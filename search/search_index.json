{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido a la Documentaci\u00f3n del desarrollor Backend del proyecto AgroInsight","text":"<p>AgroInsight es una aplicaci\u00f3n de gesti\u00f3n agr\u00edcola dise\u00f1ada para optimizar el cultivo de ma\u00edz en la regi\u00f3n del Huila, Colombia. Esta documentaci\u00f3n proporciona una gu\u00eda completa para los desarrolladores del sistema.</p>"},{"location":"#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Gesti\u00f3n de Usuarios: Sistema de registro, autenticaci\u00f3n y gesti\u00f3n de roles.</li> <li>Administraci\u00f3n de Fincas y Lotes: Herramientas para manejar la informaci\u00f3n de fincas y lotes de cultivo.</li> <li>An\u00e1lisis de Suelos: Funcionalidad para procesar y analizar datos de suelos mediante inteligencia artificial.</li> <li>Detecci\u00f3n de Plagas: Sistema de detecci\u00f3n temprana del gusano cogollero utilizando visi\u00f3n por computadora.</li> <li>Integraci\u00f3n de Datos Meteorol\u00f3gicos: Obtenci\u00f3n y an\u00e1lisis de datos clim\u00e1ticos relevantes para el cultivo.</li> <li>Recomendaciones Personalizadas: Generaci\u00f3n de recomendaciones basadas en los datos recolectados y analizados.</li> <li>Generaci\u00f3n de Informes: Creaci\u00f3n de informes detallados sobre el estado y progreso de los cultivos.</li> <li>Funcionalidad offline: Admite acceso y sincronizaci\u00f3n de datos sin conexi\u00f3n.</li> </ul>"},{"location":"#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Backend: FastAPI 0.112.1, Python 3.12</li> <li>Frontend: React Native para aplicaciones m\u00f3viles y web</li> <li>Base de Datos: PostgrSQL 15.6</li> <li>ORM: SQLAlchemy 2.0.32</li> <li>Containerization: Docker</li> <li>IA y An\u00e1lisis de Datos: TensorFlow 2.16.1, OpenCV 4.10.0</li> <li>Despliegue: Railway para backend y base de datos</li> </ul>"},{"location":"#como-usar-esta-documentacion","title":"C\u00f3mo Usar esta Documentaci\u00f3n","text":"<ul> <li>Gu\u00edas: Para empezar r\u00e1pidamente con el proyecto, consulta nuestra secci\u00f3n de gu\u00edas.</li> <li>M\u00f3dulos: Explora la documentaci\u00f3n detallada de cada m\u00f3dulo del sistema.</li> <li>API: Revisa la documentaci\u00f3n de la API generada autom\u00e1ticamente con Swagger UI y ReDoc.</li> <li>Desarrollo: Si eres desarrollador, no olvides revisar nuestras gu\u00edas de contribuci\u00f3n y est\u00e1ndares de c\u00f3digo.</li> </ul> <p>\u00a1Bienvenido al proyecto AgroInsight, tu compa\u00f1ero en la agricultura de precisi\u00f3n!</p>"},{"location":"about/","title":"Acerca de AgroInsight","text":""},{"location":"about/#introduccion","title":"Introducci\u00f3n","text":"<p>AgroInsight es una plataforma innovadora dise\u00f1ada para revolucionar la agricultura moderna mediante el uso de tecnolog\u00edas avanzadas y an\u00e1lisis de datos. Nuestro objetivo es proporcionar a los agricultores y profesionales del sector agr\u00edcola las herramientas necesarias para optimizar sus operaciones, aumentar la productividad y promover pr\u00e1cticas agr\u00edcolas sostenibles.</p>"},{"location":"about/#nuestra-mision","title":"Nuestra Misi\u00f3n","text":"<p>En AgroInsight, nos dedicamos a:</p> <ol> <li>Empoderar a los agricultores con informaci\u00f3n precisa y oportuna.</li> <li>Fomentar la agricultura de precisi\u00f3n y sostenible.</li> <li>Reducir el impacto ambiental de las pr\u00e1cticas agr\u00edcolas.</li> <li>Mejorar la eficiencia y rentabilidad de las explotaciones agr\u00edcolas.</li> </ol>"},{"location":"about/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>An\u00e1lisis de Datos Avanzado: Utilizamos algoritmos de inteligencia artificial y aprendizaje autom\u00e1tico para procesar grandes cantidades de datos agr\u00edcolas.</li> <li>Monitoreo en Tiempo Real: Ofrecemos seguimiento en tiempo real de las condiciones del cultivo, clima y suelo.</li> <li>Recomendaciones Personalizadas: Proporcionamos consejos espec\u00edficos para cada cultivo y regi\u00f3n.</li> <li>Integraci\u00f3n IoT: Compatibilidad con una amplia gama de sensores y dispositivos IoT para la recopilaci\u00f3n de datos en el campo.</li> </ul>"},{"location":"about/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<p>AgroInsight se basa en una combinaci\u00f3n de tecnolog\u00edas de vanguardia, incluyendo:</p> <ul> <li>Inteligencia Artificial y Aprendizaje Autom\u00e1tico</li> <li>Internet de las Cosas (IoT)</li> <li>Procesamiento de Im\u00e1genes Satelitales</li> <li>An\u00e1lisis de Big Data</li> <li>Computaci\u00f3n en la Nube</li> </ul>"},{"location":"about/#contacto","title":"Contacto","text":"<p>Para m\u00e1s informaci\u00f3n sobre AgroInsight, no dude en ponerse en contacto con nosotros:</p> <ul> <li>Correo Electr\u00f3nico: info@agroinsight.com</li> <li>Tel\u00e9fono: +34 900 123 456</li> <li>Sitio Web: www.agroinsight.com</li> </ul>"},{"location":"about/#contribuir","title":"Contribuir","text":"<p>AgroInsight es un proyecto de c\u00f3digo abierto y damos la bienvenida a contribuciones de la comunidad. Si est\u00e1 interesado en contribuir, por favor visite nuestra p\u00e1gina de Contribuci\u00f3n para obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo puede participar.</p> <p>\u00daltima actualizaci\u00f3n: [2024-07-20]</p>"},{"location":"complement-docs/overview/","title":"Visi\u00f3n General de AgroInsight","text":""},{"location":"complement-docs/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>AgroInsight es una plataforma innovadora dise\u00f1ada para revolucionar la agricultura mediante el uso de tecnolog\u00edas avanzadas y an\u00e1lisis de datos. Nuestro objetivo es proporcionar a los agricultores y profesionales del sector agr\u00edcola herramientas poderosas para optimizar sus operaciones, aumentar la productividad y promover pr\u00e1cticas agr\u00edcolas sostenibles.</p>"},{"location":"complement-docs/overview/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Monitoreo en tiempo real: Seguimiento continuo de las condiciones del cultivo y del suelo.</li> <li>An\u00e1lisis predictivo: Utilizaci\u00f3n de algoritmos de aprendizaje autom\u00e1tico para prever rendimientos y detectar problemas potenciales.</li> <li>Gesti\u00f3n de recursos: Optimizaci\u00f3n del uso de agua, fertilizantes y pesticidas.</li> <li>Integraci\u00f3n IoT: Conexi\u00f3n con dispositivos y sensores para recopilar datos precisos del campo.</li> <li>Informes personalizados: Generaci\u00f3n de informes detallados y visualizaciones para una toma de decisiones informada.</li> </ul>"},{"location":"complement-docs/overview/#tecnologias-utilizadas","title":"Tecnolog\u00edas utilizadas","text":"<p>AgroInsight est\u00e1 construido utilizando tecnolog\u00edas modernas y robustas, incluyendo:</p> <ul> <li>Backend: FastAPI (Python)</li> <li>Frontend: React.js</li> <li>Base de datos: PostgreSQL</li> <li>An\u00e1lisis de datos: Python (pandas, scikit-learn)</li> <li>IoT: Protocolos MQTT y CoAP</li> </ul>"},{"location":"complement-docs/overview/#como-empezar","title":"C\u00f3mo empezar","text":"<p>Para comenzar a utilizar AgroInsight, sigue estos pasos:</p> <ol> <li>Reg\u00edstrate en nuestra plataforma en www.agroinsight.com</li> <li>Configura tu perfil y a\u00f1ade los detalles de tu explotaci\u00f3n agr\u00edcola</li> <li>Conecta tus dispositivos IoT siguiendo nuestra gu\u00eda de configuraci\u00f3n</li> <li>Explora las diferentes funcionalidades y comienza a optimizar tu producci\u00f3n</li> </ol>"},{"location":"complement-docs/overview/#soporte-y-comunidad","title":"Soporte y comunidad","text":"<p>Ofrecemos soporte t\u00e9cnico a trav\u00e9s de nuestro portal de ayuda y foros de la comunidad. No dudes en contactarnos si tienes alguna pregunta o sugerencia.</p>"},{"location":"complement-docs/overview/#contribuciones","title":"Contribuciones","text":"<p>AgroInsight es un proyecto de c\u00f3digo abierto y damos la bienvenida a contribuciones de la comunidad. Si est\u00e1s interesado en contribuir, por favor consulta nuestra gu\u00eda de contribuci\u00f3n en el repositorio de GitHub.</p>"},{"location":"complement-docs/overview/#licencia","title":"Licencia","text":"<p>AgroInsight se distribuye bajo la licencia MIT. Para m\u00e1s detalles, consulta el archivo LICENSE en nuestro repositorio.</p>"},{"location":"costs/endpoints/","title":"Endpoints del M\u00f3dulo de Costos","text":""},{"location":"costs/endpoints/#registro-de-costos","title":"Registro de Costos","text":""},{"location":"costs/endpoints/#registrar-costos-de-tarea","title":"Registrar Costos de Tarea","text":"<p>Registra los costos asociados a una tarea cultural.</p> <p>Parameters:</p> Name Type Description Default <code>farm_id</code> <code>int</code> <p>ID de la finca.</p> required <code>task_id</code> <code>int</code> <p>ID de la tarea.</p> required <code>costs</code> <code>TaskCostsCreate</code> <p>Datos de los costos a registrar.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>CostRegistrationResponse</code> <code>CostRegistrationResponse</code> <p>Respuesta indicando el resultado del registro de costos.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el registro de los costos.</p> Source code in <code>app\\costs\\infrastructure\\api.py</code> <pre><code>@router.post(\"/farms/{farm_id}/tasks/{task_id}/costs\", \n            response_model=CostRegistrationResponse, \n            status_code=status.HTTP_201_CREATED)\ndef register_task_costs(\n    farm_id: int,\n    task_id: int,\n    costs: TaskCostsCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; CostRegistrationResponse:\n    \"\"\"\n    Registra los costos asociados a una tarea cultural.\n\n    Parameters:\n        farm_id (int): ID de la finca.\n        task_id (int): ID de la tarea.\n        costs (TaskCostsCreate): Datos de los costos a registrar.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        CostRegistrationResponse: Respuesta indicando el resultado del registro de costos.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el registro de los costos.\n    \"\"\"\n    register_task_costs_use_case = RegisterTaskCostsUseCase(db)\n    try:\n        return register_task_costs_use_case.register_costs(task_id, farm_id, costs, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al registrar los costos: {str(e)}\"\n        ) from e\n</code></pre> <p>Endpoint para registrar los costos asociados a una tarea cultural, incluyendo mano de obra, insumos y maquinaria.</p>"},{"location":"costs/endpoints/#gestion-de-insumos","title":"Gesti\u00f3n de Insumos","text":""},{"location":"costs/endpoints/#listar-categorias-de-insumos","title":"Listar Categor\u00edas de Insumos","text":"<p>Lista todas las categor\u00edas de insumos agr\u00edcolas.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>AgriculturalInputCategoryListResponse</code> <code>AgriculturalInputCategoryListResponse</code> <p>Lista de categor\u00edas de insumos.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de las categor\u00edas.</p> Source code in <code>app\\costs\\infrastructure\\api.py</code> <pre><code>@router.get(\"/input-categories\", response_model=AgriculturalInputCategoryListResponse, status_code=status.HTTP_200_OK)\ndef list_input_categories(\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; AgriculturalInputCategoryListResponse:\n    \"\"\"Lista todas las categor\u00edas de insumos agr\u00edcolas.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        AgriculturalInputCategoryListResponse: Lista de categor\u00edas de insumos.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de las categor\u00edas.\n    \"\"\"\n    list_categories_use_case = ListInputCategoriesUseCase(db)\n    try:\n        return list_categories_use_case.list_categories(current_user)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar las categor\u00edas de insumos: {str(e)}\"\n        ) from e\n</code></pre> <p>Endpoint para obtener todas las categor\u00edas de insumos agr\u00edcolas disponibles.</p>"},{"location":"costs/endpoints/#listar-insumos-agricolas","title":"Listar Insumos Agr\u00edcolas","text":"<p>Lista todos los insumos agr\u00edcolas.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>AgriculturalInputListResponse</code> <code>AgriculturalInputListResponse</code> <p>Lista de insumos agr\u00edcolas.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de los insumos.</p> Source code in <code>app\\costs\\infrastructure\\api.py</code> <pre><code>@router.get(\"/agricultural-inputs\", response_model=AgriculturalInputListResponse, status_code=status.HTTP_200_OK)\ndef list_agricultural_inputs(\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; AgriculturalInputListResponse:\n    \"\"\"Lista todos los insumos agr\u00edcolas.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        AgriculturalInputListResponse: Lista de insumos agr\u00edcolas.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de los insumos.\n    \"\"\"\n    list_inputs_use_case = ListAgriculturalInputsUseCase(db)\n    try:\n        return list_inputs_use_case.list_inputs(current_user)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar los insumos agr\u00edcolas: {str(e)}\"\n        ) from e\n</code></pre> <p>Endpoint para obtener todos los insumos agr\u00edcolas disponibles.</p>"},{"location":"costs/endpoints/#gestion-de-maquinaria","title":"Gesti\u00f3n de Maquinaria","text":""},{"location":"costs/endpoints/#listar-tipos-de-maquinaria","title":"Listar Tipos de Maquinaria","text":"<p>Lista todos los tipos de maquinaria agr\u00edcola.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>MachineryTypeListResponse</code> <code>MachineryTypeListResponse</code> <p>Lista de tipos de maquinaria.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de los tipos de maquinaria.</p> Source code in <code>app\\costs\\infrastructure\\api.py</code> <pre><code>@router.get(\"/machinery-types\", response_model=MachineryTypeListResponse, status_code=status.HTTP_200_OK)\ndef list_machinery_types(\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; MachineryTypeListResponse:\n    \"\"\"Lista todos los tipos de maquinaria agr\u00edcola.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        MachineryTypeListResponse: Lista de tipos de maquinaria.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de los tipos de maquinaria.\n    \"\"\"\n    list_machinery_types_use_case = ListMachineryTypesUseCase(db)\n    try:\n        return list_machinery_types_use_case.list_machinery_types(current_user)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar los tipos de maquinaria: {str(e)}\"\n        ) from e\n</code></pre> <p>Endpoint para obtener todos los tipos de maquinaria agr\u00edcola.</p>"},{"location":"costs/endpoints/#listar-maquinaria-agricola","title":"Listar Maquinaria Agr\u00edcola","text":"<p>Lista toda la maquinaria agr\u00edcola.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>AgriculturalMachineryListResponse</code> <code>AgriculturalMachineryListResponse</code> <p>Lista de maquinaria agr\u00edcola.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de la maquinaria.</p> Source code in <code>app\\costs\\infrastructure\\api.py</code> <pre><code>@router.get(\"/agricultural-machinery\", response_model=AgriculturalMachineryListResponse, status_code=status.HTTP_200_OK)\ndef list_agricultural_machinery(\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; AgriculturalMachineryListResponse:\n    \"\"\"Lista toda la maquinaria agr\u00edcola.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        AgriculturalMachineryListResponse: Lista de maquinaria agr\u00edcola.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de la maquinaria.\n    \"\"\"\n    list_machinery_use_case = ListAgriculturalMachineryUseCase(db)\n    try:\n        return list_machinery_use_case.list_machinery(current_user)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar la maquinaria agr\u00edcola: {str(e)}\"\n        ) from e\n</code></pre> <p>Endpoint para obtener toda la maquinaria agr\u00edcola disponible.</p>"},{"location":"costs/models/","title":"Modelos del M\u00f3dulo de Costos","text":""},{"location":"costs/models/#modelos-de-base-de-datos","title":"Modelos de Base de Datos","text":""},{"location":"costs/models/#costo-de-mano-de-obra-laborcost","title":"Costo de Mano de Obra (LaborCost)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo de costo de mano de obra para una tarea cultural.</p> Source code in <code>app\\costs\\infrastructure\\orm_models.py</code> <pre><code>class LaborCost(Base):\n    \"\"\"Modelo de costo de mano de obra para una tarea cultural.\"\"\"\n    __tablename__ = \"costo_mano_obra\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tarea_labor_id = Column(Integer, ForeignKey(\"tarea_labor_cultural.id\"), unique=True, nullable=False)\n    cantidad_trabajadores = Column(Integer, nullable=False)\n    horas_trabajadas = Column(DECIMAL(5,2), nullable=False)\n    costo_hora = Column(DECIMAL(10,2), nullable=False)\n    costo_total = Column(DECIMAL(10,2), nullable=False)\n    observaciones = Column(Text)\n\n    # Relaci\u00f3n con CulturalTask\n    tarea = relationship(\"CulturalTask\", back_populates=\"costo_mano_obra\")\n</code></pre> <p>Modelo que representa los costos de mano de obra asociados a una tarea cultural.</p>"},{"location":"costs/models/#categoria-de-insumo-agricola-agriculturalinputcategory","title":"Categor\u00eda de Insumo Agr\u00edcola (AgriculturalInputCategory)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo de categor\u00eda de insumos agr\u00edcolas.</p> Source code in <code>app\\costs\\infrastructure\\orm_models.py</code> <pre><code>class AgriculturalInputCategory(Base):\n    \"\"\"Modelo de categor\u00eda de insumos agr\u00edcolas.\"\"\"\n    __tablename__ = \"categoria_insumo_agricola\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(100), unique=True, nullable=False)\n    descripcion = Column(Text)\n\n    # Relaci\u00f3n con AgriculturalInput\n    insumos = relationship(\"AgriculturalInput\", back_populates=\"categoria\")\n</code></pre> <p>Modelo que representa las categor\u00edas de insumos agr\u00edcolas disponibles.</p>"},{"location":"costs/models/#insumo-agricola-agriculturalinput","title":"Insumo Agr\u00edcola (AgriculturalInput)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo de insumo agr\u00edcola.</p> Source code in <code>app\\costs\\infrastructure\\orm_models.py</code> <pre><code>class AgriculturalInput(Base):\n    \"\"\"Modelo de insumo agr\u00edcola.\"\"\"\n    __tablename__ = \"insumo_agricola\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    categoria_id = Column(Integer, ForeignKey(\"categoria_insumo_agricola.id\"), nullable=False)\n    nombre = Column(String(100), nullable=False)\n    descripcion = Column(Text)\n    unidad_medida_id = Column(Integer, ForeignKey(\"unidad_medida.id\"), nullable=False)\n    costo_unitario = Column(DECIMAL(10,2), nullable=False)\n    stock_actual = Column(DECIMAL(10,2), nullable=False, default=0)\n\n    # Relaciones\n    categoria = relationship(\"AgriculturalInputCategory\", back_populates=\"insumos\")\n    unidad_medida = relationship(\"UnitOfMeasure\")\n    usos_tarea = relationship(\"TaskInput\", back_populates=\"insumo\")\n</code></pre> <p>Modelo que representa los insumos agr\u00edcolas y sus caracter\u00edsticas.</p>"},{"location":"costs/models/#uso-de-insumo-en-tarea-taskinput","title":"Uso de Insumo en Tarea (TaskInput)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo de uso de insumo en una tarea.</p> Source code in <code>app\\costs\\infrastructure\\orm_models.py</code> <pre><code>class TaskInput(Base):\n    \"\"\"Modelo de uso de insumo en una tarea.\"\"\"\n    __tablename__ = \"tarea_insumo\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tarea_labor_id = Column(Integer, ForeignKey(\"tarea_labor_cultural.id\"), nullable=False)\n    insumo_id = Column(Integer, ForeignKey(\"insumo_agricola.id\"), nullable=False)\n    cantidad_utilizada = Column(DECIMAL(10,2), nullable=False)\n    costo_total = Column(DECIMAL(10,2), nullable=False)\n    fecha_aplicacion = Column(Date, nullable=True)\n    observaciones = Column(Text)\n\n    # Relaciones\n    tarea = relationship(\"CulturalTask\", back_populates=\"insumos\")\n    insumo = relationship(\"AgriculturalInput\", back_populates=\"usos_tarea\")\n</code></pre> <p>Modelo que registra el uso de insumos en tareas espec\u00edficas.</p>"},{"location":"costs/models/#tipo-de-maquinaria-machinerytype","title":"Tipo de Maquinaria (MachineryType)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo de tipo de maquinaria agr\u00edcola.</p> Source code in <code>app\\costs\\infrastructure\\orm_models.py</code> <pre><code>class MachineryType(Base):\n    \"\"\"Modelo de tipo de maquinaria agr\u00edcola.\"\"\"\n    __tablename__ = \"tipo_maquinaria_agricola\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(255), nullable=False)\n    descripcion = Column(String(255), nullable=False)\n\n    # Relaci\u00f3n con AgriculturalMachinery\n    maquinarias = relationship(\"AgriculturalMachinery\", back_populates=\"tipo_maquinaria\")\n</code></pre> <p>Modelo que representa los diferentes tipos de maquinaria agr\u00edcola.</p>"},{"location":"costs/models/#maquinaria-agricola-agriculturalmachinery","title":"Maquinaria Agr\u00edcola (AgriculturalMachinery)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo de maquinaria agr\u00edcola.</p> Source code in <code>app\\costs\\infrastructure\\orm_models.py</code> <pre><code>class AgriculturalMachinery(Base):\n    \"\"\"Modelo de maquinaria agr\u00edcola.\"\"\"\n    __tablename__ = \"maquinaria_agricola\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tipo_maquinaria_id = Column(Integer, ForeignKey(\"tipo_maquinaria_agricola.id\"), nullable=False)\n    nombre = Column(String(100), nullable=False)\n    descripcion = Column(Text)\n    modelo = Column(String(100))\n    numero_serie = Column(String(100))\n    costo_hora = Column(DECIMAL(10,2), nullable=False)\n\n    # Relaciones\n    tipo_maquinaria = relationship(\"MachineryType\", back_populates=\"maquinarias\")\n    usos_tarea = relationship(\"TaskMachinery\", back_populates=\"maquinaria\")\n</code></pre> <p>Modelo que representa la maquinaria agr\u00edcola disponible.</p>"},{"location":"costs/models/#uso-de-maquinaria-en-tarea-taskmachinery","title":"Uso de Maquinaria en Tarea (TaskMachinery)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo de uso de maquinaria en una tarea.</p> Source code in <code>app\\costs\\infrastructure\\orm_models.py</code> <pre><code>class TaskMachinery(Base):\n    \"\"\"Modelo de uso de maquinaria en una tarea.\"\"\"\n    __tablename__ = \"tarea_maquinaria\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    tarea_labor_id = Column(Integer, ForeignKey(\"tarea_labor_cultural.id\"), nullable=False)\n    maquinaria_id = Column(Integer, ForeignKey(\"maquinaria_agricola.id\"), nullable=False)\n    fecha_uso = Column(Date, nullable=True)\n    horas_uso = Column(DECIMAL(5,2), nullable=False)\n    costo_total = Column(DECIMAL(10,2), nullable=False)\n    observaciones = Column(Text)\n\n    # Relaciones\n    tarea = relationship(\"CulturalTask\", back_populates=\"maquinarias\")\n    maquinaria = relationship(\"AgriculturalMachinery\", back_populates=\"usos_tarea\")\n</code></pre> <p>Modelo que registra el uso de maquinaria en tareas espec\u00edficas.</p>"},{"location":"costs/models/#esquemas-de-datos","title":"Esquemas de Datos","text":""},{"location":"costs/models/#creacion-de-costo-de-mano-de-obra","title":"Creaci\u00f3n de Costo de Mano de Obra","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo para la creaci\u00f3n de costos de mano de obra.</p> <p>Attributes:</p> Name Type Description <code>cantidad_trabajadores</code> <code>int</code> <p>N\u00famero de trabajadores.</p> <code>horas_trabajadas</code> <code>Decimal</code> <p>Horas trabajadas.</p> <code>costo_hora</code> <code>Decimal</code> <p>Costo por hora.</p> <code>observaciones</code> <code>Optional[str]</code> <p>Observaciones adicionales.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class LaborCostCreate(BaseModel):\n    \"\"\"Modelo para la creaci\u00f3n de costos de mano de obra.\n\n    Attributes:\n        cantidad_trabajadores (int): N\u00famero de trabajadores.\n        horas_trabajadas (Decimal): Horas trabajadas.\n        costo_hora (Decimal): Costo por hora.\n        observaciones (Optional[str]): Observaciones adicionales.\n    \"\"\"\n    cantidad_trabajadores: int = Field(..., gt=0)\n    horas_trabajadas: Decimal = Field(..., gt=0)\n    costo_hora: Decimal = Field(..., gt=0)\n    observaciones: Optional[str] = None\n</code></pre>"},{"location":"costs/models/#creacion-de-uso-de-insumo","title":"Creaci\u00f3n de Uso de Insumo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo para la creaci\u00f3n de costos de insumos.</p> <p>Attributes:</p> Name Type Description <code>insumo_id</code> <code>int</code> <p>ID del insumo utilizado.</p> <code>cantidad_utilizada</code> <code>Decimal</code> <p>Cantidad utilizada del insumo.</p> <code>fecha_aplicacion</code> <code>date</code> <p>Fecha de aplicaci\u00f3n del insumo.</p> <code>observaciones</code> <code>Optional[str]</code> <p>Observaciones adicionales.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class TaskInputCreate(BaseModel):\n    \"\"\"Modelo para la creaci\u00f3n de costos de insumos.\n\n    Attributes:\n        insumo_id (int): ID del insumo utilizado.\n        cantidad_utilizada (Decimal): Cantidad utilizada del insumo.\n        fecha_aplicacion (date): Fecha de aplicaci\u00f3n del insumo.\n        observaciones (Optional[str]): Observaciones adicionales.\n    \"\"\"\n    insumo_id: int\n    cantidad_utilizada: Decimal = Field(..., gt=0)\n    fecha_aplicacion: Optional[date] = None\n    observaciones: Optional[str] = None\n</code></pre>"},{"location":"costs/models/#creacion-de-uso-de-maquinaria","title":"Creaci\u00f3n de Uso de Maquinaria","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo para la creaci\u00f3n de costos de maquinaria.</p> <p>Attributes:</p> Name Type Description <code>maquinaria_id</code> <code>int</code> <p>ID de la maquinaria utilizada.</p> <code>fecha_uso</code> <code>date</code> <p>Fecha de uso de la maquinaria.</p> <code>horas_uso</code> <code>Decimal</code> <p>Horas de uso de la maquinaria.</p> <code>observaciones</code> <code>Optional[str]</code> <p>Observaciones adicionales.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class TaskMachineryCreate(BaseModel):\n    \"\"\"Modelo para la creaci\u00f3n de costos de maquinaria.\n\n    Attributes:\n        maquinaria_id (int): ID de la maquinaria utilizada.\n        fecha_uso (date): Fecha de uso de la maquinaria.\n        horas_uso (Decimal): Horas de uso de la maquinaria.\n        observaciones (Optional[str]): Observaciones adicionales.\n    \"\"\"\n    maquinaria_id: int\n    fecha_uso: Optional[date] = None\n    horas_uso: Decimal = Field(..., gt=0)\n    observaciones: Optional[str] = None\n</code></pre>"},{"location":"costs/models/#creacion-de-costos-de-tarea","title":"Creaci\u00f3n de Costos de Tarea","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo para la creaci\u00f3n de todos los costos asociados a una tarea.</p> <p>Attributes:</p> Name Type Description <code>labor_cost</code> <code>Optional[LaborCostCreate]</code> <p>Costos de mano de obra.</p> <code>inputs</code> <code>Optional[List[TaskInputCreate]]</code> <p>Lista de insumos utilizados.</p> <code>machinery</code> <code>Optional[List[TaskMachineryCreate]]</code> <p>Lista de maquinaria utilizada.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class TaskCostsCreate(BaseModel):\n    \"\"\"Modelo para la creaci\u00f3n de todos los costos asociados a una tarea.\n\n    Attributes:\n        labor_cost (Optional[LaborCostCreate]): Costos de mano de obra.\n        inputs (Optional[List[TaskInputCreate]]): Lista de insumos utilizados.\n        machinery (Optional[List[TaskMachineryCreate]]): Lista de maquinaria utilizada.\n    \"\"\"\n    labor_cost: Optional[LaborCostCreate] = None\n    inputs: Optional[List[TaskInputCreate]] = None\n    machinery: Optional[List[TaskMachineryCreate]] = None\n</code></pre>"},{"location":"costs/models/#respuesta-de-registro-de-costos","title":"Respuesta de Registro de Costos","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo de respuesta para el registro de costos.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>str: Mensaje de \u00e9xito.</p> <code>labor_cost_registered</code> <code>bool</code> <p>bool: Indica si se registraron costos de mano de obra.</p> <code>inputs_registered</code> <code>int</code> <p>int: Cantidad de insumos registrados.</p> <code>machinery_registered</code> <code>int</code> <p>int: Cantidad de maquinaria registrada.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class CostRegistrationResponse(BaseModel):\n    \"\"\"Modelo de respuesta para el registro de costos.\n\n    Attributes:\n        message: str: Mensaje de \u00e9xito.\n        labor_cost_registered: bool: Indica si se registraron costos de mano de obra.\n        inputs_registered: int: Cantidad de insumos registrados.\n        machinery_registered: int: Cantidad de maquinaria registrada.\n    \"\"\"\n    message: str\n    labor_cost_registered: bool\n    inputs_registered: int\n    machinery_registered: int\n</code></pre>"},{"location":"costs/models/#respuesta-de-categoria-de-insumo","title":"Respuesta de Categor\u00eda de Insumo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo de respuesta para una categor\u00eda de insumo agr\u00edcola.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>ID \u00fanico de la categor\u00eda.</p> <code>nombre</code> <code>str</code> <p>Nombre de la categor\u00eda.</p> <code>descripcion</code> <code>Optional[str]</code> <p>Descripci\u00f3n de la categor\u00eda.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class AgriculturalInputCategoryResponse(BaseModel):\n    \"\"\"Modelo de respuesta para una categor\u00eda de insumo agr\u00edcola.\n\n    Attributes:\n        id (int): ID \u00fanico de la categor\u00eda.\n        nombre (str): Nombre de la categor\u00eda.\n        descripcion (Optional[str]): Descripci\u00f3n de la categor\u00eda.\n    \"\"\"\n    id: int\n    nombre: str\n    descripcion: Optional[str] = None\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"costs/models/#respuesta-de-insumo-agricola","title":"Respuesta de Insumo Agr\u00edcola","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo de respuesta para un insumo agr\u00edcola.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>ID \u00fanico del insumo.</p> <code>categoria_id</code> <code>int</code> <p>ID de la categor\u00eda del insumo.</p> <code>categoria_nombre</code> <code>str</code> <p>Nombre de la categor\u00eda del insumo.</p> <code>nombre</code> <code>str</code> <p>Nombre del insumo.</p> <code>descripcion</code> <code>Optional[str]</code> <p>Descripci\u00f3n del insumo.</p> <code>unidad_medida_id</code> <code>int</code> <p>ID de la unidad de medida.</p> <code>unidad_medida_nombre</code> <code>str</code> <p>Nombre de la unidad de medida.</p> <code>costo_unitario</code> <code>Decimal</code> <p>Costo por unidad del insumo.</p> <code>stock_actual</code> <code>Decimal</code> <p>Cantidad actual en stock.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class AgriculturalInputResponse(BaseModel):\n    \"\"\"Modelo de respuesta para un insumo agr\u00edcola.\n\n    Attributes:\n        id (int): ID \u00fanico del insumo.\n        categoria_id (int): ID de la categor\u00eda del insumo.\n        categoria_nombre (str): Nombre de la categor\u00eda del insumo.\n        nombre (str): Nombre del insumo.\n        descripcion (Optional[str]): Descripci\u00f3n del insumo.\n        unidad_medida_id (int): ID de la unidad de medida.\n        unidad_medida_nombre (str): Nombre de la unidad de medida.\n        costo_unitario (Decimal): Costo por unidad del insumo.\n        stock_actual (Decimal): Cantidad actual en stock.\n    \"\"\"\n    id: int\n    categoria_id: int\n    categoria_nombre: str\n    nombre: str\n    descripcion: Optional[str] = None\n    unidad_medida_id: int\n    unidad_medida_nombre: str\n    costo_unitario: Decimal\n    stock_actual: Decimal\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"costs/models/#respuesta-de-tipo-de-maquinaria","title":"Respuesta de Tipo de Maquinaria","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo de respuesta para un tipo de maquinaria.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>ID \u00fanico del tipo de maquinaria.</p> <code>nombre</code> <code>str</code> <p>Nombre del tipo de maquinaria.</p> <code>descripcion</code> <code>str</code> <p>Descripci\u00f3n del tipo de maquinaria.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class MachineryTypeResponse(BaseModel):\n    \"\"\"Modelo de respuesta para un tipo de maquinaria.\n\n    Attributes:\n        id (int): ID \u00fanico del tipo de maquinaria.\n        nombre (str): Nombre del tipo de maquinaria.\n        descripcion (str): Descripci\u00f3n del tipo de maquinaria.\n    \"\"\"\n    id: int\n    nombre: str\n    descripcion: str\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"costs/models/#respuesta-de-maquinaria-agricola","title":"Respuesta de Maquinaria Agr\u00edcola","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo de respuesta para una maquinaria agr\u00edcola.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>ID \u00fanico de la maquinaria.</p> <code>tipo_maquinaria_id</code> <code>int</code> <p>ID del tipo de maquinaria.</p> <code>tipo_maquinaria_nombre</code> <code>str</code> <p>Nombre del tipo de maquinaria.</p> <code>nombre</code> <code>str</code> <p>Nombre de la maquinaria.</p> <code>descripcion</code> <code>Optional[str]</code> <p>Descripci\u00f3n de la maquinaria.</p> <code>modelo</code> <code>Optional[str]</code> <p>Modelo de la maquinaria.</p> <code>numero_serie</code> <code>Optional[str]</code> <p>N\u00famero de serie de la maquinaria.</p> <code>costo_hora</code> <code>Decimal</code> <p>Costo por hora de la maquinaria.</p> Source code in <code>app\\costs\\domain\\schemas.py</code> <pre><code>class AgriculturalMachineryResponse(BaseModel):\n    \"\"\"Modelo de respuesta para una maquinaria agr\u00edcola.\n\n    Attributes:\n        id (int): ID \u00fanico de la maquinaria.\n        tipo_maquinaria_id (int): ID del tipo de maquinaria.\n        tipo_maquinaria_nombre (str): Nombre del tipo de maquinaria.\n        nombre (str): Nombre de la maquinaria.\n        descripcion (Optional[str]): Descripci\u00f3n de la maquinaria.\n        modelo (Optional[str]): Modelo de la maquinaria.\n        numero_serie (Optional[str]): N\u00famero de serie de la maquinaria.\n        costo_hora (Decimal): Costo por hora de la maquinaria.\n    \"\"\"\n    id: int\n    tipo_maquinaria_id: int\n    tipo_maquinaria_nombre: str\n    nombre: str\n    descripcion: Optional[str] = None\n    modelo: Optional[str] = None\n    numero_serie: Optional[str] = None\n    costo_hora: Decimal\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"costs/overview/","title":"Visi\u00f3n General del M\u00f3dulo de Costos","text":""},{"location":"costs/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>El m\u00f3dulo de Costos es una parte fundamental del sistema AgroInsight que gestiona todo lo relacionado con los costos de las pr\u00e1cticas culturales, incluyendo mano de obra, insumos agr\u00edcolas y maquinaria. Este m\u00f3dulo permite un seguimiento detallado de los gastos asociados a la producci\u00f3n agr\u00edcola.</p>"},{"location":"costs/overview/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"costs/overview/#1-gestion-de-costos-de-mano-de-obra","title":"1. Gesti\u00f3n de Costos de Mano de Obra","text":"<ul> <li>Registro de cantidad de trabajadores</li> <li>Control de horas trabajadas</li> <li>C\u00e1lculo de costos por hora</li> <li>Seguimiento de costos totales</li> </ul>"},{"location":"costs/overview/#2-gestion-de-insumos-agricolas","title":"2. Gesti\u00f3n de Insumos Agr\u00edcolas","text":"<ul> <li>Cat\u00e1logo de insumos por categor\u00edas</li> <li>Control de stock</li> <li>Registro de costos unitarios</li> <li>Seguimiento de aplicaciones</li> </ul>"},{"location":"costs/overview/#3-gestion-de-maquinaria","title":"3. Gesti\u00f3n de Maquinaria","text":"<ul> <li>Registro de tipos de maquinaria</li> <li>Control de horas de uso</li> <li>C\u00e1lculo de costos por hora</li> <li>Seguimiento de mantenimiento</li> </ul>"},{"location":"costs/overview/#4-registro-de-costos-por-tarea","title":"4. Registro de Costos por Tarea","text":"<ul> <li>Asignaci\u00f3n de costos a tareas espec\u00edficas</li> <li>C\u00e1lculo autom\u00e1tico de costos totales</li> <li>Seguimiento de gastos por actividad</li> <li>Generaci\u00f3n de reportes de costos</li> </ul>"},{"location":"costs/overview/#integracion-con-otros-modulos","title":"Integraci\u00f3n con Otros M\u00f3dulos","text":"<p>El m\u00f3dulo de Costos se integra con:</p> <ul> <li>M\u00f3dulo de Pr\u00e1cticas Culturales: Para asignar costos a tareas espec\u00edficas</li> <li>M\u00f3dulo de Cultivos: Para el seguimiento de costos por cultivo</li> <li>M\u00f3dulo de Fincas: Para la gesti\u00f3n de costos a nivel de finca</li> </ul>"},{"location":"costs/overview/#casos-de-uso-comunes","title":"Casos de Uso Comunes","text":"<ol> <li>Registro de costos de mano de obra</li> <li>Asignaci\u00f3n de insumos a tareas</li> <li>Control de uso de maquinaria</li> <li>Generaci\u00f3n de reportes de costos</li> <li>An\u00e1lisis de rentabilidad</li> </ol>"},{"location":"costs/overview/#estructura-tecnica","title":"Estructura T\u00e9cnica","text":"<p>El m\u00f3dulo sigue una arquitectura limpia con:</p> <ul> <li>Domain: Definici\u00f3n de entidades y reglas de negocio</li> <li>Application: Implementaci\u00f3n de casos de uso</li> <li>Infrastructure: Acceso a datos y servicios externos</li> </ul>"},{"location":"costs/overview/#documentacion-relacionada","title":"Documentaci\u00f3n Relacionada","text":"<ul> <li>Endpoints de Costos</li> <li>Modelos de Datos</li> <li>Casos de Uso</li> </ul>"},{"location":"costs/use_cases/","title":"Casos de Uso del M\u00f3dulo de Costos","text":""},{"location":"costs/use_cases/#registro-de-costos","title":"Registro de Costos","text":""},{"location":"costs/use_cases/#caso-de-uso-registrar-costos-de-tarea","title":"Caso de Uso: Registrar Costos de Tarea","text":"<p>Caso de uso para registrar los costos asociados a una tarea cultural.</p> Source code in <code>app\\costs\\application\\register_task_costs_use_case.py</code> <pre><code>class RegisterTaskCostsUseCase:\n    \"\"\"Caso de uso para registrar los costos asociados a una tarea cultural.\"\"\"\n\n    def __init__(self, db: Session):\n        self.db = db\n        self.costs_repository = CostsRepository(db)\n        self.cultural_practices_repository = CulturalPracticesRepository(db)\n        self.farm_service = FarmService(db)\n\n    def register_costs(self, task_id: int, farm_id: int, costs: TaskCostsCreate, current_user: UserInDB) -&gt; CostRegistrationResponse:\n        \"\"\"Registra los costos asociados a una tarea cultural.\n\n        Args:\n            task_id (int): ID de la tarea.\n            farm_id (int): ID de la finca.\n            costs (TaskCostsCreate): Datos de los costos a registrar.\n            current_user (UserInDB): Usuario actual.\n\n        Returns:\n            CostRegistrationResponse: Respuesta con el resultado del registro de costos.\n\n        Raises:\n            DomainException: Si hay errores de validaci\u00f3n o permisos.\n        \"\"\"\n        # Validar que la tarea existe\n        task = self.cultural_practices_repository.get_task_by_id(task_id)\n        if not task:\n            raise DomainException(\n                message=\"La tarea especificada no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar que el usuario es administrador de la finca\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n            raise DomainException(\n                message=\"No tienes permisos para registrar costos en esta finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        labor_cost_registered = False\n        inputs_registered = 0\n        machinery_registered = 0\n\n        # Registrar costo de mano de obra\n        if costs.labor_cost:\n            labor_cost_registered = self.costs_repository.create_labor_cost(\n                task_id, costs.labor_cost\n            )\n\n        # Registrar costos de insumos\n        if costs.inputs:\n            for input_data in costs.inputs:\n                costo_unitario = self.costs_repository.get_input_cost(input_data.insumo_id)\n                if not costo_unitario:\n                    continue\n\n                costo_total = costo_unitario * input_data.cantidad_utilizada\n                if self.costs_repository.create_task_input(task_id, input_data, costo_total):\n                    inputs_registered += 1\n\n        # Registrar costos de maquinaria\n        if costs.machinery:\n            for machinery_data in costs.machinery:\n                costo_hora = self.costs_repository.get_machinery_cost_per_hour(\n                    machinery_data.maquinaria_id\n                )\n                if not costo_hora:\n                    continue\n\n                costo_total = costo_hora * machinery_data.horas_uso\n                if self.costs_repository.create_task_machinery(task_id, machinery_data, costo_total):\n                    machinery_registered += 1\n\n        return CostRegistrationResponse(\n            message=\"Costos registrados exitosamente\",\n            labor_cost_registered=labor_cost_registered,\n            inputs_registered=inputs_registered,\n            machinery_registered=machinery_registered\n        )\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para registrar los costos asociados a una tarea cultural, incluyendo:</p> <ul> <li>Validaci\u00f3n de permisos del usuario</li> <li>Verificaci\u00f3n de la existencia de la tarea</li> <li>Registro de costos de mano de obra</li> <li>Registro de uso de insumos</li> <li>Registro de uso de maquinaria</li> </ul>"},{"location":"costs/use_cases/#app.costs.application.register_task_costs_use_case.RegisterTaskCostsUseCase.register_costs","title":"<code>register_costs(task_id, farm_id, costs, current_user)</code>","text":"<p>Registra los costos asociados a una tarea cultural.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea.</p> required <code>farm_id</code> <code>int</code> <p>ID de la finca.</p> required <code>costs</code> <code>TaskCostsCreate</code> <p>Datos de los costos a registrar.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario actual.</p> required <p>Returns:</p> Name Type Description <code>CostRegistrationResponse</code> <code>CostRegistrationResponse</code> <p>Respuesta con el resultado del registro de costos.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si hay errores de validaci\u00f3n o permisos.</p> Source code in <code>app\\costs\\application\\register_task_costs_use_case.py</code> <pre><code>def register_costs(self, task_id: int, farm_id: int, costs: TaskCostsCreate, current_user: UserInDB) -&gt; CostRegistrationResponse:\n    \"\"\"Registra los costos asociados a una tarea cultural.\n\n    Args:\n        task_id (int): ID de la tarea.\n        farm_id (int): ID de la finca.\n        costs (TaskCostsCreate): Datos de los costos a registrar.\n        current_user (UserInDB): Usuario actual.\n\n    Returns:\n        CostRegistrationResponse: Respuesta con el resultado del registro de costos.\n\n    Raises:\n        DomainException: Si hay errores de validaci\u00f3n o permisos.\n    \"\"\"\n    # Validar que la tarea existe\n    task = self.cultural_practices_repository.get_task_by_id(task_id)\n    if not task:\n        raise DomainException(\n            message=\"La tarea especificada no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar que el usuario es administrador de la finca\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n        raise DomainException(\n            message=\"No tienes permisos para registrar costos en esta finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    labor_cost_registered = False\n    inputs_registered = 0\n    machinery_registered = 0\n\n    # Registrar costo de mano de obra\n    if costs.labor_cost:\n        labor_cost_registered = self.costs_repository.create_labor_cost(\n            task_id, costs.labor_cost\n        )\n\n    # Registrar costos de insumos\n    if costs.inputs:\n        for input_data in costs.inputs:\n            costo_unitario = self.costs_repository.get_input_cost(input_data.insumo_id)\n            if not costo_unitario:\n                continue\n\n            costo_total = costo_unitario * input_data.cantidad_utilizada\n            if self.costs_repository.create_task_input(task_id, input_data, costo_total):\n                inputs_registered += 1\n\n    # Registrar costos de maquinaria\n    if costs.machinery:\n        for machinery_data in costs.machinery:\n            costo_hora = self.costs_repository.get_machinery_cost_per_hour(\n                machinery_data.maquinaria_id\n            )\n            if not costo_hora:\n                continue\n\n            costo_total = costo_hora * machinery_data.horas_uso\n            if self.costs_repository.create_task_machinery(task_id, machinery_data, costo_total):\n                machinery_registered += 1\n\n    return CostRegistrationResponse(\n        message=\"Costos registrados exitosamente\",\n        labor_cost_registered=labor_cost_registered,\n        inputs_registered=inputs_registered,\n        machinery_registered=machinery_registered\n    )\n</code></pre>"},{"location":"costs/use_cases/#gestion-de-insumos","title":"Gesti\u00f3n de Insumos","text":""},{"location":"costs/use_cases/#caso-de-uso-listar-categorias-de-insumos","title":"Caso de Uso: Listar Categor\u00edas de Insumos","text":"<p>Caso de uso para listar las categor\u00edas de insumos agr\u00edcolas.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todas las categor\u00edas de insumos, asegurando que se cumplan las validaciones necesarias antes de devolver la lista.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> Source code in <code>app\\costs\\application\\list_input_categories_use_case.py</code> <pre><code>class ListInputCategoriesUseCase:\n    \"\"\"Caso de uso para listar las categor\u00edas de insumos agr\u00edcolas.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todas las categor\u00edas de insumos,\n    asegurando que se cumplan las validaciones necesarias antes de devolver la lista.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n        self.db = db\n        self.costs_repository = CostsRepository(db)\n\n    def list_categories(self, current_user: UserInDB) -&gt; AgriculturalInputCategoryListResponse:\n        \"\"\"Lista todas las categor\u00edas de insumos agr\u00edcolas.\n\n        Args:\n            current_user (UserInDB): Usuario actual autenticado.\n\n        Returns:\n            AgriculturalInputCategoryListResponse: Lista de categor\u00edas de insumos.\n        \"\"\"\n        categories = self.costs_repository.get_input_categories()\n        category_responses = [map_input_category_to_response(category) for category in categories]\n        return AgriculturalInputCategoryListResponse(categories=category_responses)\n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_input_categories_use_case.ListInputCategoriesUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> Source code in <code>app\\costs\\application\\list_input_categories_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n    self.db = db\n    self.costs_repository = CostsRepository(db)\n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_input_categories_use_case.ListInputCategoriesUseCase.list_categories","title":"<code>list_categories(current_user)</code>","text":"<p>Lista todas las categor\u00edas de insumos agr\u00edcolas.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>AgriculturalInputCategoryListResponse</code> <code>AgriculturalInputCategoryListResponse</code> <p>Lista de categor\u00edas de insumos.</p> Source code in <code>app\\costs\\application\\list_input_categories_use_case.py</code> <pre><code>def list_categories(self, current_user: UserInDB) -&gt; AgriculturalInputCategoryListResponse:\n    \"\"\"Lista todas las categor\u00edas de insumos agr\u00edcolas.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        AgriculturalInputCategoryListResponse: Lista de categor\u00edas de insumos.\n    \"\"\"\n    categories = self.costs_repository.get_input_categories()\n    category_responses = [map_input_category_to_response(category) for category in categories]\n    return AgriculturalInputCategoryListResponse(categories=category_responses)\n</code></pre>"},{"location":"costs/use_cases/#caso-de-uso-listar-insumos-agricolas","title":"Caso de Uso: Listar Insumos Agr\u00edcolas","text":"<p>Caso de uso para listar los insumos agr\u00edcolas.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todos los insumos agr\u00edcolas, asegurando que se cumplan las validaciones necesarias antes de devolver la lista.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> Source code in <code>app\\costs\\application\\list_agricultural_inputs_use_case.py</code> <pre><code>class ListAgriculturalInputsUseCase:\n    \"\"\"Caso de uso para listar los insumos agr\u00edcolas.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todos los insumos agr\u00edcolas,\n    asegurando que se cumplan las validaciones necesarias antes de devolver la lista.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n        self.db = db\n        self.costs_repository = CostsRepository(db)\n\n    def list_inputs(self, current_user: UserInDB) -&gt; AgriculturalInputListResponse:\n        \"\"\"Lista todos los insumos agr\u00edcolas.\n\n        Args:\n            current_user (UserInDB): Usuario actual autenticado.\n\n        Returns:\n            AgriculturalInputListResponse: Lista de insumos agr\u00edcolas.\n        \"\"\"\n        inputs = self.costs_repository.get_agricultural_inputs()\n        input_responses = [map_agricultural_input_to_response(input) for input in inputs]\n        return AgriculturalInputListResponse(inputs=input_responses) \n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_agricultural_inputs_use_case.ListAgriculturalInputsUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> Source code in <code>app\\costs\\application\\list_agricultural_inputs_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n    self.db = db\n    self.costs_repository = CostsRepository(db)\n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_agricultural_inputs_use_case.ListAgriculturalInputsUseCase.list_inputs","title":"<code>list_inputs(current_user)</code>","text":"<p>Lista todos los insumos agr\u00edcolas.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>AgriculturalInputListResponse</code> <code>AgriculturalInputListResponse</code> <p>Lista de insumos agr\u00edcolas.</p> Source code in <code>app\\costs\\application\\list_agricultural_inputs_use_case.py</code> <pre><code>def list_inputs(self, current_user: UserInDB) -&gt; AgriculturalInputListResponse:\n    \"\"\"Lista todos los insumos agr\u00edcolas.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        AgriculturalInputListResponse: Lista de insumos agr\u00edcolas.\n    \"\"\"\n    inputs = self.costs_repository.get_agricultural_inputs()\n    input_responses = [map_agricultural_input_to_response(input) for input in inputs]\n    return AgriculturalInputListResponse(inputs=input_responses) \n</code></pre>"},{"location":"costs/use_cases/#gestion-de-maquinaria","title":"Gesti\u00f3n de Maquinaria","text":""},{"location":"costs/use_cases/#caso-de-uso-listar-tipos-de-maquinaria","title":"Caso de Uso: Listar Tipos de Maquinaria","text":"<p>Caso de uso para listar los tipos de maquinaria agr\u00edcola.</p> Source code in <code>app\\costs\\application\\list_machinery_types_use_case.py</code> <pre><code>class ListMachineryTypesUseCase:\n    \"\"\"Caso de uso para listar los tipos de maquinaria agr\u00edcola.\"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n        self.db = db\n        self.costs_repository = CostsRepository(db)\n\n    def list_machinery_types(self, current_user: UserInDB) -&gt; MachineryTypeListResponse:\n        \"\"\"Lista todos los tipos de maquinaria agr\u00edcola.\n\n        Args:\n            current_user (UserInDB): Usuario actual autenticado.\n\n        Returns:\n            MachineryTypeListResponse: Lista de tipos de maquinaria.\n        \"\"\"\n        machinery_types = self.costs_repository.get_machinery_types()\n        machinery_type_responses = [map_machinery_type_to_response(mt) for mt in machinery_types]\n        return MachineryTypeListResponse(machinery_types=machinery_type_responses)\n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_machinery_types_use_case.ListMachineryTypesUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> Source code in <code>app\\costs\\application\\list_machinery_types_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n    self.db = db\n    self.costs_repository = CostsRepository(db)\n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_machinery_types_use_case.ListMachineryTypesUseCase.list_machinery_types","title":"<code>list_machinery_types(current_user)</code>","text":"<p>Lista todos los tipos de maquinaria agr\u00edcola.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>MachineryTypeListResponse</code> <code>MachineryTypeListResponse</code> <p>Lista de tipos de maquinaria.</p> Source code in <code>app\\costs\\application\\list_machinery_types_use_case.py</code> <pre><code>def list_machinery_types(self, current_user: UserInDB) -&gt; MachineryTypeListResponse:\n    \"\"\"Lista todos los tipos de maquinaria agr\u00edcola.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        MachineryTypeListResponse: Lista de tipos de maquinaria.\n    \"\"\"\n    machinery_types = self.costs_repository.get_machinery_types()\n    machinery_type_responses = [map_machinery_type_to_response(mt) for mt in machinery_types]\n    return MachineryTypeListResponse(machinery_types=machinery_type_responses)\n</code></pre>"},{"location":"costs/use_cases/#caso-de-uso-listar-maquinaria-agricola","title":"Caso de Uso: Listar Maquinaria Agr\u00edcola","text":"<p>Caso de uso para listar la maquinaria agr\u00edcola.</p> Source code in <code>app\\costs\\application\\list_agricultural_machinery_use_case.py</code> <pre><code>class ListAgriculturalMachineryUseCase:\n    \"\"\"Caso de uso para listar la maquinaria agr\u00edcola.\"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n        self.db = db\n        self.costs_repository = CostsRepository(db)\n\n    def list_machinery(self, current_user: UserInDB) -&gt; AgriculturalMachineryListResponse:\n        \"\"\"Lista toda la maquinaria agr\u00edcola.\n\n        Args:\n            current_user (UserInDB): Usuario actual autenticado.\n\n        Returns:\n            AgriculturalMachineryListResponse: Lista de maquinaria agr\u00edcola.\n        \"\"\"\n        machinery = self.costs_repository.get_agricultural_machinery()\n        machinery_responses = [map_agricultural_machinery_to_response(m) for m in machinery]\n        return AgriculturalMachineryListResponse(machinery=machinery_responses)\n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_agricultural_machinery_use_case.ListAgriculturalMachineryUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> Source code in <code>app\\costs\\application\\list_agricultural_machinery_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\"\"\"\n    self.db = db\n    self.costs_repository = CostsRepository(db)\n</code></pre>"},{"location":"costs/use_cases/#app.costs.application.list_agricultural_machinery_use_case.ListAgriculturalMachineryUseCase.list_machinery","title":"<code>list_machinery(current_user)</code>","text":"<p>Lista toda la maquinaria agr\u00edcola.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>AgriculturalMachineryListResponse</code> <code>AgriculturalMachineryListResponse</code> <p>Lista de maquinaria agr\u00edcola.</p> Source code in <code>app\\costs\\application\\list_agricultural_machinery_use_case.py</code> <pre><code>def list_machinery(self, current_user: UserInDB) -&gt; AgriculturalMachineryListResponse:\n    \"\"\"Lista toda la maquinaria agr\u00edcola.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        AgriculturalMachineryListResponse: Lista de maquinaria agr\u00edcola.\n    \"\"\"\n    machinery = self.costs_repository.get_agricultural_machinery()\n    machinery_responses = [map_agricultural_machinery_to_response(m) for m in machinery]\n    return AgriculturalMachineryListResponse(machinery=machinery_responses)\n</code></pre>"},{"location":"crop/endpoints/","title":"Endpoints del M\u00f3dulo de Cultivos","text":""},{"location":"crop/endpoints/#crear-cultivo","title":"Crear Cultivo","text":"<p>Crea un nuevo cultivo en el sistema.</p> <p>Parameters:</p> Name Type Description Default <code>crop</code> <code>CropCreate</code> <p>Datos del cultivo a crear.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Un objeto SuccessResponse indicando que el cultivo fue creado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la creaci\u00f3n del cultivo.</p> Source code in <code>app\\crop\\infrastructure\\api.py</code> <pre><code>@router.post(\"/crops\", response_model=SuccessResponse, status_code=status.HTTP_201_CREATED)\ndef create_crop(\n    crop: CropCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Crea un nuevo cultivo en el sistema.\n\n    Parameters:\n        crop (CropCreate): Datos del cultivo a crear.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Un objeto SuccessResponse indicando que el cultivo fue creado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la creaci\u00f3n del cultivo.\n    \"\"\"\n    create_crop_use_case = CreateCropUseCase(db)\n    try:\n        return create_crop_use_case.create_crop(crop, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al crear el cultivo: {str(e)}\"\n        )\n</code></pre>"},{"location":"crop/endpoints/#listar-variedades-de-maiz","title":"Listar Variedades de Ma\u00edz","text":"<p>Lista todas las variedades de ma\u00edz disponibles.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>CornVarietyListResponse</code> <code>CornVarietyListResponse</code> <p>Lista de variedades de ma\u00edz.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error al obtener las variedades.</p> Source code in <code>app\\crop\\infrastructure\\api.py</code> <pre><code>@router.get(\"/corn-varieties\", response_model=CornVarietyListResponse)\ndef list_corn_varieties(\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; CornVarietyListResponse:\n    \"\"\"\n    Lista todas las variedades de ma\u00edz disponibles.\n\n    Parameters:\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        CornVarietyListResponse: Lista de variedades de ma\u00edz.\n\n    Raises:\n        HTTPException: Si ocurre un error al obtener las variedades.\n    \"\"\"\n    try:\n        use_case = ListCornVarietiesUseCase(db)\n        return use_case.list_corn_varieties()\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error al obtener las variedades de ma\u00edz: {str(e)}\"\n        )\n</code></pre>"},{"location":"crop/endpoints/#listar-cultivos-por-lote","title":"Listar Cultivos por Lote","text":"<p>Lista todos los cultivos asociados a un lote espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>plot_id</code> <code>int</code> <p>ID del lote.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>PaginatedCropListResponse</code> <code>PaginatedCropListResponse</code> <p>Lista de cultivos y total.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error al obtener los cultivos.</p> Source code in <code>app\\crop\\infrastructure\\api.py</code> <pre><code>@router.get(\"/plots/{plot_id}/crops\", response_model=PaginatedCropListResponse)\ndef list_crops_by_plot(\n    plot_id: int,\n    page: int = Query(1, ge=1),\n    per_page: int = Query(10, ge=1, le=100),\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; PaginatedCropListResponse:\n    \"\"\"\n    Lista todos los cultivos asociados a un lote espec\u00edfico.\n\n    Parameters:\n        plot_id (int): ID del lote.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        PaginatedCropListResponse: Lista de cultivos y total.\n\n    Raises:\n        HTTPException: Si ocurre un error al obtener los cultivos.\n    \"\"\"\n    try:\n        use_case = ListCropsByPlotUseCase(db)\n        return use_case.list_crops(plot_id, page, per_page, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error al obtener los cultivos del lote: {str(e)}\"\n        )\n</code></pre>"},{"location":"crop/models/","title":"Modelos del M\u00f3dulo de Cultivos","text":""},{"location":"crop/models/#modelos-orm","title":"Modelos ORM","text":""},{"location":"crop/models/#cultivo","title":"Cultivo","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'cultivo' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del cultivo.</p> <code>lote_id</code> <code>int</code> <p>ID del lote asociado.</p> <code>variedad_maiz_id</code> <code>int</code> <p>ID de la variedad de ma\u00edz.</p> <code>fecha_siembra</code> <code>date</code> <p>Fecha de siembra.</p> <code>densidad_siembra</code> <code>int</code> <p>Densidad de siembra.</p> <code>densidad_siembra_unidad_id</code> <code>int</code> <p>ID de la unidad de medida para la densidad.</p> <code>estado_id</code> <code>int</code> <p>ID del estado del cultivo.</p> <code>fecha_cosecha</code> <code>date</code> <p>Fecha de cosecha (opcional).</p> <code>produccion_total</code> <code>int</code> <p>Producci\u00f3n total (opcional).</p> <code>produccion_total_unidad_id</code> <code>int</code> <p>ID de la unidad de medida para la producci\u00f3n (opcional).</p> <code>precio_venta_unitario</code> <code>decimal</code> <p>Precio de venta unitario (opcional).</p> <code>cantidad_vendida</code> <code>int</code> <p>Cantidad vendida (opcional).</p> <code>cantidad_vendida_unidad_id</code> <code>int</code> <p>ID de la unidad de medida para la cantidad vendida (opcional).</p> <code>ingreso_total</code> <code>decimal</code> <p>Ingreso total (opcional).</p> <code>costo_produccion</code> <code>decimal</code> <p>Costo de producci\u00f3n (opcional).</p> <code>moneda_id</code> <code>int</code> <p>ID de la moneda (opcional).</p> <code>fecha_venta</code> <code>date</code> <p>Fecha de venta (opcional).</p> <code>fecha_creacion</code> <code>timestamp</code> <p>Fecha de creaci\u00f3n del registro.</p> <code>fecha_modificacion</code> <code>timestamp</code> <p>Fecha de \u00faltima modificaci\u00f3n del registro.</p> Source code in <code>app\\crop\\infrastructure\\orm_models.py</code> <pre><code>class Crop(Base):\n    \"\"\"\n    Representa la tabla 'cultivo' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del cultivo.\n        lote_id (int): ID del lote asociado.\n        variedad_maiz_id (int): ID de la variedad de ma\u00edz.\n        fecha_siembra (date): Fecha de siembra.\n        densidad_siembra (int): Densidad de siembra.\n        densidad_siembra_unidad_id (int): ID de la unidad de medida para la densidad.\n        estado_id (int): ID del estado del cultivo.\n        fecha_cosecha (date): Fecha de cosecha (opcional).\n        produccion_total (int): Producci\u00f3n total (opcional).\n        produccion_total_unidad_id (int): ID de la unidad de medida para la producci\u00f3n (opcional).\n        precio_venta_unitario (decimal): Precio de venta unitario (opcional).\n        cantidad_vendida (int): Cantidad vendida (opcional).\n        cantidad_vendida_unidad_id (int): ID de la unidad de medida para la cantidad vendida (opcional).\n        ingreso_total (decimal): Ingreso total (opcional).\n        costo_produccion (decimal): Costo de producci\u00f3n (opcional).\n        moneda_id (int): ID de la moneda (opcional).\n        fecha_venta (date): Fecha de venta (opcional).\n        fecha_creacion (timestamp): Fecha de creaci\u00f3n del registro.\n        fecha_modificacion (timestamp): Fecha de \u00faltima modificaci\u00f3n del registro.\n    \"\"\"\n    __tablename__ = \"cultivo\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    lote_id = Column(Integer, ForeignKey('lote.id'), nullable=False)\n    variedad_maiz_id = Column(Integer, ForeignKey('variedad_maiz.id'), nullable=False)\n    fecha_siembra = Column(Date, nullable=False)\n    densidad_siembra = Column(Integer, nullable=False)\n    densidad_siembra_unidad_id = Column(Integer, ForeignKey('unidad_medida.id'), nullable=False)\n    estado_id = Column(Integer, ForeignKey('estado_cultivo.id'), nullable=False)\n    fecha_cosecha = Column(Date)\n    produccion_total = Column(Integer)\n    produccion_total_unidad_id = Column(Integer, ForeignKey('unidad_medida.id'))\n    precio_venta_unitario = Column(DECIMAL(10, 2))\n    cantidad_vendida = Column(Integer)\n    cantidad_vendida_unidad_id = Column(Integer, ForeignKey('unidad_medida.id'))\n    ingreso_total = Column(DECIMAL(15, 2))\n    costo_produccion = Column(DECIMAL(15, 2))\n    moneda_id = Column(Integer, ForeignKey('moneda.id'))\n    fecha_venta = Column(Date)\n\n    # Relaciones\n    lote = relationship(\"Plot\", back_populates=\"cultivos\")\n    variedad_maiz = relationship(\"CornVariety\")\n    densidad_siembra_unidad = relationship(\"UnitOfMeasure\", foreign_keys=[densidad_siembra_unidad_id])\n    estado = relationship(\"CropState\")\n    produccion_total_unidad = relationship(\"UnitOfMeasure\", foreign_keys=[produccion_total_unidad_id])\n    cantidad_vendida_unidad = relationship(\"UnitOfMeasure\", foreign_keys=[cantidad_vendida_unidad_id])\n    moneda = relationship(\"Currency\")\n</code></pre>"},{"location":"crop/models/#estado-del-cultivo","title":"Estado del Cultivo","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'estado_cultivo' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del estado.</p> <code>nombre</code> <code>str</code> <p>Nombre del estado.</p> <code>descripcion</code> <code>str</code> <p>Descripci\u00f3n del estado.</p> Source code in <code>app\\crop\\infrastructure\\orm_models.py</code> <pre><code>class CropState(Base):\n    \"\"\"\n    Representa la tabla 'estado_cultivo' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del estado.\n        nombre (str): Nombre del estado.\n        descripcion (str): Descripci\u00f3n del estado.\n    \"\"\"\n    __tablename__ = \"estado_cultivo\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), unique=True, nullable=False)\n    descripcion = Column(Text)\n</code></pre>"},{"location":"crop/models/#variedad-de-maiz","title":"Variedad de Ma\u00edz","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'variedad_maiz' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la variedad.</p> <code>nombre</code> <code>str</code> <p>Nombre de la variedad.</p> <code>descripcion</code> <code>str</code> <p>Descripci\u00f3n de la variedad.</p> Source code in <code>app\\crop\\infrastructure\\orm_models.py</code> <pre><code>class CornVariety(Base):\n    \"\"\"\n    Representa la tabla 'variedad_maiz' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la variedad.\n        nombre (str): Nombre de la variedad.\n        descripcion (str): Descripci\u00f3n de la variedad.\n    \"\"\"\n    __tablename__ = \"variedad_maiz\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(100), unique=True, nullable=False)\n    descripcion = Column(Text)\n</code></pre>"},{"location":"crop/models/#moneda","title":"Moneda","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'moneda' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la moneda.</p> <code>nombre</code> <code>str</code> <p>Nombre de la moneda.</p> <code>codigo</code> <code>str</code> <p>C\u00f3digo de la moneda.</p> <code>simbolo</code> <code>str</code> <p>S\u00edmbolo de la moneda.</p> Source code in <code>app\\crop\\infrastructure\\orm_models.py</code> <pre><code>class Currency(Base):\n    \"\"\"\n    Representa la tabla 'moneda' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la moneda.\n        nombre (str): Nombre de la moneda.\n        codigo (str): C\u00f3digo de la moneda.\n        simbolo (str): S\u00edmbolo de la moneda.\n    \"\"\"\n    __tablename__ = \"moneda\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), unique=True, nullable=False)\n    codigo = Column(String(3), unique=True, nullable=False)\n    simbolo = Column(String(5), nullable=False)\n</code></pre>"},{"location":"crop/overview/","title":"Visi\u00f3n General del M\u00f3dulo de Cultivos","text":""},{"location":"crop/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>El m\u00f3dulo de cultivos de AgroInsight gestiona toda la informaci\u00f3n relacionada con los cultivos de ma\u00edz en las diferentes fincas. Este m\u00f3dulo es fundamental para el seguimiento y control de la producci\u00f3n agr\u00edcola.</p>"},{"location":"crop/overview/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"crop/overview/#1-gestion-de-cultivos","title":"1. Gesti\u00f3n de Cultivos","text":"<ul> <li>Creaci\u00f3n y seguimiento de cultivos</li> <li>Registro de fechas de siembra y cosecha</li> <li>Control de densidad de siembra</li> <li>Seguimiento del estado del cultivo</li> </ul>"},{"location":"crop/overview/#2-variedades-de-maiz","title":"2. Variedades de Ma\u00edz","text":"<ul> <li>Cat\u00e1logo de variedades disponibles</li> <li>Informaci\u00f3n detallada de cada variedad</li> <li>Recomendaciones de uso seg\u00fan la regi\u00f3n</li> </ul>"},{"location":"crop/overview/#3-estados-del-cultivo","title":"3. Estados del Cultivo","text":"<ul> <li>Programado</li> <li>Sembrado</li> <li>Germinando</li> <li>Creciendo</li> <li>Floraci\u00f3n</li> <li>Maduraci\u00f3n</li> <li>Cosechado</li> <li>Enfermo</li> <li>Muerto</li> <li>Dormante</li> </ul>"},{"location":"crop/overview/#4-metricas-y-seguimiento","title":"4. M\u00e9tricas y Seguimiento","text":"<ul> <li>Registro de producci\u00f3n total</li> <li>Control de ventas y precios</li> <li>C\u00e1lculo de rendimientos</li> <li>An\u00e1lisis de costos e ingresos</li> </ul>"},{"location":"crop/overview/#integracion-con-otros-modulos","title":"Integraci\u00f3n con Otros M\u00f3dulos","text":"<p>El m\u00f3dulo de cultivos se integra estrechamente con:</p> <ul> <li>M\u00f3dulo de Lotes: Para la gesti\u00f3n de ubicaciones de cultivos</li> <li>M\u00f3dulo de Pr\u00e1cticas Culturales: Para el seguimiento de labores agr\u00edcolas</li> <li>M\u00f3dulo de Fincas: Para la administraci\u00f3n general de la producci\u00f3n</li> </ul>"},{"location":"crop/overview/#casos-de-uso-comunes","title":"Casos de Uso Comunes","text":"<ol> <li>Registro de nuevo cultivo</li> <li>Actualizaci\u00f3n de estado del cultivo</li> <li>Registro de cosecha</li> <li>Consulta de variedades disponibles</li> <li>Generaci\u00f3n de reportes de producci\u00f3n</li> </ol>"},{"location":"crop/overview/#estructura-tecnica","title":"Estructura T\u00e9cnica","text":"<p>El m\u00f3dulo sigue una arquitectura limpia con las siguientes capas:</p> <ul> <li>Domain: Modelos y reglas de negocio</li> <li>Application: Casos de uso y servicios</li> <li>Infrastructure: Implementaciones t\u00e9cnicas y acceso a datos</li> </ul>"},{"location":"crop/overview/#documentacion-relacionada","title":"Documentaci\u00f3n Relacionada","text":"<ul> <li>Endpoints de Cultivos</li> <li>Modelos de Datos</li> <li>Casos de Uso</li> </ul>"},{"location":"crop/use_cases/","title":"Casos de Uso del M\u00f3dulo de Cultivos","text":""},{"location":"crop/use_cases/#crear-cultivo","title":"Crear Cultivo","text":"<p>Caso de uso para crear un nuevo cultivo.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para crear un cultivo en un lote, incluyendo validaciones de permisos y existencia de recursos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>crop_repository</code> <code>CropRepository</code> <p>Repositorio para operaciones con cultivos.</p> <code>plot_repository</code> <code>PlotRepository</code> <p>Repositorio para operaciones con lotes.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>measurement_service</code> <code>MeasurementService</code> <p>Servicio para l\u00f3gica de negocio de medidas.</p> <code>measurement_repository</code> <code>MeasurementRepository</code> <p>Repositorio para operaciones con medidas.</p> Source code in <code>app\\crop\\application\\create_crop_use_case.py</code> <pre><code>class CreateCropUseCase:\n    \"\"\"Caso de uso para crear un nuevo cultivo.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para crear un cultivo en un lote,\n    incluyendo validaciones de permisos y existencia de recursos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        crop_repository (CropRepository): Repositorio para operaciones con cultivos.\n        plot_repository (PlotRepository): Repositorio para operaciones con lotes.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        measurement_service (MeasurementService): Servicio para l\u00f3gica de negocio de medidas.\n        measurement_repository (MeasurementRepository): Repositorio para operaciones con medidas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.crop_repository = CropRepository(db)\n        self.plot_repository = PlotRepository(db)\n        self.farm_repository = FarmRepository(db)\n        self.farm_service = FarmService(db)\n        self.measurement_service = MeasurementService(db)\n        self.measurement_repository = MeasurementRepository(db)\n\n    def create_crop(self, crop_data: CropCreate, current_user: UserInDB) -&gt; SuccessResponse:\n        \"\"\"Crea un nuevo cultivo en la base de datos.\n\n        Este m\u00e9todo realiza las siguientes validaciones antes de crear el cultivo:\n        1. Verifica que el lote especificado exista.\n        2. Obtiene la finca asociada al lote y verifica su existencia.\n        3. Valida que el usuario tenga permisos para crear cultivos en la finca.\n        4. Verifica que la variedad de ma\u00edz especificada exista.\n        5. Verifica que la unidad de medida para la densidad de siembra exista y sea v\u00e1lida.\n        6. Verifica que el estado del cultivo especificado exista.\n        7. Verifica que no exista un cultivo activo en el lote.\n\n        Args:\n            crop_data (CropCreate): Datos del cultivo a crear.\n            current_user (UserInDB): Usuario que est\u00e1 creando el cultivo.\n\n        Returns:\n            SuccessResponse: Respuesta exitosa con un mensaje de confirmaci\u00f3n.\n\n        Raises:\n            DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n                - 404: El lote, la finca, la variedad de ma\u00edz, la unidad de medida o el estado del cultivo no existen.\n                - 403: El usuario no tiene permisos para crear cultivos en la finca.\n                - 409: Ya existe un cultivo activo en el lote.\n                - 500: Error al crear el cultivo.\n        \"\"\"\n        # Obtener el lote\n        plot = self.plot_repository.get_plot_by_id(crop_data.lote_id)\n        if not plot:\n            raise DomainException(\n                message=\"No se pudo obtener el lote especificado.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Obtener la finca asociada al lote\n        farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n        if not farm:\n            raise DomainException(\n                message=\"No se pudo obtener la finca asociada al lote.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar que el usuario sea administrador de la finca\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n            raise DomainException(\n                message=\"No tienes permisos para crear cultivos en esta finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # Verificar si la variedad de ma\u00edz existe\n        if not self.crop_repository.get_corn_variety_by_id(crop_data.variedad_maiz_id):\n            raise DomainException(\n                message=\"La variedad de ma\u00edz especificada no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Verificar si la unidad de medida para densidad de siembra existe\n        unit_of_measure = self.measurement_repository.get_unit_of_measure_by_id(crop_data.densidad_siembra_unidad_id)\n        if not unit_of_measure:\n            raise DomainException(\n                message=\"La unidad de medida para densidad de siembra especificada no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # verificar que la unidad de medida para densidad de siembra sea de densidad de siembra\n        unit_category = self.measurement_repository.get_unit_category_by_id(unit_of_measure.categoria_id)\n        if not unit_category:\n            raise DomainException(\n                message=\"No se pudo obtener la categor\u00eda de la unidad de medida para densidad de siembra.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if unit_category.nombre != self.measurement_service.UNIT_CATEGORY_PLANTING_DENSITY_NAME:\n            raise DomainException(\n                message=\"La unidad de medida elegida no es de densidad de siembra.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        # Verificar si el estado del cultivo existe\n        if not self.crop_repository.get_crop_state_by_id(crop_data.estado_id):\n            raise DomainException(\n                message=\"El estado de cultivo especificado no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Verificar si ya existe un cultivo activo en el lote\n        if self.crop_repository.has_active_crop(crop_data.lote_id):\n            raise DomainException(\n                message=\"Ya existe un cultivo activo en este lote.\",\n                status_code=status.HTTP_409_CONFLICT\n            )\n\n        # Crear el cultivo\n        crop = self.crop_repository.create_crop(crop_data)\n        if not crop:\n            raise DomainException(\n                message=\"No se pudo crear el cultivo.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessResponse(message=\"Cultivo creado exitosamente\")\n</code></pre>"},{"location":"crop/use_cases/#app.crop.application.create_crop_use_case.CreateCropUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\crop\\application\\create_crop_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.crop_repository = CropRepository(db)\n    self.plot_repository = PlotRepository(db)\n    self.farm_repository = FarmRepository(db)\n    self.farm_service = FarmService(db)\n    self.measurement_service = MeasurementService(db)\n    self.measurement_repository = MeasurementRepository(db)\n</code></pre>"},{"location":"crop/use_cases/#app.crop.application.create_crop_use_case.CreateCropUseCase.create_crop","title":"<code>create_crop(crop_data, current_user)</code>","text":"<p>Crea un nuevo cultivo en la base de datos.</p> <p>Este m\u00e9todo realiza las siguientes validaciones antes de crear el cultivo: 1. Verifica que el lote especificado exista. 2. Obtiene la finca asociada al lote y verifica su existencia. 3. Valida que el usuario tenga permisos para crear cultivos en la finca. 4. Verifica que la variedad de ma\u00edz especificada exista. 5. Verifica que la unidad de medida para la densidad de siembra exista y sea v\u00e1lida. 6. Verifica que el estado del cultivo especificado exista. 7. Verifica que no exista un cultivo activo en el lote.</p> <p>Parameters:</p> Name Type Description Default <code>crop_data</code> <code>CropCreate</code> <p>Datos del cultivo a crear.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario que est\u00e1 creando el cultivo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta exitosa con un mensaje de confirmaci\u00f3n.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre alg\u00fan error de validaci\u00f3n: - 404: El lote, la finca, la variedad de ma\u00edz, la unidad de medida o el estado del cultivo no existen. - 403: El usuario no tiene permisos para crear cultivos en la finca. - 409: Ya existe un cultivo activo en el lote. - 500: Error al crear el cultivo.</p> Source code in <code>app\\crop\\application\\create_crop_use_case.py</code> <pre><code>def create_crop(self, crop_data: CropCreate, current_user: UserInDB) -&gt; SuccessResponse:\n    \"\"\"Crea un nuevo cultivo en la base de datos.\n\n    Este m\u00e9todo realiza las siguientes validaciones antes de crear el cultivo:\n    1. Verifica que el lote especificado exista.\n    2. Obtiene la finca asociada al lote y verifica su existencia.\n    3. Valida que el usuario tenga permisos para crear cultivos en la finca.\n    4. Verifica que la variedad de ma\u00edz especificada exista.\n    5. Verifica que la unidad de medida para la densidad de siembra exista y sea v\u00e1lida.\n    6. Verifica que el estado del cultivo especificado exista.\n    7. Verifica que no exista un cultivo activo en el lote.\n\n    Args:\n        crop_data (CropCreate): Datos del cultivo a crear.\n        current_user (UserInDB): Usuario que est\u00e1 creando el cultivo.\n\n    Returns:\n        SuccessResponse: Respuesta exitosa con un mensaje de confirmaci\u00f3n.\n\n    Raises:\n        DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n            - 404: El lote, la finca, la variedad de ma\u00edz, la unidad de medida o el estado del cultivo no existen.\n            - 403: El usuario no tiene permisos para crear cultivos en la finca.\n            - 409: Ya existe un cultivo activo en el lote.\n            - 500: Error al crear el cultivo.\n    \"\"\"\n    # Obtener el lote\n    plot = self.plot_repository.get_plot_by_id(crop_data.lote_id)\n    if not plot:\n        raise DomainException(\n            message=\"No se pudo obtener el lote especificado.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Obtener la finca asociada al lote\n    farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n    if not farm:\n        raise DomainException(\n            message=\"No se pudo obtener la finca asociada al lote.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar que el usuario sea administrador de la finca\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n        raise DomainException(\n            message=\"No tienes permisos para crear cultivos en esta finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # Verificar si la variedad de ma\u00edz existe\n    if not self.crop_repository.get_corn_variety_by_id(crop_data.variedad_maiz_id):\n        raise DomainException(\n            message=\"La variedad de ma\u00edz especificada no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si la unidad de medida para densidad de siembra existe\n    unit_of_measure = self.measurement_repository.get_unit_of_measure_by_id(crop_data.densidad_siembra_unidad_id)\n    if not unit_of_measure:\n        raise DomainException(\n            message=\"La unidad de medida para densidad de siembra especificada no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # verificar que la unidad de medida para densidad de siembra sea de densidad de siembra\n    unit_category = self.measurement_repository.get_unit_category_by_id(unit_of_measure.categoria_id)\n    if not unit_category:\n        raise DomainException(\n            message=\"No se pudo obtener la categor\u00eda de la unidad de medida para densidad de siembra.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if unit_category.nombre != self.measurement_service.UNIT_CATEGORY_PLANTING_DENSITY_NAME:\n        raise DomainException(\n            message=\"La unidad de medida elegida no es de densidad de siembra.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Verificar si el estado del cultivo existe\n    if not self.crop_repository.get_crop_state_by_id(crop_data.estado_id):\n        raise DomainException(\n            message=\"El estado de cultivo especificado no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si ya existe un cultivo activo en el lote\n    if self.crop_repository.has_active_crop(crop_data.lote_id):\n        raise DomainException(\n            message=\"Ya existe un cultivo activo en este lote.\",\n            status_code=status.HTTP_409_CONFLICT\n        )\n\n    # Crear el cultivo\n    crop = self.crop_repository.create_crop(crop_data)\n    if not crop:\n        raise DomainException(\n            message=\"No se pudo crear el cultivo.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(message=\"Cultivo creado exitosamente\")\n</code></pre>"},{"location":"crop/use_cases/#listar-variedades-de-maiz","title":"Listar Variedades de Ma\u00edz","text":"<p>Caso de uso para listar las variedades de ma\u00edz.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para obtener todas las variedades de ma\u00edz disponibles en el sistema.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>crop_repository</code> <code>CropRepository</code> <p>Repositorio para operaciones con cultivos.</p> Source code in <code>app\\crop\\application\\list_corn_varieties_use_case.py</code> <pre><code>class ListCornVarietiesUseCase:\n    \"\"\"Caso de uso para listar las variedades de ma\u00edz.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para obtener todas las variedades de ma\u00edz\n    disponibles en el sistema.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        crop_repository (CropRepository): Repositorio para operaciones con cultivos.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.crop_repository = CropRepository(db)\n\n    def list_corn_varieties(self) -&gt; CornVarietyListResponse:\n        \"\"\"Lista todas las variedades de ma\u00edz disponibles.\n\n        Returns:\n            CornVarietyListResponse: Objeto con la lista de variedades de ma\u00edz.\n\n        Raises:\n            DomainException: Si ocurre un error al obtener las variedades.\n        \"\"\"\n        varieties = self.crop_repository.get_all_corn_varieties()\n        if varieties is None:\n            raise DomainException(\n                message=\"Error al obtener las variedades de ma\u00edz\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        if len(varieties) == 0:\n            raise DomainException(\n                message=\"No hay variedades de ma\u00edz registradas\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        return CornVarietyListResponse(varieties=varieties)\n</code></pre>"},{"location":"crop/use_cases/#app.crop.application.list_corn_varieties_use_case.ListCornVarietiesUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\crop\\application\\list_corn_varieties_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.crop_repository = CropRepository(db)\n</code></pre>"},{"location":"crop/use_cases/#app.crop.application.list_corn_varieties_use_case.ListCornVarietiesUseCase.list_corn_varieties","title":"<code>list_corn_varieties()</code>","text":"<p>Lista todas las variedades de ma\u00edz disponibles.</p> <p>Returns:</p> Name Type Description <code>CornVarietyListResponse</code> <code>CornVarietyListResponse</code> <p>Objeto con la lista de variedades de ma\u00edz.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre un error al obtener las variedades.</p> Source code in <code>app\\crop\\application\\list_corn_varieties_use_case.py</code> <pre><code>def list_corn_varieties(self) -&gt; CornVarietyListResponse:\n    \"\"\"Lista todas las variedades de ma\u00edz disponibles.\n\n    Returns:\n        CornVarietyListResponse: Objeto con la lista de variedades de ma\u00edz.\n\n    Raises:\n        DomainException: Si ocurre un error al obtener las variedades.\n    \"\"\"\n    varieties = self.crop_repository.get_all_corn_varieties()\n    if varieties is None:\n        raise DomainException(\n            message=\"Error al obtener las variedades de ma\u00edz\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    if len(varieties) == 0:\n        raise DomainException(\n            message=\"No hay variedades de ma\u00edz registradas\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    return CornVarietyListResponse(varieties=varieties)\n</code></pre>"},{"location":"crop/use_cases/#listar-cultivos-por-lote","title":"Listar Cultivos por Lote","text":"<p>Caso de uso para listar los cultivos de un lote espec\u00edfico.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para obtener una lista paginada de los cultivos que pertenecen a un lote espec\u00edfico, asegurando que el usuario tenga los permisos adecuados.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>crop_repository</code> <code>CropRepository</code> <p>Repositorio para operaciones con cultivos.</p> <code>plot_repository</code> <code>PlotRepository</code> <p>Repositorio para operaciones con lotes.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones con usuarios.</p> Source code in <code>app\\crop\\application\\list_crops_by_plot_use_case.py</code> <pre><code>class ListCropsByPlotUseCase:\n    \"\"\"Caso de uso para listar los cultivos de un lote espec\u00edfico.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para obtener una lista paginada\n    de los cultivos que pertenecen a un lote espec\u00edfico, asegurando que el usuario\n    tenga los permisos adecuados.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        crop_repository (CropRepository): Repositorio para operaciones con cultivos.\n        plot_repository (PlotRepository): Repositorio para operaciones con lotes.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        user_repository (UserRepository): Repositorio para operaciones con usuarios.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.crop_repository = CropRepository(db)\n        self.plot_repository = PlotRepository(db)\n        self.farm_repository = FarmRepository(db)\n        self.farm_service = FarmService(db)\n        self.user_repository = UserRepository(db)\n\n    def list_crops(self, plot_id: int, page: int, per_page: int, current_user: UserInDB) -&gt; PaginatedCropListResponse:\n        \"\"\"Lista los cultivos de un lote espec\u00edfico de forma paginada.\n\n        Este m\u00e9todo realiza las siguientes validaciones:\n        1. Verifica si el lote especificado existe.\n        2. Obtiene la finca asociada al lote y verifica su existencia.\n        3. Verifica que el usuario tenga acceso a la finca.\n\n        Args:\n            plot_id (int): ID del lote del cual se quieren listar los cultivos.\n            page (int): N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.\n            per_page (int): Cantidad de cultivos por p\u00e1gina.\n            current_user (UserInDB): Usuario que est\u00e1 solicitando la lista de cultivos.\n\n        Returns:\n            PaginatedCropListResponse: Respuesta paginada que incluye:\n                - Lista de cultivos para la p\u00e1gina actual.\n                - Total de cultivos.\n                - N\u00famero de p\u00e1gina actual.\n                - Cantidad de elementos por p\u00e1gina.\n                - Total de p\u00e1ginas.\n\n        Raises:\n            DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n                - 404: El lote o la finca no existen.\n                - 403: El usuario no tiene permisos para ver los cultivos de este lote.\n        \"\"\"\n        # Verificar si el lote existe\n        plot = self.plot_repository.get_plot_by_id(plot_id)\n        if not plot:\n            raise DomainException(\n                message=\"El lote especificado no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Obtener la finca asociada al lote\n        farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n        if not farm:\n            raise DomainException(\n                message=\"No se pudo obtener la finca asociada al lote.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Verificar que el usuario tenga acceso a la finca\n        user = self.user_repository.get_user_by_id(current_user.id)\n        if not user:\n            raise DomainException(\n                message=\"No se pudo obtener el usuario.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        nombre_usuario = user.nombre + \" \" + user.apellido\n        if not self.farm_service.user_is_farm_admin(user.id, farm.id):\n            raise DomainException(\n                message=f\"El usuario {nombre_usuario} con email {user.email} no tiene permisos para ver los cultivos de este lote.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # Obtener los cultivos\n        total_crops, crops = self.crop_repository.get_crops_by_plot_id_paginated(plot_id, page, per_page)\n\n        total_pages = ceil(total_crops / per_page)\n\n        return PaginatedCropListResponse(\n            crops=crops,\n            total_crops=total_crops,\n            page=page,\n            per_page=per_page,\n            total_pages=total_pages\n        )\n</code></pre>"},{"location":"crop/use_cases/#app.crop.application.list_crops_by_plot_use_case.ListCropsByPlotUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\crop\\application\\list_crops_by_plot_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.crop_repository = CropRepository(db)\n    self.plot_repository = PlotRepository(db)\n    self.farm_repository = FarmRepository(db)\n    self.farm_service = FarmService(db)\n    self.user_repository = UserRepository(db)\n</code></pre>"},{"location":"crop/use_cases/#app.crop.application.list_crops_by_plot_use_case.ListCropsByPlotUseCase.list_crops","title":"<code>list_crops(plot_id, page, per_page, current_user)</code>","text":"<p>Lista los cultivos de un lote espec\u00edfico de forma paginada.</p> <p>Este m\u00e9todo realiza las siguientes validaciones: 1. Verifica si el lote especificado existe. 2. Obtiene la finca asociada al lote y verifica su existencia. 3. Verifica que el usuario tenga acceso a la finca.</p> <p>Parameters:</p> Name Type Description Default <code>plot_id</code> <code>int</code> <p>ID del lote del cual se quieren listar los cultivos.</p> required <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.</p> required <code>per_page</code> <code>int</code> <p>Cantidad de cultivos por p\u00e1gina.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario que est\u00e1 solicitando la lista de cultivos.</p> required <p>Returns:</p> Name Type Description <code>PaginatedCropListResponse</code> <code>PaginatedCropListResponse</code> <p>Respuesta paginada que incluye: - Lista de cultivos para la p\u00e1gina actual. - Total de cultivos. - N\u00famero de p\u00e1gina actual. - Cantidad de elementos por p\u00e1gina. - Total de p\u00e1ginas.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre alg\u00fan error de validaci\u00f3n: - 404: El lote o la finca no existen. - 403: El usuario no tiene permisos para ver los cultivos de este lote.</p> Source code in <code>app\\crop\\application\\list_crops_by_plot_use_case.py</code> <pre><code>def list_crops(self, plot_id: int, page: int, per_page: int, current_user: UserInDB) -&gt; PaginatedCropListResponse:\n    \"\"\"Lista los cultivos de un lote espec\u00edfico de forma paginada.\n\n    Este m\u00e9todo realiza las siguientes validaciones:\n    1. Verifica si el lote especificado existe.\n    2. Obtiene la finca asociada al lote y verifica su existencia.\n    3. Verifica que el usuario tenga acceso a la finca.\n\n    Args:\n        plot_id (int): ID del lote del cual se quieren listar los cultivos.\n        page (int): N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.\n        per_page (int): Cantidad de cultivos por p\u00e1gina.\n        current_user (UserInDB): Usuario que est\u00e1 solicitando la lista de cultivos.\n\n    Returns:\n        PaginatedCropListResponse: Respuesta paginada que incluye:\n            - Lista de cultivos para la p\u00e1gina actual.\n            - Total de cultivos.\n            - N\u00famero de p\u00e1gina actual.\n            - Cantidad de elementos por p\u00e1gina.\n            - Total de p\u00e1ginas.\n\n    Raises:\n        DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n            - 404: El lote o la finca no existen.\n            - 403: El usuario no tiene permisos para ver los cultivos de este lote.\n    \"\"\"\n    # Verificar si el lote existe\n    plot = self.plot_repository.get_plot_by_id(plot_id)\n    if not plot:\n        raise DomainException(\n            message=\"El lote especificado no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Obtener la finca asociada al lote\n    farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n    if not farm:\n        raise DomainException(\n            message=\"No se pudo obtener la finca asociada al lote.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar que el usuario tenga acceso a la finca\n    user = self.user_repository.get_user_by_id(current_user.id)\n    if not user:\n        raise DomainException(\n            message=\"No se pudo obtener el usuario.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    nombre_usuario = user.nombre + \" \" + user.apellido\n    if not self.farm_service.user_is_farm_admin(user.id, farm.id):\n        raise DomainException(\n            message=f\"El usuario {nombre_usuario} con email {user.email} no tiene permisos para ver los cultivos de este lote.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # Obtener los cultivos\n    total_crops, crops = self.crop_repository.get_crops_by_plot_id_paginated(plot_id, page, per_page)\n\n    total_pages = ceil(total_crops / per_page)\n\n    return PaginatedCropListResponse(\n        crops=crops,\n        total_crops=total_crops,\n        page=page,\n        per_page=per_page,\n        total_pages=total_pages\n    )\n</code></pre>"},{"location":"cultural_practices/endpoints/","title":"Endpoints del M\u00f3dulo de Pr\u00e1cticas Culturales","text":""},{"location":"cultural_practices/endpoints/#crear-tarea","title":"Crear Tarea","text":"<p>Crea una nueva tarea de pr\u00e1ctica cultural en el sistema.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>TaskCreate</code> <p>Datos de la tarea a crear.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessTaskCreateResponse</code> <p>Un objeto SuccessResponse indicando que la tarea fue creada exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la creaci\u00f3n de la tarea.</p> Source code in <code>app\\cultural_practices\\infrastructure\\api.py</code> <pre><code>@router.post(\"/task/create\", response_model=SuccessTaskCreateResponse, status_code=status.HTTP_201_CREATED)\ndef create_task(\n    task: TaskCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; SuccessTaskCreateResponse:\n    \"\"\"\n    Crea una nueva tarea de pr\u00e1ctica cultural en el sistema.\n\n    Parameters:\n        task (TaskCreate): Datos de la tarea a crear.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Un objeto SuccessResponse indicando que la tarea fue creada exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la creaci\u00f3n de la tarea.\n    \"\"\"\n    create_task_use_case = CreateTaskUseCase(db)\n    try:\n        return create_task_use_case.create_task(task, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al crear la tarea: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"cultural_practices/endpoints/#crear-asignacion","title":"Crear Asignaci\u00f3n","text":"<p>Crea una nueva asignaci\u00f3n de pr\u00e1ctica cultural en el sistema.</p> <p>Parameters:</p> Name Type Description Default <code>assignment</code> <code>AssignmentCreate</code> <p>Datos de la asignaci\u00f3n a crear.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>JSONResponse</code> <p>Un objeto SuccessResponse indicando que la asignaci\u00f3n fue creada exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la creaci\u00f3n de la asignaci\u00f3n.</p> Source code in <code>app\\cultural_practices\\infrastructure\\api.py</code> <pre><code>@router.post(\"/assignment/create\", response_model=MultipleResponse, \n             responses={\n                 200: {\"description\": \"Todas las tareas asignadas exitosamente\"},\n                 207: {\"description\": \"Algunas tareas asignadas, otras fallaron\"},\n                 400: {\"description\": \"No se pudo asignar ninguna tarea\"}\n             }\n)\ndef create_assignment(\n    assignment: AssignmentCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; JSONResponse:\n    \"\"\"\n    Crea una nueva asignaci\u00f3n de pr\u00e1ctica cultural en el sistema.\n\n    Parameters:\n        assignment (AssignmentCreate): Datos de la asignaci\u00f3n a crear.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Un objeto SuccessResponse indicando que la asignaci\u00f3n fue creada exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la creaci\u00f3n de la asignaci\u00f3n.\n    \"\"\"\n    assign_task_use_case = AssignTaskUseCase(db)\n    try:\n        response = assign_task_use_case.create_assignment(assignment, current_user)\n        return JSONResponse(content=response.model_dump(), status_code=response.status_code)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al asignar la tarea: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"cultural_practices/endpoints/#listar-tareas-por-usuario-y-finca","title":"Listar Tareas por Usuario y Finca","text":"<p>Lista todas las tareas asignadas a un usuario espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario.</p> required <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina.</p> <code>Query(1, ge=1, description='Page number')</code> <code>per_page</code> <code>int</code> <p>Elementos por p\u00e1gina.</p> <code>Query(10, ge=1, le=100, description='Items per page')</code> <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>PaginatedTaskListResponse</code> <code>PaginatedTaskListResponse</code> <p>Una lista paginada de tareas.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de la lista de tareas.</p> Source code in <code>app\\cultural_practices\\infrastructure\\api.py</code> <pre><code>@router.get(\"/farm/{farm_id}/user/{user_id}/tasks/list\", response_model=PaginatedTaskListResponse, status_code=status.HTTP_200_OK)\ndef list_tasks_by_user_and_farm(\n    farm_id: int,\n    user_id: int,\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    per_page: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; PaginatedTaskListResponse:\n    \"\"\"\n    Lista todas las tareas asignadas a un usuario espec\u00edfico.\n\n    Parameters:\n        user_id (int): ID del usuario.\n        page (int): N\u00famero de p\u00e1gina.\n        per_page (int): Elementos por p\u00e1gina.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        PaginatedTaskListResponse: Una lista paginada de tareas.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de la lista de tareas.\n    \"\"\"\n    list_tasks_by_user_and_farm_use_case = ListTasksByUserAndFarmUseCase(db)\n    try:\n        return list_tasks_by_user_and_farm_use_case.list_tasks_by_user_and_farm(farm_id, user_id, page, per_page, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar las tareas: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"cultural_practices/endpoints/#obtener-tarea-por-id","title":"Obtener Tarea por ID","text":"<p>Obtiene una tarea espec\u00edfica por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>farm_id</code> <code>int</code> <p>ID de la finca.</p> required <code>task_id</code> <code>int</code> <p>ID de la tarea.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>TaskResponse</code> <code>TaskResponse</code> <p>Detalles de la tarea solicitada.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de la tarea.</p> Source code in <code>app\\cultural_practices\\infrastructure\\api.py</code> <pre><code>@router.get(\"/farm/{farm_id}/tasks/{task_id}\", response_model=TaskResponse, status_code=status.HTTP_200_OK)\ndef get_task_by_id(\n    farm_id: int,\n    task_id: int,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; TaskResponse:\n    \"\"\"\n    Obtiene una tarea espec\u00edfica por su ID.\n\n    Parameters:\n        farm_id (int): ID de la finca.\n        task_id (int): ID de la tarea.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        TaskResponse: Detalles de la tarea solicitada.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de la tarea.\n    \"\"\"\n    get_task_by_id_use_case = GetTaskByIdUseCase(db)\n    try:\n        return get_task_by_id_use_case.get_task_by_id(farm_id, task_id, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al obtener la tarea: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"cultural_practices/endpoints/#listar-estados-de-tareas","title":"Listar Estados de Tareas","text":"<p>Lista todos los estados de las tareas de pr\u00e1cticas culturales.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Type Description <code>TaskStateListResponse</code> <p>List[TaskStateResponse]: Una lista de estados de tareas.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de los estados de las tareas.</p> Source code in <code>app\\cultural_practices\\infrastructure\\api.py</code> <pre><code>@router.get(\"/tasks/states\", response_model=TaskStateListResponse, status_code=status.HTTP_200_OK)\ndef list_task_states(\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; TaskStateListResponse:\n    \"\"\"\n    Lista todos los estados de las tareas de pr\u00e1cticas culturales.\n\n    Parameters:\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        List[TaskStateResponse]: Una lista de estados de tareas.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de los estados de las tareas.\n    \"\"\"\n    list_task_states_use_case = ListTaskStatesUseCase(db)\n    try:\n        return list_task_states_use_case.list_task_states(current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar los estados de las tareas: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"cultural_practices/endpoints/#cambiar-estado-de-tarea","title":"Cambiar Estado de Tarea","text":"<p>Cambia el estado de una tarea de labor cultural.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a cambiar el estado.</p> <code>Path(..., description='ID de la tarea', ge=1)</code> <code>state_id</code> <code>Union[int, str]</code> <p>ID del estado o comando ('in_progress', 'done').</p> <code>Path(..., description=\"ID del estado o comando ('in_progress'/'done')\")</code> <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Un objeto SuccessResponse indicando que el estado de la tarea fue cambiado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el cambio de estado de la tarea.</p> Source code in <code>app\\cultural_practices\\infrastructure\\api.py</code> <pre><code>@router.put(\n    \"/tasks/{task_id}/states/{state_id}\", \n    response_model=SuccessResponse, \n    status_code=status.HTTP_200_OK\n)\ndef change_task_state(\n    task_id: int = Path(..., description=\"ID de la tarea\", ge=1),\n    state_id: Union[int, str] = Path(..., description=\"ID del estado o comando ('in_progress'/'done')\"),\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Cambia el estado de una tarea de labor cultural.\n\n    Parameters:\n        task_id (int): ID de la tarea a cambiar el estado.\n        state_id (Union[int, str]): ID del estado o comando ('in_progress', 'done').\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Un objeto SuccessResponse indicando que el estado de la tarea fue cambiado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el cambio de estado de la tarea.\n    \"\"\"\n    change_task_state_use_case = ChangeTaskStateUseCase(db)\n    try:\n        return change_task_state_use_case.change_task_state(task_id, state_id, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al cambiar de estado la tarea: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"cultural_practices/endpoints/#listar-tipos-de-tareas","title":"Listar Tipos de Tareas","text":"<p>Lista todos los tipos de labor cultural disponibles.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>TaskTypeListResponse</code> <code>TaskTypeListResponse</code> <p>Una lista de tipos de labor cultural.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de los tipos de labor cultural.</p> Source code in <code>app\\cultural_practices\\infrastructure\\api.py</code> <pre><code>@router.get(\"/tasks/types\", response_model=TaskTypeListResponse, status_code=status.HTTP_200_OK)\ndef list_task_types(\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; TaskTypeListResponse:\n    \"\"\"\n    Lista todos los tipos de labor cultural disponibles.\n\n    Parameters:\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        TaskTypeListResponse: Una lista de tipos de labor cultural.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de los tipos de labor cultural.\n    \"\"\"\n    list_task_types_use_case = ListTaskTypesUseCase(db)\n    try:\n        return list_task_types_use_case.list_task_types(current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar los tipos de labor cultural: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"cultural_practices/models/","title":"Modelos del M\u00f3dulo de Pr\u00e1cticas Culturales","text":""},{"location":"cultural_practices/models/#modelos-de-dominio","title":"Modelos de Dominio","text":""},{"location":"cultural_practices/models/#tarea","title":"Tarea","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo para la creaci\u00f3n de una tarea de labor cultural.</p> <p>Attributes:</p> Name Type Description <code>nombre</code> <code>str</code> <p>Nombre de la tarea. Debe tener entre 3 y 255 caracteres.</p> <code>tipo_labor_id</code> <code>int</code> <p>ID del tipo de labor cultural.</p> <code>fecha_inicio_estimada</code> <code>date</code> <p>Fecha estimada de inicio de la tarea.</p> <code>descripcion</code> <code>Optional[str]</code> <p>Descripci\u00f3n de la tarea, m\u00e1ximo 500 caracteres.</p> <code>estado_id</code> <code>int</code> <p>ID del estado de la tarea.</p> <code>lote_id</code> <code>int</code> <p>ID del lote asociado a la tarea.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>class TaskCreate(BaseModel):\n    \"\"\"Modelo para la creaci\u00f3n de una tarea de labor cultural.\n\n    Attributes:\n        nombre (str): Nombre de la tarea. Debe tener entre 3 y 255 caracteres.\n        tipo_labor_id (int): ID del tipo de labor cultural.\n        fecha_inicio_estimada (date): Fecha estimada de inicio de la tarea.\n        descripcion (Optional[str]): Descripci\u00f3n de la tarea, m\u00e1ximo 500 caracteres.\n        estado_id (int): ID del estado de la tarea.\n        lote_id (int): ID del lote asociado a la tarea.\n    \"\"\"\n    nombre: str = Field(..., min_length=3, max_length=255)\n    tipo_labor_id: int\n    fecha_inicio_estimada: date\n    descripcion: Optional[str] = Field(None, max_length=500)\n    estado_id: int = Field(default=1)\n    lote_id: int\n\n    @field_validator('nombre')\n    def validate_no_emojis_nombre(cls, value):\n        \"\"\"Valida que el nombre no contenga emojis.\"\"\"\n        return validate_no_emojis(value)\n\n    @field_validator('nombre')\n    def validate_no_special_chars_nombre(cls, value):\n        \"\"\"Valida que el nombre no contenga caracteres especiales.\"\"\"\n        return validate_no_special_chars(value)\n\n    @field_validator('nombre')\n    def validate_no_xss_nombre(cls, value):\n        \"\"\"Valida que el nombre no contenga XSS.\"\"\"\n        return validate_no_xss(value)\n\n    @field_validator('fecha_inicio_estimada')\n    def validar_fecha_inicio_estimada(cls, value):\n        \"\"\"Valida que la fecha de inicio estimada no sea anterior a un mes desde la fecha actual.\"\"\"\n        # Calcular la fecha l\u00edmite (un mes atr\u00e1s)\n        fecha_limite = date.today() - timedelta(days=30)\n\n        if value &lt; fecha_limite:\n            raise ValueError('La fecha de inicio estimada no puede ser anterior a un mes desde la fecha actual.')\n        return value\n</code></pre>"},{"location":"cultural_practices/models/#app.cultural_practices.domain.schemas.TaskCreate.validar_fecha_inicio_estimada","title":"<code>validar_fecha_inicio_estimada(value)</code>","text":"<p>Valida que la fecha de inicio estimada no sea anterior a un mes desde la fecha actual.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>@field_validator('fecha_inicio_estimada')\ndef validar_fecha_inicio_estimada(cls, value):\n    \"\"\"Valida que la fecha de inicio estimada no sea anterior a un mes desde la fecha actual.\"\"\"\n    # Calcular la fecha l\u00edmite (un mes atr\u00e1s)\n    fecha_limite = date.today() - timedelta(days=30)\n\n    if value &lt; fecha_limite:\n        raise ValueError('La fecha de inicio estimada no puede ser anterior a un mes desde la fecha actual.')\n    return value\n</code></pre>"},{"location":"cultural_practices/models/#app.cultural_practices.domain.schemas.TaskCreate.validate_no_emojis_nombre","title":"<code>validate_no_emojis_nombre(value)</code>","text":"<p>Valida que el nombre no contenga emojis.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_no_emojis_nombre(cls, value):\n    \"\"\"Valida que el nombre no contenga emojis.\"\"\"\n    return validate_no_emojis(value)\n</code></pre>"},{"location":"cultural_practices/models/#app.cultural_practices.domain.schemas.TaskCreate.validate_no_special_chars_nombre","title":"<code>validate_no_special_chars_nombre(value)</code>","text":"<p>Valida que el nombre no contenga caracteres especiales.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_no_special_chars_nombre(cls, value):\n    \"\"\"Valida que el nombre no contenga caracteres especiales.\"\"\"\n    return validate_no_special_chars(value)\n</code></pre>"},{"location":"cultural_practices/models/#app.cultural_practices.domain.schemas.TaskCreate.validate_no_xss_nombre","title":"<code>validate_no_xss_nombre(value)</code>","text":"<p>Valida que el nombre no contenga XSS.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_no_xss_nombre(cls, value):\n    \"\"\"Valida que el nombre no contenga XSS.\"\"\"\n    return validate_no_xss(value)\n</code></pre>"},{"location":"cultural_practices/models/#asignacion","title":"Asignaci\u00f3n","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo para la creaci\u00f3n de asignaciones de tareas.</p> <p>Attributes:</p> Name Type Description <code>usuario_ids</code> <code>List[int]</code> <p>Lista de IDs de usuarios a los que se asignar\u00e1 la tarea.</p> <code>tarea_labor_cultural_id</code> <code>int</code> <p>ID de la tarea de labor cultural.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>class AssignmentCreate(BaseModel):\n    \"\"\"Modelo para la creaci\u00f3n de asignaciones de tareas.\n\n    Attributes:\n        usuario_ids (List[int]): Lista de IDs de usuarios a los que se asignar\u00e1 la tarea.\n        tarea_labor_cultural_id (int): ID de la tarea de labor cultural.\n    \"\"\"\n    usuario_ids: List[int]\n    tarea_labor_cultural_id: int\n</code></pre>"},{"location":"cultural_practices/models/#estado-de-tarea","title":"Estado de Tarea","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo de respuesta para el estado de una tarea.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>ID \u00fanico del estado.</p> <code>nombre</code> <code>str</code> <p>Nombre del estado.</p> <code>descripcion</code> <code>Optional[str]</code> <p>Descripci\u00f3n del estado.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>class TaskStateResponse(BaseModel):\n    \"\"\"Modelo de respuesta para el estado de una tarea.\n\n    Attributes:\n        id (int): ID \u00fanico del estado.\n        nombre (str): Nombre del estado.\n        descripcion (Optional[str]): Descripci\u00f3n del estado.\n    \"\"\"\n    id: int\n    nombre: str\n    descripcion: Optional[str] = None\n</code></pre>"},{"location":"cultural_practices/models/#tipo-de-tarea","title":"Tipo de Tarea","text":"<p>               Bases: <code>BaseModel</code></p> <p>Modelo de respuesta para el tipo de tarea.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>ID \u00fanico del tipo de labor.</p> <code>nombre</code> <code>str</code> <p>Nombre del tipo de labor.</p> <code>descripcion</code> <code>Optional[str]</code> <p>Descripci\u00f3n del tipo de labor.</p> Source code in <code>app\\cultural_practices\\domain\\schemas.py</code> <pre><code>class TaskTypeResponse(BaseModel):\n    \"\"\"Modelo de respuesta para el tipo de tarea.\n\n    Attributes:\n        id (int): ID \u00fanico del tipo de labor.\n        nombre (str): Nombre del tipo de labor.\n        descripcion (Optional[str]): Descripci\u00f3n del tipo de labor.\n    \"\"\"\n    id: int\n    nombre: str\n    descripcion: Optional[str] = None\n</code></pre>"},{"location":"cultural_practices/overview/","title":"Visi\u00f3n General del M\u00f3dulo de Pr\u00e1cticas Culturales","text":""},{"location":"cultural_practices/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>El m\u00f3dulo de pr\u00e1cticas culturales gestiona todas las labores y actividades agr\u00edcolas que se realizan en los cultivos. Este m\u00f3dulo es esencial para el seguimiento y control de las tareas necesarias para el mantenimiento y desarrollo \u00f3ptimo de los cultivos.</p>"},{"location":"cultural_practices/overview/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"cultural_practices/overview/#1-gestion-de-tareas","title":"1. Gesti\u00f3n de Tareas","text":"<ul> <li>Creaci\u00f3n y asignaci\u00f3n de tareas</li> <li>Seguimiento del estado de las tareas</li> <li>Programaci\u00f3n de labores culturales</li> <li>Notificaciones y recordatorios</li> </ul>"},{"location":"cultural_practices/overview/#2-tipos-de-labores-culturales","title":"2. Tipos de Labores Culturales","text":"<ul> <li>Preparaci\u00f3n del terreno</li> <li>Siembra</li> <li>Fertilizaci\u00f3n</li> <li>Control de malezas</li> <li>Control de plagas</li> <li>Riego</li> <li>Cosecha</li> </ul>"},{"location":"cultural_practices/overview/#3-estados-de-las-tareas","title":"3. Estados de las Tareas","text":"<ul> <li>Programada</li> <li>En Progreso</li> <li>Completada</li> <li>Cancelada</li> <li>Pendiente</li> <li>Retrasada</li> <li>Fallida</li> <li>Revisada</li> <li>Aprobada</li> <li>Postergada</li> <li>Cerrada</li> </ul>"},{"location":"cultural_practices/overview/#4-asignacion-y-seguimiento","title":"4. Asignaci\u00f3n y Seguimiento","text":"<ul> <li>Asignaci\u00f3n de responsables</li> <li>Control de fechas y plazos</li> <li>Registro de avances</li> <li>Validaci\u00f3n de completitud</li> </ul>"},{"location":"cultural_practices/overview/#integracion-con-otros-modulos","title":"Integraci\u00f3n con Otros M\u00f3dulos","text":"<p>El m\u00f3dulo se integra con:</p> <ul> <li>M\u00f3dulo de Usuarios: Para la asignaci\u00f3n de tareas</li> <li>M\u00f3dulo de Cultivos: Para el contexto de las labores</li> <li>M\u00f3dulo de Lotes: Para la ubicaci\u00f3n de las actividades</li> </ul>"},{"location":"cultural_practices/overview/#casos-de-uso-comunes","title":"Casos de Uso Comunes","text":"<ol> <li>Creaci\u00f3n de nueva tarea</li> <li>Asignaci\u00f3n de responsables</li> <li>Actualizaci\u00f3n de estado</li> <li>Consulta de tareas pendientes</li> <li>Generaci\u00f3n de reportes de actividades</li> </ol>"},{"location":"cultural_practices/overview/#estructura-tecnica","title":"Estructura T\u00e9cnica","text":"<p>El m\u00f3dulo sigue una arquitectura limpia con:</p> <ul> <li>Domain: Definici\u00f3n de entidades y reglas</li> <li>Application: L\u00f3gica de negocio y casos de uso</li> <li>Infrastructure: Implementaci\u00f3n t\u00e9cnica y persistencia</li> </ul>"},{"location":"cultural_practices/overview/#documentacion-relacionada","title":"Documentaci\u00f3n Relacionada","text":"<ul> <li>Endpoints</li> <li>Modelos de Datos</li> <li>Casos de Uso</li> </ul>"},{"location":"cultural_practices/use_cases/","title":"Casos de Uso del M\u00f3dulo de Pr\u00e1cticas Culturales","text":""},{"location":"cultural_practices/use_cases/#asignar-tarea","title":"Asignar Tarea","text":"<p>Caso de uso para asignar tareas de labor cultural a usuarios.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para la creaci\u00f3n de asignaciones de tareas, asegurando que se cumplan las validaciones necesarias antes de realizar la asignaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuarios.</p> <code>plot_repository</code> <code>PlotRepository</code> <p>Repositorio para operaciones de lotes.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones de fincas.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> Source code in <code>app\\cultural_practices\\application\\assign_task_use_case.py</code> <pre><code>class AssignTaskUseCase:\n    \"\"\"Caso de uso para asignar tareas de labor cultural a usuarios.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para la creaci\u00f3n de asignaciones de tareas,\n    asegurando que se cumplan las validaciones necesarias antes de realizar la asignaci\u00f3n.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n        user_repository (UserRepository): Repositorio para operaciones de usuarios.\n        plot_repository (PlotRepository): Repositorio para operaciones de lotes.\n        farm_repository (FarmRepository): Repositorio para operaciones de fincas.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.cultural_practice_repository = CulturalPracticesRepository(db)\n        self.user_repository = UserRepository(db)\n        self.plot_repository = PlotRepository(db)\n        self.farm_repository = FarmRepository(db)\n        self.farm_service = FarmService(db)\n\n    def create_assignment(self, assignment_data: AssignmentCreate, current_user: UserInDB) -&gt; MultipleResponse:\n        \"\"\"Crea asignaciones de tareas para los usuarios especificados.\n\n        Este m\u00e9todo valida la existencia de la tarea, el lote y la finca, as\u00ed como los permisos del usuario\n        que intenta realizar la asignaci\u00f3n. Luego, itera sobre los IDs de los usuarios y crea las asignaciones\n        correspondientes, registrando los mensajes de \u00e9xito o error.\n\n        Args:\n            assignment_data (AssignmentCreate): Datos de la asignaci\u00f3n a crear.\n            current_user (UserInDB): Usuario actual autenticado que intenta realizar la asignaci\u00f3n.\n\n        Returns:\n            MultipleResponse: Respuesta que incluye mensajes sobre el resultado de las asignaciones y el c\u00f3digo de estado.\n\n        Raises:\n            DomainException: Si la tarea, lote o finca no existen, o si el usuario no tiene permisos.\n        \"\"\"\n        # Validar que la tarea existe\n        task = self.cultural_practice_repository.get_task_by_id(assignment_data.tarea_labor_cultural_id)\n        if not task:\n            raise DomainException(\n                message=\"No se pudo obtener la tarea.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Obtener lote por ID\n        plot = self.plot_repository.get_plot_by_id(task.lote_id)\n        if not plot:\n            raise DomainException(\n                message=\"No se pudo obtener el lote.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Obtener finca por ID\n        farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n        if not farm:\n            raise DomainException(\n                message=\"No se pudo obtener la finca.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar que el usuario sea administrador de la finca\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n            raise DomainException(\n                message=\"No tienes permisos para asignar tareas en esta finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        messages = []\n        success_count = 0\n        failure_count = 0\n\n        # Iterar sobre cada usuario_id en usuario_ids\n        for usuario_id in assignment_data.usuario_ids:\n            # Obtener el nombre del usuario\n            user = self.user_repository.get_user_by_id(usuario_id)\n            if not user:\n                messages.append(f\"El usuario con ID {usuario_id} especificado no existe.\")\n                failure_count += 1\n                continue\n\n            user_name = user.nombre + \" \" + user.apellido\n\n            if current_user.id == usuario_id:\n                messages.append(f\"El usuario {user_name} es el administrador de la finca.\")\n                failure_count += 1\n                continue\n\n            # Validar que el usuario es trabajador de la finca\n            if not self.farm_service.user_is_farm_worker(usuario_id, farm.id):\n                messages.append(f\"El usuario {user_name} no es trabajador de la finca.\")\n                failure_count += 1\n                continue\n\n            # Validar que el usuario no tenga ya asignada esa tarea\n            if self.cultural_practice_repository.get_user_task_assignment(usuario_id, assignment_data.tarea_labor_cultural_id):\n                messages.append(f\"El usuario {user_name} ya tiene asignada la tarea con ID {assignment_data.tarea_labor_cultural_id}.\")\n                failure_count += 1\n                continue\n\n            assignment_data_single = AssignmentCreateSingle(\n                usuario_id=usuario_id,\n                tarea_labor_cultural_id=assignment_data.tarea_labor_cultural_id\n            )\n\n            if not self.cultural_practice_repository.create_assignment(assignment_data_single):\n                messages.append(f\"No se pudo crear la asignaci\u00f3n para el usuario {user_name}.\")\n                failure_count += 1\n                continue\n\n            messages.append(f\"Asignaci\u00f3n creada exitosamente para el usuario {user_name}.\")\n            success_count += 1\n\n        if success_count &gt; 0 and failure_count &gt; 0:\n            status_code = status.HTTP_207_MULTI_STATUS\n        elif success_count == 0:\n            status_code = status.HTTP_400_BAD_REQUEST\n        else:\n            status_code = status.HTTP_200_OK\n\n        return MultipleResponse(messages=messages, status_code=status_code)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.assign_task_use_case.AssignTaskUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\cultural_practices\\application\\assign_task_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.cultural_practice_repository = CulturalPracticesRepository(db)\n    self.user_repository = UserRepository(db)\n    self.plot_repository = PlotRepository(db)\n    self.farm_repository = FarmRepository(db)\n    self.farm_service = FarmService(db)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.assign_task_use_case.AssignTaskUseCase.create_assignment","title":"<code>create_assignment(assignment_data, current_user)</code>","text":"<p>Crea asignaciones de tareas para los usuarios especificados.</p> <p>Este m\u00e9todo valida la existencia de la tarea, el lote y la finca, as\u00ed como los permisos del usuario que intenta realizar la asignaci\u00f3n. Luego, itera sobre los IDs de los usuarios y crea las asignaciones correspondientes, registrando los mensajes de \u00e9xito o error.</p> <p>Parameters:</p> Name Type Description Default <code>assignment_data</code> <code>AssignmentCreate</code> <p>Datos de la asignaci\u00f3n a crear.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado que intenta realizar la asignaci\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>MultipleResponse</code> <code>MultipleResponse</code> <p>Respuesta que incluye mensajes sobre el resultado de las asignaciones y el c\u00f3digo de estado.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si la tarea, lote o finca no existen, o si el usuario no tiene permisos.</p> Source code in <code>app\\cultural_practices\\application\\assign_task_use_case.py</code> <pre><code>def create_assignment(self, assignment_data: AssignmentCreate, current_user: UserInDB) -&gt; MultipleResponse:\n    \"\"\"Crea asignaciones de tareas para los usuarios especificados.\n\n    Este m\u00e9todo valida la existencia de la tarea, el lote y la finca, as\u00ed como los permisos del usuario\n    que intenta realizar la asignaci\u00f3n. Luego, itera sobre los IDs de los usuarios y crea las asignaciones\n    correspondientes, registrando los mensajes de \u00e9xito o error.\n\n    Args:\n        assignment_data (AssignmentCreate): Datos de la asignaci\u00f3n a crear.\n        current_user (UserInDB): Usuario actual autenticado que intenta realizar la asignaci\u00f3n.\n\n    Returns:\n        MultipleResponse: Respuesta que incluye mensajes sobre el resultado de las asignaciones y el c\u00f3digo de estado.\n\n    Raises:\n        DomainException: Si la tarea, lote o finca no existen, o si el usuario no tiene permisos.\n    \"\"\"\n    # Validar que la tarea existe\n    task = self.cultural_practice_repository.get_task_by_id(assignment_data.tarea_labor_cultural_id)\n    if not task:\n        raise DomainException(\n            message=\"No se pudo obtener la tarea.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Obtener lote por ID\n    plot = self.plot_repository.get_plot_by_id(task.lote_id)\n    if not plot:\n        raise DomainException(\n            message=\"No se pudo obtener el lote.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Obtener finca por ID\n    farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n    if not farm:\n        raise DomainException(\n            message=\"No se pudo obtener la finca.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar que el usuario sea administrador de la finca\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n        raise DomainException(\n            message=\"No tienes permisos para asignar tareas en esta finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    messages = []\n    success_count = 0\n    failure_count = 0\n\n    # Iterar sobre cada usuario_id en usuario_ids\n    for usuario_id in assignment_data.usuario_ids:\n        # Obtener el nombre del usuario\n        user = self.user_repository.get_user_by_id(usuario_id)\n        if not user:\n            messages.append(f\"El usuario con ID {usuario_id} especificado no existe.\")\n            failure_count += 1\n            continue\n\n        user_name = user.nombre + \" \" + user.apellido\n\n        if current_user.id == usuario_id:\n            messages.append(f\"El usuario {user_name} es el administrador de la finca.\")\n            failure_count += 1\n            continue\n\n        # Validar que el usuario es trabajador de la finca\n        if not self.farm_service.user_is_farm_worker(usuario_id, farm.id):\n            messages.append(f\"El usuario {user_name} no es trabajador de la finca.\")\n            failure_count += 1\n            continue\n\n        # Validar que el usuario no tenga ya asignada esa tarea\n        if self.cultural_practice_repository.get_user_task_assignment(usuario_id, assignment_data.tarea_labor_cultural_id):\n            messages.append(f\"El usuario {user_name} ya tiene asignada la tarea con ID {assignment_data.tarea_labor_cultural_id}.\")\n            failure_count += 1\n            continue\n\n        assignment_data_single = AssignmentCreateSingle(\n            usuario_id=usuario_id,\n            tarea_labor_cultural_id=assignment_data.tarea_labor_cultural_id\n        )\n\n        if not self.cultural_practice_repository.create_assignment(assignment_data_single):\n            messages.append(f\"No se pudo crear la asignaci\u00f3n para el usuario {user_name}.\")\n            failure_count += 1\n            continue\n\n        messages.append(f\"Asignaci\u00f3n creada exitosamente para el usuario {user_name}.\")\n        success_count += 1\n\n    if success_count &gt; 0 and failure_count &gt; 0:\n        status_code = status.HTTP_207_MULTI_STATUS\n    elif success_count == 0:\n        status_code = status.HTTP_400_BAD_REQUEST\n    else:\n        status_code = status.HTTP_200_OK\n\n    return MultipleResponse(messages=messages, status_code=status_code)\n</code></pre>"},{"location":"cultural_practices/use_cases/#cambiar-estado-de-tarea","title":"Cambiar Estado de Tarea","text":"<p>Caso de uso para cambiar el estado de una tarea de labor cultural.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para cambiar el estado de una tarea, asegurando que se cumplan las validaciones necesarias antes de realizar el cambio.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> <code>plot_repository</code> <code>PlotRepository</code> <p>Repositorio para operaciones de lotes.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones de fincas.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>task_service</code> <code>TaskService</code> <p>Servicio para l\u00f3gica de negocio de tareas.</p> Source code in <code>app\\cultural_practices\\application\\change_task_state_use_case.py</code> <pre><code>class ChangeTaskStateUseCase:\n    \"\"\"Caso de uso para cambiar el estado de una tarea de labor cultural.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para cambiar el estado de una tarea,\n    asegurando que se cumplan las validaciones necesarias antes de realizar el cambio.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n        plot_repository (PlotRepository): Repositorio para operaciones de lotes.\n        farm_repository (FarmRepository): Repositorio para operaciones de fincas.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        task_service (TaskService): Servicio para l\u00f3gica de negocio de tareas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.cultural_practice_repository = CulturalPracticesRepository(db)\n        self.plot_repository = PlotRepository(db)\n        self.farm_repository = FarmRepository(db)\n        self.farm_service = FarmService(db)\n        self.task_service = TaskService(db)\n\n    def change_task_state(self, task_id: int, state_id: Union[int, str], current_user: UserInDB) -&gt; SuccessResponse:\n        \"\"\"Cambia el estado de una tarea de labor cultural.\n\n        Args:\n            task_id (int): ID de la tarea cuyo estado se desea cambiar.\n            state_id (Union[int, str]): ID del estado o comando ('in_progress', 'done').\n            current_user (UserInDB): Usuario actual autenticado que intenta cambiar el estado.\n\n        Returns:\n            SuccessResponse: Respuesta que indica que el estado de la tarea fue cambiado exitosamente.\n\n        Raises:\n            DomainException: Si la tarea, el estado, o los permisos del usuario no son v\u00e1lidos.\n        \"\"\"\n        # Validar existencia de la tarea\n        if not self.cultural_practice_repository.get_task_by_id(task_id):\n            raise DomainException(\n                message=\"La tarea especificada no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar permisos del usuario\n        if not self.user_can_change_task_state(current_user.id, task_id):\n            raise DomainException(\n                message=\"No tienes permisos para cambiar el estado de esta tarea.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # Intentar convertir state_id a entero\n        try:\n            numeric_state_id = int(state_id)\n        except ValueError:\n            # Si falla, intentar convertir comando de texto a ID\n            numeric_state_id = self.task_service.get_state_id_from_command(state_id)\n            if numeric_state_id is None:\n                raise DomainException(\n                    message=\"Comando de estado inv\u00e1lido. Use un ID num\u00e9rico o 'in_progress'/'done'.\",\n                    status_code=status.HTTP_400_BAD_REQUEST\n                )\n\n        # Obtener el estado objetivo\n        target_state: TaskStateResponse = self.cultural_practice_repository.get_task_state_by_id(numeric_state_id)\n        if not target_state:\n            raise DomainException(\n                message=\"No se pudo obtener el estado al cu\u00e1l se quiere cambiar la tarea.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Obtener tarea por ID\n        task = self.cultural_practice_repository.get_task_by_id(task_id)\n        if not task:\n            raise DomainException(\n                message=\"No se pudo obtener la tarea.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Actualizar el estado de la tarea\n        task.estado_id = numeric_state_id\n        task.estado = target_state\n\n        # Actualizar la fecha de finalizaci\u00f3n si es necesario\n        if target_state.nombre == TaskService.COMPLETADA:\n            task.fecha_finalizacion = datetime_utc_time()\n        else:\n            task.fecha_finalizacion = None\n\n        # Guardar cambios en la base de datos\n        if not self.cultural_practice_repository.update_task(task):\n            raise DomainException(\n                message=\"No se pudo actualizar el estado de la tarea.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessResponse(\n            message=f\"Estado de la tarea cambiado exitosamente a '{target_state.nombre}'.\"\n        )\n\n    def user_can_change_task_state(self, user_id: int, task_id: int) -&gt; bool:\n        \"\"\"Verifica si un usuario tiene permisos para cambiar el estado de una tarea.\n\n        Este m\u00e9todo valida la existencia de la tarea, el lote y la finca asociada, y verifica si el usuario\n        es administrador o trabajador de la finca.\n\n        Args:\n            user_id (int): ID del usuario que intenta cambiar el estado.\n            task_id (int): ID de la tarea cuyo estado se desea cambiar.\n\n        Returns:\n            bool: True si el usuario tiene permisos para cambiar el estado, False en caso contrario.\n\n        Raises:\n            DomainException: Si la tarea, el lote o la finca no existen.\n        \"\"\"\n        # Obtener tarea por ID\n        task = self.cultural_practice_repository.get_task_by_id(task_id)\n        if not task:\n            raise DomainException(\n                message=\"No se pudo obtener la tarea.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Obtener lote por ID\n        plot = self.plot_repository.get_plot_by_id(task.lote_id)\n        if not plot:\n            raise DomainException(\n                message=\"No se pudo obtener el lote.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Obtener finca por ID\n        farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n        if not farm:\n            raise DomainException(\n                message=\"No se pudo obtener la finca.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Verificar si el usuario es administrador o trabajador de la finca\n        return (self.farm_service.user_is_farm_admin(user_id, farm.id) or \n                self.farm_service.user_is_farm_worker(user_id, farm.id))\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.change_task_state_use_case.ChangeTaskStateUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\cultural_practices\\application\\change_task_state_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.cultural_practice_repository = CulturalPracticesRepository(db)\n    self.plot_repository = PlotRepository(db)\n    self.farm_repository = FarmRepository(db)\n    self.farm_service = FarmService(db)\n    self.task_service = TaskService(db)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.change_task_state_use_case.ChangeTaskStateUseCase.change_task_state","title":"<code>change_task_state(task_id, state_id, current_user)</code>","text":"<p>Cambia el estado de una tarea de labor cultural.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea cuyo estado se desea cambiar.</p> required <code>state_id</code> <code>Union[int, str]</code> <p>ID del estado o comando ('in_progress', 'done').</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado que intenta cambiar el estado.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta que indica que el estado de la tarea fue cambiado exitosamente.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si la tarea, el estado, o los permisos del usuario no son v\u00e1lidos.</p> Source code in <code>app\\cultural_practices\\application\\change_task_state_use_case.py</code> <pre><code>def change_task_state(self, task_id: int, state_id: Union[int, str], current_user: UserInDB) -&gt; SuccessResponse:\n    \"\"\"Cambia el estado de una tarea de labor cultural.\n\n    Args:\n        task_id (int): ID de la tarea cuyo estado se desea cambiar.\n        state_id (Union[int, str]): ID del estado o comando ('in_progress', 'done').\n        current_user (UserInDB): Usuario actual autenticado que intenta cambiar el estado.\n\n    Returns:\n        SuccessResponse: Respuesta que indica que el estado de la tarea fue cambiado exitosamente.\n\n    Raises:\n        DomainException: Si la tarea, el estado, o los permisos del usuario no son v\u00e1lidos.\n    \"\"\"\n    # Validar existencia de la tarea\n    if not self.cultural_practice_repository.get_task_by_id(task_id):\n        raise DomainException(\n            message=\"La tarea especificada no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar permisos del usuario\n    if not self.user_can_change_task_state(current_user.id, task_id):\n        raise DomainException(\n            message=\"No tienes permisos para cambiar el estado de esta tarea.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # Intentar convertir state_id a entero\n    try:\n        numeric_state_id = int(state_id)\n    except ValueError:\n        # Si falla, intentar convertir comando de texto a ID\n        numeric_state_id = self.task_service.get_state_id_from_command(state_id)\n        if numeric_state_id is None:\n            raise DomainException(\n                message=\"Comando de estado inv\u00e1lido. Use un ID num\u00e9rico o 'in_progress'/'done'.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n    # Obtener el estado objetivo\n    target_state: TaskStateResponse = self.cultural_practice_repository.get_task_state_by_id(numeric_state_id)\n    if not target_state:\n        raise DomainException(\n            message=\"No se pudo obtener el estado al cu\u00e1l se quiere cambiar la tarea.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Obtener tarea por ID\n    task = self.cultural_practice_repository.get_task_by_id(task_id)\n    if not task:\n        raise DomainException(\n            message=\"No se pudo obtener la tarea.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Actualizar el estado de la tarea\n    task.estado_id = numeric_state_id\n    task.estado = target_state\n\n    # Actualizar la fecha de finalizaci\u00f3n si es necesario\n    if target_state.nombre == TaskService.COMPLETADA:\n        task.fecha_finalizacion = datetime_utc_time()\n    else:\n        task.fecha_finalizacion = None\n\n    # Guardar cambios en la base de datos\n    if not self.cultural_practice_repository.update_task(task):\n        raise DomainException(\n            message=\"No se pudo actualizar el estado de la tarea.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(\n        message=f\"Estado de la tarea cambiado exitosamente a '{target_state.nombre}'.\"\n    )\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.change_task_state_use_case.ChangeTaskStateUseCase.user_can_change_task_state","title":"<code>user_can_change_task_state(user_id, task_id)</code>","text":"<p>Verifica si un usuario tiene permisos para cambiar el estado de una tarea.</p> <p>Este m\u00e9todo valida la existencia de la tarea, el lote y la finca asociada, y verifica si el usuario es administrador o trabajador de la finca.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario que intenta cambiar el estado.</p> required <code>task_id</code> <code>int</code> <p>ID de la tarea cuyo estado se desea cambiar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario tiene permisos para cambiar el estado, False en caso contrario.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si la tarea, el lote o la finca no existen.</p> Source code in <code>app\\cultural_practices\\application\\change_task_state_use_case.py</code> <pre><code>def user_can_change_task_state(self, user_id: int, task_id: int) -&gt; bool:\n    \"\"\"Verifica si un usuario tiene permisos para cambiar el estado de una tarea.\n\n    Este m\u00e9todo valida la existencia de la tarea, el lote y la finca asociada, y verifica si el usuario\n    es administrador o trabajador de la finca.\n\n    Args:\n        user_id (int): ID del usuario que intenta cambiar el estado.\n        task_id (int): ID de la tarea cuyo estado se desea cambiar.\n\n    Returns:\n        bool: True si el usuario tiene permisos para cambiar el estado, False en caso contrario.\n\n    Raises:\n        DomainException: Si la tarea, el lote o la finca no existen.\n    \"\"\"\n    # Obtener tarea por ID\n    task = self.cultural_practice_repository.get_task_by_id(task_id)\n    if not task:\n        raise DomainException(\n            message=\"No se pudo obtener la tarea.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Obtener lote por ID\n    plot = self.plot_repository.get_plot_by_id(task.lote_id)\n    if not plot:\n        raise DomainException(\n            message=\"No se pudo obtener el lote.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Obtener finca por ID\n    farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n    if not farm:\n        raise DomainException(\n            message=\"No se pudo obtener la finca.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si el usuario es administrador o trabajador de la finca\n    return (self.farm_service.user_is_farm_admin(user_id, farm.id) or \n            self.farm_service.user_is_farm_worker(user_id, farm.id))\n</code></pre>"},{"location":"cultural_practices/use_cases/#crear-tarea","title":"Crear Tarea","text":"<p>Caso de uso para crear tareas de labor cultural.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para la creaci\u00f3n de tareas, asegurando que se cumplan las validaciones necesarias antes de realizar la creaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones de fincas.</p> <code>plot_repository</code> <code>PlotRepository</code> <p>Repositorio para operaciones de lotes.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>task_service</code> <code>TaskService</code> <p>Servicio para l\u00f3gica de negocio de tareas.</p> <code>crop_repository</code> <code>CropRepository</code> <p>Repositorio para operaciones de cultivos.</p> Source code in <code>app\\cultural_practices\\application\\create_task_use_case.py</code> <pre><code>class CreateTaskUseCase:\n    \"\"\"Caso de uso para crear tareas de labor cultural.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para la creaci\u00f3n de tareas, asegurando que se cumplan\n    las validaciones necesarias antes de realizar la creaci\u00f3n.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n        farm_repository (FarmRepository): Repositorio para operaciones de fincas.\n        plot_repository (PlotRepository): Repositorio para operaciones de lotes.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        task_service (TaskService): Servicio para l\u00f3gica de negocio de tareas.\n        crop_repository (CropRepository): Repositorio para operaciones de cultivos.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.cultural_practice_repository = CulturalPracticesRepository(db)\n        self.farm_repository = FarmRepository(db)\n        self.plot_repository = PlotRepository(db)\n        self.farm_service = FarmService(db)\n        self.task_service = TaskService(db)\n        self.crop_repository = CropRepository(db)\n\n    def create_task(self, task_data: TaskCreate, current_user: UserInDB) -&gt; SuccessTaskCreateResponse:\n        \"\"\"Crea una nueva tarea de labor cultural.\n\n        Este m\u00e9todo valida la existencia del lote, el cultivo activo en el lote, la finca asociada,\n        y los permisos del usuario que intenta crear la tarea. Si todas las validaciones son exitosas,\n        se crea la tarea.\n\n        Args:\n            task_data (TaskCreate): Datos de la tarea a crear.\n            current_user (UserInDB): Usuario actual autenticado que intenta crear la tarea.\n\n        Returns:\n            SuccessTaskCreateResponse: Respuesta que indica que la tarea fue creada exitosamente.\n\n        Raises:\n            DomainException: Si el lote, la finca, el cultivo activo, el tipo de labor cultural o el estado de tarea no son v\u00e1lidos.\n        \"\"\"\n        plot = self.plot_repository.get_plot_by_id(task_data.lote_id)\n        if not plot:\n            raise DomainException(\n                message=\"No se pudo obtener el lote.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar que el lote tiene un cultivo activo\n        if not self.crop_repository.has_active_crop(task_data.lote_id):\n            raise DomainException(\n                message=\"El lote no tiene un cultivo activo. No se pueden crear tareas en lotes sin cultivos activos.\",\n                status_code=status.HTTP_409_CONFLICT\n            )\n\n        # Buscar el id de la finca por medio del id del lote\n        farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n        if not farm:\n            raise DomainException(\n                message=\"No se pudo obtener la finca.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        # Validar que el usuario sea administrador de la finca\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n            raise DomainException(\n                message=\"No tienes permisos para crear tareas en esta finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # Verificar si el tipo de labor cultural existe\n        if not self.cultural_practice_repository.get_task_type_by_id(task_data.tipo_labor_id):\n            raise DomainException(\n                message=\"El tipo de labor cultural especificado no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Verificar si el estado de tarea existe\n        task_state = self.cultural_practice_repository.get_task_state_by_id(task_data.estado_id)\n        if not task_state:\n            raise DomainException(\n                message=\"El estado de tarea especificado no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Crear la tarea\n        task = self.cultural_practice_repository.create_task(task_data)\n        if not task:\n            raise DomainException(\n                message=\"No se pudo crear la tarea de labor cultural.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessTaskCreateResponse(message=\"Tarea creada exitosamente\", task_id=task.id)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.create_task_use_case.CreateTaskUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\cultural_practices\\application\\create_task_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.cultural_practice_repository = CulturalPracticesRepository(db)\n    self.farm_repository = FarmRepository(db)\n    self.plot_repository = PlotRepository(db)\n    self.farm_service = FarmService(db)\n    self.task_service = TaskService(db)\n    self.crop_repository = CropRepository(db)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.create_task_use_case.CreateTaskUseCase.create_task","title":"<code>create_task(task_data, current_user)</code>","text":"<p>Crea una nueva tarea de labor cultural.</p> <p>Este m\u00e9todo valida la existencia del lote, el cultivo activo en el lote, la finca asociada, y los permisos del usuario que intenta crear la tarea. Si todas las validaciones son exitosas, se crea la tarea.</p> <p>Parameters:</p> Name Type Description Default <code>task_data</code> <code>TaskCreate</code> <p>Datos de la tarea a crear.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado que intenta crear la tarea.</p> required <p>Returns:</p> Name Type Description <code>SuccessTaskCreateResponse</code> <code>SuccessTaskCreateResponse</code> <p>Respuesta que indica que la tarea fue creada exitosamente.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si el lote, la finca, el cultivo activo, el tipo de labor cultural o el estado de tarea no son v\u00e1lidos.</p> Source code in <code>app\\cultural_practices\\application\\create_task_use_case.py</code> <pre><code>def create_task(self, task_data: TaskCreate, current_user: UserInDB) -&gt; SuccessTaskCreateResponse:\n    \"\"\"Crea una nueva tarea de labor cultural.\n\n    Este m\u00e9todo valida la existencia del lote, el cultivo activo en el lote, la finca asociada,\n    y los permisos del usuario que intenta crear la tarea. Si todas las validaciones son exitosas,\n    se crea la tarea.\n\n    Args:\n        task_data (TaskCreate): Datos de la tarea a crear.\n        current_user (UserInDB): Usuario actual autenticado que intenta crear la tarea.\n\n    Returns:\n        SuccessTaskCreateResponse: Respuesta que indica que la tarea fue creada exitosamente.\n\n    Raises:\n        DomainException: Si el lote, la finca, el cultivo activo, el tipo de labor cultural o el estado de tarea no son v\u00e1lidos.\n    \"\"\"\n    plot = self.plot_repository.get_plot_by_id(task_data.lote_id)\n    if not plot:\n        raise DomainException(\n            message=\"No se pudo obtener el lote.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar que el lote tiene un cultivo activo\n    if not self.crop_repository.has_active_crop(task_data.lote_id):\n        raise DomainException(\n            message=\"El lote no tiene un cultivo activo. No se pueden crear tareas en lotes sin cultivos activos.\",\n            status_code=status.HTTP_409_CONFLICT\n        )\n\n    # Buscar el id de la finca por medio del id del lote\n    farm = self.farm_repository.get_farm_by_id(plot.finca_id)\n    if not farm:\n        raise DomainException(\n            message=\"No se pudo obtener la finca.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Validar que el usuario sea administrador de la finca\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n        raise DomainException(\n            message=\"No tienes permisos para crear tareas en esta finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # Verificar si el tipo de labor cultural existe\n    if not self.cultural_practice_repository.get_task_type_by_id(task_data.tipo_labor_id):\n        raise DomainException(\n            message=\"El tipo de labor cultural especificado no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si el estado de tarea existe\n    task_state = self.cultural_practice_repository.get_task_state_by_id(task_data.estado_id)\n    if not task_state:\n        raise DomainException(\n            message=\"El estado de tarea especificado no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Crear la tarea\n    task = self.cultural_practice_repository.create_task(task_data)\n    if not task:\n        raise DomainException(\n            message=\"No se pudo crear la tarea de labor cultural.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessTaskCreateResponse(message=\"Tarea creada exitosamente\", task_id=task.id)\n</code></pre>"},{"location":"cultural_practices/use_cases/#obtener-tarea-por-id","title":"Obtener Tarea por ID","text":"<p>Caso de uso para obtener una tarea de labor cultural por su ID.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para recuperar una tarea espec\u00edfica, asegurando que se cumplan las validaciones necesarias antes de devolver la tarea.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones de fincas.</p> Source code in <code>app\\cultural_practices\\application\\get_task_by_id_use_case.py</code> <pre><code>class GetTaskByIdUseCase:\n    \"\"\"Caso de uso para obtener una tarea de labor cultural por su ID.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para recuperar una tarea espec\u00edfica,\n    asegurando que se cumplan las validaciones necesarias antes de devolver la tarea.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        farm_repository (FarmRepository): Repositorio para operaciones de fincas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.cultural_practice_repository = CulturalPracticesRepository(db)\n        self.farm_service = FarmService(db)\n        self.farm_repository = FarmRepository(db)\n\n    def get_task_by_id(self, farm_id: int, task_id: int, current_user: UserInDB) -&gt; TaskResponse:\n        \"\"\"Obtiene una tarea de labor cultural por su ID.\n\n        Este m\u00e9todo valida la existencia de la tarea y verifica si el usuario tiene permisos\n        para acceder a la tarea. Si las validaciones son exitosas, devuelve la tarea.\n\n        Args:\n            farm_id (int): ID de la finca a la que pertenece la tarea.\n            task_id (int): ID de la tarea que se desea obtener.\n            current_user (UserInDB): Usuario actual autenticado que intenta acceder a la tarea.\n\n        Returns:\n            TaskResponse: Respuesta que contiene los detalles de la tarea.\n\n        Raises:\n            DomainException: Si la tarea no existe o si el usuario no tiene permisos para acceder a ella.\n        \"\"\"\n        # Validar que la tarea existe\n        task = self.cultural_practice_repository.get_task_by_id(task_id)\n        if not task:\n            raise DomainException(\n                message=\"La tarea especificada no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar que el usuario es el administrador de la finca\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n            raise DomainException(\n                message=\"No tienes permisos para acceder a esta tarea.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        return TaskResponse(\n            id=task.id,\n            nombre=task.nombre,\n            tipo_labor_id=task.tipo_labor_id,\n            tipo_labor_nombre=task.tipo_labor.nombre,\n            fecha_inicio_estimada=task.fecha_inicio_estimada,\n            fecha_finalizacion=task.fecha_finalizacion,\n            descripcion=task.descripcion,\n            estado_id=task.estado_id,\n            estado_nombre=task.estado.nombre,\n            lote_id=task.lote_id\n        )\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.get_task_by_id_use_case.GetTaskByIdUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\cultural_practices\\application\\get_task_by_id_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.cultural_practice_repository = CulturalPracticesRepository(db)\n    self.farm_service = FarmService(db)\n    self.farm_repository = FarmRepository(db)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.get_task_by_id_use_case.GetTaskByIdUseCase.get_task_by_id","title":"<code>get_task_by_id(farm_id, task_id, current_user)</code>","text":"<p>Obtiene una tarea de labor cultural por su ID.</p> <p>Este m\u00e9todo valida la existencia de la tarea y verifica si el usuario tiene permisos para acceder a la tarea. Si las validaciones son exitosas, devuelve la tarea.</p> <p>Parameters:</p> Name Type Description Default <code>farm_id</code> <code>int</code> <p>ID de la finca a la que pertenece la tarea.</p> required <code>task_id</code> <code>int</code> <p>ID de la tarea que se desea obtener.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado que intenta acceder a la tarea.</p> required <p>Returns:</p> Name Type Description <code>TaskResponse</code> <code>TaskResponse</code> <p>Respuesta que contiene los detalles de la tarea.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si la tarea no existe o si el usuario no tiene permisos para acceder a ella.</p> Source code in <code>app\\cultural_practices\\application\\get_task_by_id_use_case.py</code> <pre><code>def get_task_by_id(self, farm_id: int, task_id: int, current_user: UserInDB) -&gt; TaskResponse:\n    \"\"\"Obtiene una tarea de labor cultural por su ID.\n\n    Este m\u00e9todo valida la existencia de la tarea y verifica si el usuario tiene permisos\n    para acceder a la tarea. Si las validaciones son exitosas, devuelve la tarea.\n\n    Args:\n        farm_id (int): ID de la finca a la que pertenece la tarea.\n        task_id (int): ID de la tarea que se desea obtener.\n        current_user (UserInDB): Usuario actual autenticado que intenta acceder a la tarea.\n\n    Returns:\n        TaskResponse: Respuesta que contiene los detalles de la tarea.\n\n    Raises:\n        DomainException: Si la tarea no existe o si el usuario no tiene permisos para acceder a ella.\n    \"\"\"\n    # Validar que la tarea existe\n    task = self.cultural_practice_repository.get_task_by_id(task_id)\n    if not task:\n        raise DomainException(\n            message=\"La tarea especificada no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar que el usuario es el administrador de la finca\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n        raise DomainException(\n            message=\"No tienes permisos para acceder a esta tarea.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    return TaskResponse(\n        id=task.id,\n        nombre=task.nombre,\n        tipo_labor_id=task.tipo_labor_id,\n        tipo_labor_nombre=task.tipo_labor.nombre,\n        fecha_inicio_estimada=task.fecha_inicio_estimada,\n        fecha_finalizacion=task.fecha_finalizacion,\n        descripcion=task.descripcion,\n        estado_id=task.estado_id,\n        estado_nombre=task.estado.nombre,\n        lote_id=task.lote_id\n    )\n</code></pre>"},{"location":"cultural_practices/use_cases/#listar-tareas-por-usuario-y-finca","title":"Listar Tareas por Usuario y Finca","text":"<p>Caso de uso para listar las tareas de un usuario en una finca espec\u00edfica.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para recuperar las tareas asignadas a un usuario en una finca espec\u00edfica, asegurando que se cumplan las validaciones necesarias antes de devolver la lista de tareas.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuarios.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> Source code in <code>app\\cultural_practices\\application\\list_tasks_by_user_and_farm_use_case.py</code> <pre><code>class ListTasksByUserAndFarmUseCase:\n    \"\"\"Caso de uso para listar las tareas de un usuario en una finca espec\u00edfica.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para recuperar las tareas asignadas a un usuario\n    en una finca espec\u00edfica, asegurando que se cumplan las validaciones necesarias antes de devolver\n    la lista de tareas.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n        user_repository (UserRepository): Repositorio para operaciones de usuarios.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.cultural_practice_repository = CulturalPracticesRepository(db)\n        self.user_repository = UserRepository(db)\n        self.farm_service = FarmService(db)\n\n    def list_tasks_by_user_and_farm(self, farm_id: int, user_id: int, page: int, per_page: int, current_user: UserInDB) -&gt; PaginatedTaskListResponse:\n        \"\"\"Lista las tareas de un usuario en una finca espec\u00edfica de forma paginada.\n\n        Este m\u00e9todo valida que el usuario actual tenga permisos para acceder a las tareas del usuario\n        especificado en la finca indicada. Si las validaciones son exitosas, devuelve una lista paginada\n        de las tareas.\n\n        Args:\n            farm_id (int): ID de la finca de la que se desean listar las tareas.\n            user_id (int): ID del usuario cuyas tareas se desean listar.\n            page (int): N\u00famero de p\u00e1gina para la paginaci\u00f3n.\n            per_page (int): Cantidad de tareas por p\u00e1gina.\n            current_user (UserInDB): Usuario actual autenticado que intenta acceder a las tareas.\n\n        Returns:\n            PaginatedTaskListResponse: Respuesta que contiene la lista paginada de tareas del usuario.\n\n        Raises:\n            DomainException: Si el usuario no tiene permisos, no existe, o no es trabajador de la finca.\n        \"\"\"\n        # validar que el usuario es administrador de la finca\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n            raise DomainException(\n                message=\"No tienes permisos para listar las tareas de este usuario.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # validar que el usuario existe\n        if not self.user_repository.get_user_by_id(user_id):\n            raise DomainException(\n                message=\"El usuario especificado no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if current_user.id == user_id:\n            raise DomainException(\n                message=\"El usuario es el administrador de la finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # validar que el usuario pertenezca a la finca\n        if not self.farm_service.user_is_farm_worker(user_id, farm_id):\n            raise DomainException(\n                message=\"El usuario no es trabajador en la finca especificada.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # listar las tareas del usuario filtradas por la finca\n        total_tasks, tasks = self.cultural_practice_repository.list_tasks_by_user_and_farm_paginated(user_id, farm_id, page, per_page)\n\n        task_responses = [map_task_to_response(task) for task in tasks]\n\n        total_pages = ceil(total_tasks / per_page)\n\n        return PaginatedTaskListResponse(\n            tasks=task_responses,\n            total_tasks=total_tasks,\n            page=page,\n            per_page=per_page,\n            total_pages=total_pages\n        )\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.list_tasks_by_user_and_farm_use_case.ListTasksByUserAndFarmUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\cultural_practices\\application\\list_tasks_by_user_and_farm_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.cultural_practice_repository = CulturalPracticesRepository(db)\n    self.user_repository = UserRepository(db)\n    self.farm_service = FarmService(db)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.list_tasks_by_user_and_farm_use_case.ListTasksByUserAndFarmUseCase.list_tasks_by_user_and_farm","title":"<code>list_tasks_by_user_and_farm(farm_id, user_id, page, per_page, current_user)</code>","text":"<p>Lista las tareas de un usuario en una finca espec\u00edfica de forma paginada.</p> <p>Este m\u00e9todo valida que el usuario actual tenga permisos para acceder a las tareas del usuario especificado en la finca indicada. Si las validaciones son exitosas, devuelve una lista paginada de las tareas.</p> <p>Parameters:</p> Name Type Description Default <code>farm_id</code> <code>int</code> <p>ID de la finca de la que se desean listar las tareas.</p> required <code>user_id</code> <code>int</code> <p>ID del usuario cuyas tareas se desean listar.</p> required <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina para la paginaci\u00f3n.</p> required <code>per_page</code> <code>int</code> <p>Cantidad de tareas por p\u00e1gina.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado que intenta acceder a las tareas.</p> required <p>Returns:</p> Name Type Description <code>PaginatedTaskListResponse</code> <code>PaginatedTaskListResponse</code> <p>Respuesta que contiene la lista paginada de tareas del usuario.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si el usuario no tiene permisos, no existe, o no es trabajador de la finca.</p> Source code in <code>app\\cultural_practices\\application\\list_tasks_by_user_and_farm_use_case.py</code> <pre><code>def list_tasks_by_user_and_farm(self, farm_id: int, user_id: int, page: int, per_page: int, current_user: UserInDB) -&gt; PaginatedTaskListResponse:\n    \"\"\"Lista las tareas de un usuario en una finca espec\u00edfica de forma paginada.\n\n    Este m\u00e9todo valida que el usuario actual tenga permisos para acceder a las tareas del usuario\n    especificado en la finca indicada. Si las validaciones son exitosas, devuelve una lista paginada\n    de las tareas.\n\n    Args:\n        farm_id (int): ID de la finca de la que se desean listar las tareas.\n        user_id (int): ID del usuario cuyas tareas se desean listar.\n        page (int): N\u00famero de p\u00e1gina para la paginaci\u00f3n.\n        per_page (int): Cantidad de tareas por p\u00e1gina.\n        current_user (UserInDB): Usuario actual autenticado que intenta acceder a las tareas.\n\n    Returns:\n        PaginatedTaskListResponse: Respuesta que contiene la lista paginada de tareas del usuario.\n\n    Raises:\n        DomainException: Si el usuario no tiene permisos, no existe, o no es trabajador de la finca.\n    \"\"\"\n    # validar que el usuario es administrador de la finca\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n        raise DomainException(\n            message=\"No tienes permisos para listar las tareas de este usuario.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # validar que el usuario existe\n    if not self.user_repository.get_user_by_id(user_id):\n        raise DomainException(\n            message=\"El usuario especificado no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if current_user.id == user_id:\n        raise DomainException(\n            message=\"El usuario es el administrador de la finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # validar que el usuario pertenezca a la finca\n    if not self.farm_service.user_is_farm_worker(user_id, farm_id):\n        raise DomainException(\n            message=\"El usuario no es trabajador en la finca especificada.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # listar las tareas del usuario filtradas por la finca\n    total_tasks, tasks = self.cultural_practice_repository.list_tasks_by_user_and_farm_paginated(user_id, farm_id, page, per_page)\n\n    task_responses = [map_task_to_response(task) for task in tasks]\n\n    total_pages = ceil(total_tasks / per_page)\n\n    return PaginatedTaskListResponse(\n        tasks=task_responses,\n        total_tasks=total_tasks,\n        page=page,\n        per_page=per_page,\n        total_pages=total_pages\n    )\n</code></pre>"},{"location":"cultural_practices/use_cases/#listar-estados-de-tareas","title":"Listar Estados de Tareas","text":"<p>Caso de uso para listar los estados de las tareas de labor cultural.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todos los estados de las tareas, asegurando que se cumplan las validaciones necesarias antes de devolver la lista de estados.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> Source code in <code>app\\cultural_practices\\application\\list_task_states_use_case.py</code> <pre><code>class ListTaskStatesUseCase:\n    \"\"\"Caso de uso para listar los estados de las tareas de labor cultural.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todos los estados de las tareas,\n    asegurando que se cumplan las validaciones necesarias antes de devolver la lista de estados.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.cultural_practice_repository = CulturalPracticesRepository(db)\n\n    def list_task_states(self, current_user: UserInDB) -&gt; TaskStateListResponse:\n        \"\"\"Lista todos los estados de las tareas de labor cultural.\n\n        Este m\u00e9todo obtiene todos los estados de las tareas desde el repositorio y los mapea a\n        objetos de respuesta. Si ocurre un error durante la obtenci\u00f3n, se lanza una excepci\u00f3n.\n\n        Args:\n            current_user (UserInDB): Usuario actual autenticado que intenta acceder a los estados.\n\n        Returns:\n            TaskStateListResponse: Respuesta que contiene la lista de estados de las tareas.\n\n        Raises:\n            DomainException: Si ocurre un error al obtener los estados de las tareas.\n        \"\"\"\n        try:\n            # Asumiendo que el m\u00e9todo del repositorio devuelve una lista de objetos de estado de tarea\n            task_states = self.cultural_practice_repository.get_states()\n\n            # Crear objetos TaskStateResponse\n            task_state_responses = [map_task_state_to_response(state) for state in task_states]\n\n            # Retornar un objeto TaskStateListResponse\n            return TaskStateListResponse(states=task_state_responses)\n        except Exception as e:\n            raise DomainException(f\"Error obteniendo los estados de las tareas: {str(e)}\")\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.list_task_states_use_case.ListTaskStatesUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\cultural_practices\\application\\list_task_states_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.cultural_practice_repository = CulturalPracticesRepository(db)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.list_task_states_use_case.ListTaskStatesUseCase.list_task_states","title":"<code>list_task_states(current_user)</code>","text":"<p>Lista todos los estados de las tareas de labor cultural.</p> <p>Este m\u00e9todo obtiene todos los estados de las tareas desde el repositorio y los mapea a objetos de respuesta. Si ocurre un error durante la obtenci\u00f3n, se lanza una excepci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado que intenta acceder a los estados.</p> required <p>Returns:</p> Name Type Description <code>TaskStateListResponse</code> <code>TaskStateListResponse</code> <p>Respuesta que contiene la lista de estados de las tareas.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre un error al obtener los estados de las tareas.</p> Source code in <code>app\\cultural_practices\\application\\list_task_states_use_case.py</code> <pre><code>def list_task_states(self, current_user: UserInDB) -&gt; TaskStateListResponse:\n    \"\"\"Lista todos los estados de las tareas de labor cultural.\n\n    Este m\u00e9todo obtiene todos los estados de las tareas desde el repositorio y los mapea a\n    objetos de respuesta. Si ocurre un error durante la obtenci\u00f3n, se lanza una excepci\u00f3n.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado que intenta acceder a los estados.\n\n    Returns:\n        TaskStateListResponse: Respuesta que contiene la lista de estados de las tareas.\n\n    Raises:\n        DomainException: Si ocurre un error al obtener los estados de las tareas.\n    \"\"\"\n    try:\n        # Asumiendo que el m\u00e9todo del repositorio devuelve una lista de objetos de estado de tarea\n        task_states = self.cultural_practice_repository.get_states()\n\n        # Crear objetos TaskStateResponse\n        task_state_responses = [map_task_state_to_response(state) for state in task_states]\n\n        # Retornar un objeto TaskStateListResponse\n        return TaskStateListResponse(states=task_state_responses)\n    except Exception as e:\n        raise DomainException(f\"Error obteniendo los estados de las tareas: {str(e)}\")\n</code></pre>"},{"location":"cultural_practices/use_cases/#listar-tipos-de-tareas","title":"Listar Tipos de Tareas","text":"<p>Caso de uso para listar los tipos de tareas de labor cultural.</p> <p>Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todos los tipos de tareas, asegurando que se cumplan las validaciones necesarias antes de devolver la lista de tipos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>cultural_practice_repository</code> <code>CulturalPracticesRepository</code> <p>Repositorio para operaciones de pr\u00e1cticas culturales.</p> Source code in <code>app\\cultural_practices\\application\\list_task_types_use_case.py</code> <pre><code>class ListTaskTypesUseCase:\n    \"\"\"Caso de uso para listar los tipos de tareas de labor cultural.\n\n    Este caso de uso gestiona la l\u00f3gica de negocio para recuperar todos los tipos de tareas,\n    asegurando que se cumplan las validaciones necesarias antes de devolver la lista de tipos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        cultural_practice_repository (CulturalPracticesRepository): Repositorio para operaciones de pr\u00e1cticas culturales.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.cultural_practice_repository = CulturalPracticesRepository(db)\n\n    def list_task_types(self, current_user: UserInDB) -&gt; TaskTypeListResponse:\n        \"\"\"Lista todos los tipos de tareas de labor cultural.\n\n        Este m\u00e9todo obtiene todos los tipos de tareas desde el repositorio y los mapea a\n        objetos de respuesta.\n\n        Args:\n            current_user (UserInDB): Usuario actual autenticado que intenta acceder a los tipos de tareas.\n\n        Returns:\n            TaskTypeListResponse: Respuesta que contiene la lista de tipos de tareas.\n        \"\"\"\n        task_types = self.cultural_practice_repository.get_task_types()\n        task_type_responses = [map_task_type_to_response(type) for type in task_types]\n        return TaskTypeListResponse(task_types=task_type_responses)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.list_task_types_use_case.ListTaskTypesUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\cultural_practices\\application\\list_task_types_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.cultural_practice_repository = CulturalPracticesRepository(db)\n</code></pre>"},{"location":"cultural_practices/use_cases/#app.cultural_practices.application.list_task_types_use_case.ListTaskTypesUseCase.list_task_types","title":"<code>list_task_types(current_user)</code>","text":"<p>Lista todos los tipos de tareas de labor cultural.</p> <p>Este m\u00e9todo obtiene todos los tipos de tareas desde el repositorio y los mapea a objetos de respuesta.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado que intenta acceder a los tipos de tareas.</p> required <p>Returns:</p> Name Type Description <code>TaskTypeListResponse</code> <code>TaskTypeListResponse</code> <p>Respuesta que contiene la lista de tipos de tareas.</p> Source code in <code>app\\cultural_practices\\application\\list_task_types_use_case.py</code> <pre><code>def list_task_types(self, current_user: UserInDB) -&gt; TaskTypeListResponse:\n    \"\"\"Lista todos los tipos de tareas de labor cultural.\n\n    Este m\u00e9todo obtiene todos los tipos de tareas desde el repositorio y los mapea a\n    objetos de respuesta.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado que intenta acceder a los tipos de tareas.\n\n    Returns:\n        TaskTypeListResponse: Respuesta que contiene la lista de tipos de tareas.\n    \"\"\"\n    task_types = self.cultural_practice_repository.get_task_types()\n    task_type_responses = [map_task_type_to_response(type) for type in task_types]\n    return TaskTypeListResponse(task_types=task_type_responses)\n</code></pre>"},{"location":"development/coding_standards/","title":"Est\u00e1ndares de Codificaci\u00f3n para AgroInsight","text":"<p>Este documento describe los est\u00e1ndares de codificaci\u00f3n y las mejores pr\u00e1cticas para el proyecto AgroInsight.  Adherirse a estos est\u00e1ndares garantiza la consistencia, legibilidad y mantenibilidad en toda la base de c\u00f3digo.</p>"},{"location":"development/coding_standards/#1-convenciones-de-nombres","title":"1. Convenciones de Nombres","text":""},{"location":"development/coding_standards/#11-variables-y-funciones","title":"1.1 Variables y Funciones","text":"<ul> <li>Usar <code>snake_case</code> para nombres de variables y funciones.</li> <li>Los nombres deben ser descriptivos e indicar el prop\u00f3sito o contenido.</li> </ul> <p>Ejemplos:</p> <pre><code>user_name = \"John Doe\"\ndef calculate_total_cost(items):\n    # Implementaci\u00f3n de la funci\u00f3n\n</code></pre>"},{"location":"development/coding_standards/#12-clases","title":"1.2 Clases","text":"<ul> <li>Usar <code>PascalCase</code> para nombres de clases.</li> <li>Los nombres de las clases deben ser sustantivos y representar el objeto o concepto.</li> </ul> <p>Ejemplo:</p> <pre><code>class UserProfile:\n    # Implementaci\u00f3n de la clase\n</code></pre>"},{"location":"development/coding_standards/#13-modulos-y-paquetes","title":"1.3 M\u00f3dulos y Paquetes","text":"<ul> <li>Usar <code>snake_case</code> para nombres de m\u00f3dulos y paquetes.</li> <li>Mantener los nombres de los m\u00f3dulos cortos y descriptivos.</li> </ul> <p>Ejemplo:</p> <pre><code>import user_authentication\nfrom data_processing import clean_data\n</code></pre>"},{"location":"development/coding_standards/#14-constantes","title":"1.4 Constantes","text":"<ul> <li>Usar <code>MAY\u00daSCULAS</code> con guiones bajos para las constantes.</li> </ul> <p>Ejemplo:</p> <pre><code>MAX_LOGIN_ATTEMPTS = 3\nDEFAULT_TIMEOUT = 30\n</code></pre>"},{"location":"development/coding_standards/#2-diseno-del-codigo","title":"2. Dise\u00f1o del C\u00f3digo","text":""},{"location":"development/coding_standards/#21-indentacion","title":"2.1 Indentaci\u00f3n","text":"<ul> <li>Usar 4 espacios para la indentaci\u00f3n.</li> <li>No usar tabulaciones.</li> </ul>"},{"location":"development/coding_standards/#22-longitud-maxima-de-linea","title":"2.2 Longitud M\u00e1xima de L\u00ednea","text":"<ul> <li>Limitar todas las l\u00edneas a un m\u00e1ximo de 79 caracteres.</li> <li>Para bloques de texto largos (docstrings o comentarios), limitar la longitud a 72 caracteres.</li> </ul>"},{"location":"development/coding_standards/#23-lineas-en-blanco","title":"2.3 L\u00edneas en Blanco","text":"<ul> <li>Rodear las funciones y clases de nivel superior con dos l\u00edneas en blanco.</li> <li>Usar una l\u00ednea en blanco para separar los m\u00e9todos dentro de una clase.</li> <li>Usar l\u00edneas en blanco con moderaci\u00f3n dentro de las funciones para indicar secciones l\u00f3gicas.</li> </ul>"},{"location":"development/coding_standards/#3-importaciones","title":"3. Importaciones","text":"<ul> <li>Las importaciones deben estar en l\u00edneas separadas.</li> <li>Agrupar las importaciones en el siguiente orden:</li> <li>Importaciones de la biblioteca est\u00e1ndar</li> <li>Importaciones de terceros relacionadas</li> <li>Importaciones espec\u00edficas de la aplicaci\u00f3n/biblioteca local</li> <li>Usar importaciones absolutas cuando sea posible.</li> </ul> <p>Ejemplo:</p> <pre><code>import os\nimport sys\n\nfrom fastapi import FastAPI\nfrom sqlalchemy import Column, Integer\n\nfrom app.models import User\nfrom app.utils import generate_token\n</code></pre>"},{"location":"development/coding_standards/#4-formato-de-cadenas","title":"4. Formato de Cadenas","text":"<ul> <li>Usar f-strings para el formato de cadenas cuando sea posible.</li> <li>Para versiones anteriores de Python, usar el m\u00e9todo <code>.format()</code>.</li> </ul> <p>Ejemplo:</p> <pre><code>name = \"Alice\"\nage = 30\nprint(f\"Name: {name}, Age: {age}\")\n</code></pre>"},{"location":"development/coding_standards/#5-comentarios-y-documentacion","title":"5. Comentarios y Documentaci\u00f3n","text":""},{"location":"development/coding_standards/#51-comentarios-en-linea","title":"5.1 Comentarios en L\u00ednea","text":"<ul> <li>Usar comentarios en l\u00ednea con moderaci\u00f3n.</li> <li>Escribir comentarios que expliquen el porqu\u00e9, no el qu\u00e9.</li> </ul>"},{"location":"development/coding_standards/#52-docstrings-de-funciones-y-metodos","title":"5.2 Docstrings de Funciones y M\u00e9todos","text":"<ul> <li>Usar docstrings de estilo Google para funciones y m\u00e9todos.</li> <li>Incluir una breve descripci\u00f3n, par\u00e1metros, valores de retorno y excepciones generadas.</li> </ul> <p>Ejemplo:</p> <pre><code>def calculate_area(length: float, width: float) -&gt; float:\n    \"\"\"\n    Calcula el \u00e1rea de un rect\u00e1ngulo.\n\n    Parameters:\n        length (float): La longitud del rect\u00e1ngulo.\n        width (float): El ancho del rect\u00e1ngulo.\n\n    Returns:\n        float: El \u00e1rea calculada.\n\n    Raises:\n        ValueError: Si la longitud o el ancho son negativos.\n    \"\"\"\n    if length &lt; 0 or width &lt; 0:\n        raise ValueError(\"La longitud y el ancho deben ser no negativos.\")\n    return length * width\n</code></pre>"},{"location":"development/coding_standards/#53-docstrings-de-clases","title":"5.3 Docstrings de Clases","text":"<ul> <li>Incluir un docstring para cada clase que describa su prop\u00f3sito y comportamiento.</li> </ul> <p>Ejemplo:</p> <pre><code>class UserManager:\n    \"\"\"\n    Gestiona las operaciones relacionadas con el usuario, como la creaci\u00f3n, la autenticaci\u00f3n y las actualizaciones de perfil.\n\n    Esta clase interact\u00faa con el modelo de Usuario y proporciona una interfaz para la gesti\u00f3n de usuarios\n    en toda la aplicaci\u00f3n.\n    \"\"\"\n\n    def __init__(self, db_session):\n        \"\"\"\n        Inicializa el UserManager.\n\n        Parameters:\n            db_session: La sesi\u00f3n de la base de datos a utilizar para las operaciones.\n        \"\"\"\n        self.db_session = db_session\n</code></pre>"},{"location":"development/coding_standards/#6-indicacion-de-tipos-type-hinting","title":"6.  Indicaci\u00f3n de Tipos (Type Hinting)","text":"<ul> <li>Usar indicaciones de tipos para los argumentos de las funciones y los valores de retorno.</li> <li>Importar tipos del m\u00f3dulo <code>typing</code> cuando sea necesario.</li> </ul> <p>Ejemplo:</p> <pre><code>from typing import List, Dict\n\ndef process_user_data(users: List[Dict[str, Any]]) -&gt; List[User]:\n    # Implementaci\u00f3n de la funci\u00f3n\n</code></pre>"},{"location":"development/coding_standards/#7-manejo-de-errores","title":"7. Manejo de Errores","text":"<ul> <li>Usar tipos de excepci\u00f3n espec\u00edficos al generar o capturar excepciones.</li> <li>Proporcionar mensajes de error informativos.</li> </ul> <p>Ejemplo:</p> <pre><code>def divide(a: float, b: float) -&gt; float:\n    if b == 0:\n        raise ValueError(\"No se puede dividir por cero.\")\n    return a / b\n</code></pre>"},{"location":"development/coding_standards/#8-pruebas","title":"8. Pruebas","text":"<ul> <li>Escribir pruebas unitarias para todas las funciones y m\u00e9todos.</li> <li>Usar nombres descriptivos para las funciones de prueba, comenzando con <code>test_</code>.</li> <li>Apuntar a al menos un 80% de cobertura de c\u00f3digo.</li> </ul> <p>Ejemplo:</p> <pre><code>def test_calculate_area_positive_values():\n    assert calculate_area(5, 10) == 50\n\ndef test_calculate_area_raises_value_error():\n    with pytest.raises(ValueError):\n        calculate_area(-1, 5)\n</code></pre>"},{"location":"development/coding_standards/#9-control-de-versiones","title":"9. Control de Versiones","text":"<ul> <li>Escribir mensajes de confirmaci\u00f3n claros y concisos.</li> <li>Usar el tiempo presente en los mensajes de confirmaci\u00f3n (por ejemplo, \"Agregar funci\u00f3n\" no \"Funci\u00f3n agregada\").</li> <li>Hacer referencia a los n\u00fameros de problema en los mensajes de confirmaci\u00f3n cuando corresponda.</li> <li>Utilizar Semantic Versioning (SemVer) para el control de versiones del producto.</li> </ul>"},{"location":"development/coding_standards/#91-semantic-versioning-semver","title":"9.1 Semantic Versioning (SemVer)","text":"<p>El proyecto AgroInsight sigue las reglas de Semantic Versioning para el control de versiones. El formato de versi\u00f3n de SemVer consta de tres partes:</p> <ul> <li>MAJOR: Se incrementa cuando se realizan cambios incompatibles con versiones anteriores de la API.</li> <li>MINOR: Se incrementa cuando se a\u00f1aden funcionalidades de manera compatible con versiones anteriores.</li> <li>PATCH: Se incrementa cuando se realizan correcciones de errores compatibles con versiones anteriores.</li> </ul> <p>Ejemplo: 1.2.3 (MAJOR.MINOR.PATCH)</p>"},{"location":"development/coding_standards/#92-relacion-entre-commits-y-versiones","title":"9.2 Relaci\u00f3n entre Commits y Versiones","text":"<ul> <li>Commits de tipo feat generalmente incrementan la versi\u00f3n MINOR.</li> <li>Commits de tipo fix generalmente incrementan la versi\u00f3n PATCH.</li> <li>Commits con \"BREAKING CHANGE\" en las notas al pie incrementan la versi\u00f3n MAJOR.</li> </ul>"},{"location":"development/coding_standards/#93-convencion-de-commits","title":"9.3 Convenci\u00f3n de Commits","text":"<p>Se adopta la convenci\u00f3n de formato de commits de Conventional Commits para estandarizar el registro de cambios y facilitar la comprensi\u00f3n del historial de desarrollo. Los mensajes de commit deben seguir esta estructura:</p> <pre><code>&lt;tipo&gt;[\u00e1mbito opcional]: &lt;descripci\u00f3n&gt;\n\n[cuerpo opcional]\n\n[nota(s) al pie opcional(es)]\n</code></pre> <p>Donde <code>&lt;tipo&gt;</code> puede ser:</p> <ul> <li>feat: cuando se a\u00f1ade una nueva funcionalidad.</li> <li>fix: cuando se arregla un error.</li> <li>docs: cuando se realizan cambios en la documentaci\u00f3n.</li> <li>refactor: cuando se realiza una refactorizaci\u00f3n del c\u00f3digo sin cambiar su funcionalidad.</li> <li>test: cuando se a\u00f1aden o modifican pruebas.</li> <li>chore: cuando se realizan cambios de mantenimiento o tareas no relacionadas con el c\u00f3digo en s\u00ed.</li> </ul> <p>Esta estructura de versionado y convenci\u00f3n de commits ayuda a mantener un historial de cambios claro y a gestionar las actualizaciones del software de manera m\u00e1s efectiva.</p>"},{"location":"development/coding_standards/#10-organizacion-del-codigo","title":"10. Organizaci\u00f3n del C\u00f3digo","text":"<ul> <li>Seguir la estructura modular del proyecto:</li> <li><code>app/</code>: Paquete principal de la aplicaci\u00f3n<ul> <li><code>[nombre_del_m\u00f3dulo]/</code>: M\u00f3dulo espec\u00edfico (por ejemplo, <code>user</code>, <code>farm</code>, <code>plot</code>)</li> <li><code>application/</code>: Casos de uso y l\u00f3gica de negocio</li> <li><code>domain/</code>: Modelos de dominio y reglas de negocio</li> <li><code>infrastructure/</code>: Modelos de base de datos, repositorios y rutas API</li> </ul> </li> </ul>"},{"location":"development/coding_standards/#11-directrices-especificas-de-fastapi","title":"11. Directrices Espec\u00edficas de FastAPI","text":"<ul> <li>Usar modelos Pydantic para esquemas de solicitud y respuesta.</li> <li>Implementar la inyecci\u00f3n de dependencias para sesiones de base de datos y otros recursos compartidos.</li> <li>Usar funciones as\u00edncronas para operaciones de base de datos y llamadas a API externas.</li> </ul> <p>Ejemplo:</p> <pre><code>from fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\nfrom app.infrastructure.database import get_db\nfrom app.user.domain.schemas import UserCreate, UserResponse\n\nrouter = APIRouter()\n\n@router.post(\"/users/\", response_model=UserResponse)\nasync def create_user(user: UserCreate, db: Session = Depends(get_db)):\n    # Implementaci\u00f3n\n</code></pre>"},{"location":"development/coding_standards/#12-operaciones-de-base-de-datos","title":"12. Operaciones de Base de Datos","text":"<ul> <li>Usar SQLAlchemy ORM para las operaciones de base de datos.</li> <li>Definir los modelos de base de datos en <code>infrastructure/orm_models.py</code>.</li> <li>Implementar el patr\u00f3n de repositorio para las interacciones con la base de datos.</li> </ul> <p>Ejemplo:</p> <pre><code>from sqlalchemy.orm import Session\nfrom app.user.infrastructure.orm_models import User\n\nclass UserRepository:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def create_user(self, user_data: dict) -&gt; User:\n        user = User(**user_data)\n        self.db.add(user)\n        self.db.commit()\n        self.db.refresh(user)\n        return user\n</code></pre>"},{"location":"development/coding_standards/#13-inyeccion-de-dependencias","title":"13. Inyecci\u00f3n de Dependencias","text":"<ul> <li>Usar el sistema de inyecci\u00f3n de dependencias de FastAPI para recursos compartidos.</li> <li>Crear dependencias reutilizables para operaciones comunes.</li> </ul> <p>Ejemplo:</p> <pre><code>from fastapi import Depends\nfrom app.infrastructure.security import get_current_user\nfrom app.user.domain.schemas import UserInDB\n\nasync def get_current_active_user(\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; UserInDB:\n    if not current_user.is_active:\n        raise HTTPException(status_code=400, detail=\"Usuario inactivo\")\n    return current_user\n</code></pre>"},{"location":"development/coding_standards/#14-gestion-de-la-configuracion","title":"14. Gesti\u00f3n de la Configuraci\u00f3n","text":"<ul> <li>Usar variables de entorno para la configuraci\u00f3n.</li> <li>Cargar la configuraci\u00f3n usando BaseSettings de Pydantic.</li> </ul> <p>Ejemplo:</p> <pre><code>from pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    database_url: str\n    secret_key: str\n    api_prefix: str = \"/api/v1\"\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n</code></pre>"},{"location":"development/coding_standards/#15-registro-logging","title":"15. Registro (Logging)","text":"<ul> <li>Usar el m\u00f3dulo de registro integrado de Python.</li> <li>Configurar los niveles de registro adecuadamente para diferentes entornos.</li> </ul> <p>Ejemplo:</p> <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ndef some_function():\n    logger.info(\"Procesamiento iniciado\")\n    try:\n        # Alguna operaci\u00f3n\n        logger.debug(\"Detalles de la operaci\u00f3n\")\n    except Exception as e:\n        logger.error(f\"Ocurri\u00f3 un error: {str(e)}\")\n</code></pre> <p>Siguiendo estos est\u00e1ndares de codificaci\u00f3n, aseguramos una base de c\u00f3digo consistente y mantenible para el proyecto AgroInsight.  Se deben utilizar revisiones de c\u00f3digo regulares y herramientas de linting automatizadas para aplicar estos est\u00e1ndares en todo el equipo de desarrollo.</p>"},{"location":"development/contributing/","title":"Contribuyendo a AgroInsight","text":"<p>\u00a1Gracias por tu inter\u00e9s en contribuir a AgroInsight! Este documento proporciona una gu\u00eda para aquellos que desean contribuir al proyecto.</p>"},{"location":"development/contributing/#configuracion-del-entorno-de-desarrollo","title":"Configuraci\u00f3n del entorno de desarrollo","text":"<ol> <li>Clona el repositorio:</li> </ol> <pre><code>git clone https://github.com/AgroInsight/agroinsight.git\ncd agroinsight\n</code></pre> <ol> <li>Instala las dependencias:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Configura el entorno virtual (recomendado):</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # En Windows: venv\\Scripts\\activate\n</code></pre>"},{"location":"development/contributing/#flujo-de-trabajo-de-contribucion","title":"Flujo de trabajo de contribuci\u00f3n","text":"<ol> <li>Crea una nueva rama para tu contribuci\u00f3n:</li> </ol> <pre><code>git checkout -b feature/nombre-de-tu-caracteristica\n</code></pre> <ol> <li> <p>Realiza tus cambios y aseg\u00farate de seguir las gu\u00edas de estilo del proyecto.</p> </li> <li> <p>Ejecuta las pruebas localmente:</p> </li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Haz commit de tus cambios:</li> </ol> <pre><code>git add .\ngit commit -m \"Descripci\u00f3n concisa de tus cambios\"\n</code></pre> <ol> <li>Sube tus cambios a tu fork:</li> </ol> <pre><code>git push origin feature/nombre-de-tu-caracteristica\n</code></pre> <ol> <li>Crea un Pull Request en GitHub.</li> </ol>"},{"location":"development/contributing/#guias-de-estilo","title":"Gu\u00edas de estilo","text":"<ul> <li>Sigue PEP 8 para el c\u00f3digo Python.</li> <li>Utiliza nombres descriptivos para variables y funciones.</li> <li>Comenta tu c\u00f3digo cuando sea necesario, especialmente para l\u00f3gica compleja.</li> <li>Escribe pruebas unitarias para nuevas funcionalidades.</li> </ul>"},{"location":"development/contributing/#reportando-problemas","title":"Reportando problemas","text":"<p>Si encuentras un bug o tienes una sugerencia de mejora:</p> <ol> <li>Verifica que el problema no haya sido reportado anteriormente.</li> <li>Abre un nuevo issue en GitHub, proporcionando la mayor cantidad de detalles posible.</li> </ol>"},{"location":"development/contributing/#proceso-de-revision-de-codigo","title":"Proceso de revisi\u00f3n de c\u00f3digo","text":"<ul> <li>Todos los Pull Requests ser\u00e1n revisados por al menos un miembro del equipo principal.</li> <li>Se pueden solicitar cambios o aclaraciones antes de la aprobaci\u00f3n.</li> <li>Una vez aprobado, un mantenedor fusionar\u00e1 tu PR.</li> </ul>"},{"location":"development/contributing/#documentacion","title":"Documentaci\u00f3n","text":"<ul> <li>Actualiza la documentaci\u00f3n relevante cuando realices cambios.</li> <li>Utiliza MkDocs para la documentaci\u00f3n del proyecto.</li> <li>Aseg\u00farate de que tus cambios est\u00e9n reflejados en la documentaci\u00f3n.</li> </ul>"},{"location":"development/contributing/#licencia","title":"Licencia","text":"<p>Al contribuir a AgroInsight, aceptas que tus contribuciones se licenciar\u00e1n bajo la misma licencia que el proyecto.</p> <p>\u00a1Gracias por contribuir a AgroInsight y ayudar a mejorar la agricultura con tecnolog\u00eda!</p>"},{"location":"farm/endpoints/","title":"Endpoints de Finca","text":"<p>Este documento describe los endpoints disponibles para la gesti\u00f3n de fincas en el sistema AgroInsight.</p>"},{"location":"farm/endpoints/#gestion-de-fincas","title":"Gesti\u00f3n de Fincas","text":""},{"location":"farm/endpoints/#crear-finca","title":"Crear Finca","text":"<p>Crea una nueva finca en el sistema para un usuario espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>farm</code> <code>FarmCreate</code> <p>Datos de la finca a crear.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Un objeto SuccessResponse indicando que la finca fue creada exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la creaci\u00f3n de la finca.</p> Source code in <code>app\\farm\\infrastructure\\api.py</code> <pre><code>@router.post(\"/create\", response_model=SuccessResponse, status_code=status.HTTP_201_CREATED)\ndef create_farm(\n    farm: FarmCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Crea una nueva finca en el sistema para un usuario espec\u00edfico.\n\n    Parameters:\n        farm (FarmCreate): Datos de la finca a crear.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Un objeto SuccessResponse indicando que la finca fue creada exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la creaci\u00f3n de la finca.\n    \"\"\"\n    crear_farm_use_case = CreateFarmUseCase(db)\n    try:\n        return crear_farm_use_case.create_farm(farm, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al crear la finca: {str(e)}\"\n        )\n</code></pre>"},{"location":"farm/endpoints/#listar-fincas","title":"Listar Fincas","text":"<p>Lista todas las fincas en el sistema para un usuario espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina.</p> <code>Query(1, ge=1, description='Page number')</code> <code>per_page</code> <code>int</code> <p>Elementos por p\u00e1gina.</p> <code>Query(10, ge=1, le=100, description='Items per page')</code> <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>PaginatedFarmListResponse</code> <code>PaginatedFarmListResponse</code> <p>Una lista paginada de fincas.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de la lista de fincas.</p> Source code in <code>app\\farm\\infrastructure\\api.py</code> <pre><code>@router.get(\"/list\", response_model=PaginatedFarmListResponse, status_code=status.HTTP_200_OK)\ndef list_farms(\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    per_page: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; PaginatedFarmListResponse:\n    \"\"\"\n    Lista todas las fincas en el sistema para un usuario espec\u00edfico.\n\n    Parameters:\n        page (int): N\u00famero de p\u00e1gina.\n        per_page (int): Elementos por p\u00e1gina.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        PaginatedFarmListResponse: Una lista paginada de fincas.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de la lista de fincas.\n    \"\"\"\n    list_farms_use_case = ListFarmsUseCase(db)\n    try:\n        return list_farms_use_case.list_farms(current_user, page, per_page)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar las fincas: {str(e)}\"\n        )\n</code></pre>"},{"location":"farm/endpoints/#asignar-usuarios-por-email","title":"Asignar Usuarios por Email","text":"Source code in <code>app\\farm\\infrastructure\\api.py</code> <pre><code>@router.post(\"/assign-users-by-email\", \n             response_model=MultipleResponse,\n             responses={\n                 200: {\"description\": \"Todos los usuarios asignados exitosamente\"},\n                 207: {\"description\": \"Algunos usuarios asignados, otros fallaron\"},\n                 400: {\"description\": \"No se pudo asignar ning\u00fan usuario\"}\n             }\n)\ndef assign_users_to_farm_by_email(\n    assignment_data: FarmUserAssignmentByEmail,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n):\n    assign_users_use_case = AssignUsersToFarmUseCase(db)\n    try:\n        response = assign_users_use_case.assign_users_by_emails(assignment_data, current_user)\n        return JSONResponse(content=response.model_dump(), status_code=response.status_code)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al asignar usuarios a una finca: {str(e)}\"\n        )\n</code></pre>"},{"location":"farm/endpoints/#estructura-de-rutas","title":"Estructura de Rutas","text":"<p>El m\u00f3dulo de fincas utiliza el prefijo <code>/farm</code> para todos sus endpoints y est\u00e1 etiquetado como \"farm\" en la documentaci\u00f3n de la API.</p>"},{"location":"farm/models/","title":"Modelos de Finca","text":"<p>Este documento describe los modelos utilizados para la gesti\u00f3n de fincas en el sistema AgroInsight.</p>"},{"location":"farm/models/#modelos-de-base-de-datos","title":"Modelos de Base de Datos","text":""},{"location":"farm/models/#finca-farm","title":"Finca (Farm)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo ORM que representa una finca o granja en el sistema.</p> <p>Esta clase define la estructura y relaciones de la tabla 'finca' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la finca.</p> <code>nombre</code> <code>str</code> <p>Nombre de la finca. M\u00e1ximo 100 caracteres.</p> <code>ubicacion</code> <code>str</code> <p>Ubicaci\u00f3n o direcci\u00f3n de la finca. M\u00e1ximo 255 caracteres.</p> <code>area_total</code> <code>Decimal</code> <p>\u00c1rea total de la finca con precisi\u00f3n de 2 decimales.</p> <code>unidad_area_id</code> <code>int</code> <p>Clave for\u00e1nea que referencia la unidad de medida del \u00e1rea.</p> <code>unidad_area</code> <code>UnitOfMeasure</code> <p>Relaci\u00f3n con la unidad de medida del \u00e1rea.</p> <code>lotes</code> <code>List[Plot]</code> <p>Relaci\u00f3n con los lotes o parcelas de la finca.</p> <code>usuario_roles</code> <code>List[UserFarmRole]</code> <p>Relaci\u00f3n con los roles de usuarios en la finca.</p> Source code in <code>app\\farm\\infrastructure\\orm_models.py</code> <pre><code>class Farm(Base):\n    \"\"\"Modelo ORM que representa una finca o granja en el sistema.\n\n    Esta clase define la estructura y relaciones de la tabla 'finca' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la finca.\n        nombre (str): Nombre de la finca. M\u00e1ximo 100 caracteres.\n        ubicacion (str): Ubicaci\u00f3n o direcci\u00f3n de la finca. M\u00e1ximo 255 caracteres.\n        area_total (Decimal): \u00c1rea total de la finca con precisi\u00f3n de 2 decimales.\n        unidad_area_id (int): Clave for\u00e1nea que referencia la unidad de medida del \u00e1rea.\n        unidad_area (UnitOfMeasure): Relaci\u00f3n con la unidad de medida del \u00e1rea.\n        lotes (List[Plot]): Relaci\u00f3n con los lotes o parcelas de la finca.\n        usuario_roles (List[UserFarmRole]): Relaci\u00f3n con los roles de usuarios en la finca.\n    \"\"\"\n\n    __tablename__ = \"finca\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(100), nullable=False)\n    ubicacion = Column(String(255))\n    area_total = Column(DECIMAL(10, 2), nullable=False)\n    unidad_area_id = Column(Integer, ForeignKey('unidad_medida.id'), nullable=False)\n\n    unidad_area = relationship(\"UnitOfMeasure\")\n    lotes = relationship(\"Plot\", back_populates=\"finca\")\n    usuario_roles = relationship(\"UserFarmRole\", back_populates=\"finca\")\n</code></pre>"},{"location":"farm/models/#relacion-usuario-finca-rol-userfarmrole","title":"Relaci\u00f3n Usuario-Finca-Rol (UserFarmRole)","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'usuario_finca_rol' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la relaci\u00f3n usuario-finca-rol.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario.</p> <code>finca_id</code> <code>int</code> <p>Identificador de la finca.</p> <code>rol_id</code> <code>int</code> <p>Identificador del rol.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado.</p> <code>finca</code> <code>Farm</code> <p>Finca asociada.</p> <code>rol</code> <code>Role</code> <p>Rol asociado.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class UserFarmRole(Base):\n    \"\"\"\n    Representa la tabla 'usuario_finca_rol' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la relaci\u00f3n usuario-finca-rol.\n        usuario_id (int): Identificador del usuario.\n        finca_id (int): Identificador de la finca.\n        rol_id (int): Identificador del rol.\n        usuario (User): Usuario asociado.\n        finca (Farm): Finca asociada.\n        rol (Role): Rol asociado.\n    \"\"\"\n    __tablename__ = \"usuario_finca_rol\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    usuario_id = Column(Integer, ForeignKey('usuario.id'), nullable=False)\n    finca_id = Column(Integer, ForeignKey('finca.id'), nullable=False)\n    rol_id = Column(Integer, ForeignKey('rol.id'), nullable=False)\n\n    usuario = relationship(\"User\", back_populates=\"roles_fincas\")\n    finca = relationship(\"Farm\", back_populates=\"usuario_roles\")\n    rol = relationship(\"Role\", back_populates=\"usuario_fincas\")\n</code></pre>"},{"location":"farm/models/#esquemas-de-datos","title":"Esquemas de Datos","text":""},{"location":"farm/models/#crear-finca","title":"Crear Finca","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para la creaci\u00f3n de una nueva finca.</p> <p>Attributes:</p> Name Type Description <code>nombre</code> <code>str</code> <p>Nombre de la finca. Debe tener entre 2 y 100 caracteres.</p> <code>ubicacion</code> <code>str</code> <p>Ubicaci\u00f3n de la finca. Debe tener entre 2 y 255 caracteres.</p> <code>area_total</code> <code>Decimal</code> <p>\u00c1rea total de la finca. Debe ser mayor que 0.</p> <code>unidad_area_id</code> <code>int</code> <p>ID de la unidad de medida del \u00e1rea.</p> Source code in <code>app\\farm\\domain\\schemas.py</code> <pre><code>class FarmCreate(BaseModel):\n    \"\"\"Schema para la creaci\u00f3n de una nueva finca.\n\n    Attributes:\n        nombre (str): Nombre de la finca. Debe tener entre 2 y 100 caracteres.\n        ubicacion (str): Ubicaci\u00f3n de la finca. Debe tener entre 2 y 255 caracteres.\n        area_total (Decimal): \u00c1rea total de la finca. Debe ser mayor que 0.\n        unidad_area_id (int): ID de la unidad de medida del \u00e1rea.\n    \"\"\"\n    nombre: str = Field(..., min_length=2, max_length=100)\n    ubicacion: str = Field(..., min_length=2, max_length=255)\n    area_total: Decimal = Field(..., gt=0)\n    unidad_area_id: int\n\n    @field_validator('nombre')\n    def validate_no_emojis_nombre(cls, v) -&gt; str:\n        \"\"\"Valida que el nombre no contenga emojis.\n\n        Args:\n            v (str): Valor del nombre a validar.\n\n        Returns:\n            str: El valor validado.\n\n        Raises:\n            ValueError: Si el nombre contiene emojis.\n        \"\"\"\n        return validate_no_emojis(v)\n\n    @field_validator('nombre')\n    def validate_no_special_chars_nombre(cls, v):\n        return validate_no_special_chars(v)\n\n    @field_validator('nombre')\n    def validate_no_xss_nombre(cls, v):\n        return validate_no_xss(v)\n\n    @field_validator('ubicacion')\n    def validate_no_emojis_ubicacion(cls, v):\n        return validate_no_emojis(v)\n\n    @field_validator('ubicacion')\n    def validate_no_special_chars_ubicacion(cls, v):\n        return validate_no_special_chars(v)\n\n    @field_validator('ubicacion')\n    def validate_no_xss_ubicacion(cls, v):\n        return validate_no_xss(v)\n</code></pre>"},{"location":"farm/models/#app.farm.domain.schemas.FarmCreate.validate_no_emojis_nombre","title":"<code>validate_no_emojis_nombre(v)</code>","text":"<p>Valida que el nombre no contenga emojis.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>Valor del nombre a validar.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>El valor validado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Si el nombre contiene emojis.</p> Source code in <code>app\\farm\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_no_emojis_nombre(cls, v) -&gt; str:\n    \"\"\"Valida que el nombre no contenga emojis.\n\n    Args:\n        v (str): Valor del nombre a validar.\n\n    Returns:\n        str: El valor validado.\n\n    Raises:\n        ValueError: Si el nombre contiene emojis.\n    \"\"\"\n    return validate_no_emojis(v)\n</code></pre>"},{"location":"farm/models/#respuesta-de-finca","title":"Respuesta de Finca","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para la respuesta con informaci\u00f3n de una finca.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la finca.</p> <code>nombre</code> <code>str</code> <p>Nombre de la finca.</p> <code>ubicacion</code> <code>str</code> <p>Ubicaci\u00f3n de la finca.</p> <code>area_total</code> <code>float</code> <p>\u00c1rea total de la finca.</p> <code>unidad_area</code> <code>str</code> <p>Unidad de medida del \u00e1rea.</p> <code>usuarios</code> <code>List[UserForFarmResponse]</code> <p>Lista de usuarios asociados a la finca.</p> Source code in <code>app\\farm\\domain\\schemas.py</code> <pre><code>class FarmResponse(BaseModel):\n    \"\"\"Schema para la respuesta con informaci\u00f3n de una finca.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la finca.\n        nombre (str): Nombre de la finca.\n        ubicacion (str): Ubicaci\u00f3n de la finca.\n        area_total (float): \u00c1rea total de la finca.\n        unidad_area (str): Unidad de medida del \u00e1rea.\n        usuarios (List[UserForFarmResponse]): Lista de usuarios asociados a la finca.\n    \"\"\"\n    id: int\n    nombre: str\n    ubicacion: str\n    area_total: float\n    unidad_area: str\n    usuarios: List[UserForFarmResponse]\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"farm/models/#respuesta-paginada-de-fincas","title":"Respuesta Paginada de Fincas","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para la respuesta paginada de lista de fincas.</p> <p>Attributes:</p> Name Type Description <code>farms</code> <code>List[FarmResponse]</code> <p>Lista de fincas para la p\u00e1gina actual.</p> <code>total_farms</code> <code>int</code> <p>N\u00famero total de fincas.</p> <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina actual (m\u00ednimo 1).</p> <code>per_page</code> <code>int</code> <p>Cantidad de elementos por p\u00e1gina (entre 1 y 100).</p> <code>total_pages</code> <code>int</code> <p>N\u00famero total de p\u00e1ginas.</p> Source code in <code>app\\farm\\domain\\schemas.py</code> <pre><code>class PaginatedFarmListResponse(BaseModel):\n    \"\"\"Schema para la respuesta paginada de lista de fincas.\n\n    Attributes:\n        farms (List[FarmResponse]): Lista de fincas para la p\u00e1gina actual.\n        total_farms (int): N\u00famero total de fincas.\n        page (int): N\u00famero de p\u00e1gina actual (m\u00ednimo 1).\n        per_page (int): Cantidad de elementos por p\u00e1gina (entre 1 y 100).\n        total_pages (int): N\u00famero total de p\u00e1ginas.\n    \"\"\"\n    farms: List[FarmResponse]\n    total_farms: int\n    page: int = Field(..., ge=1)\n    per_page: int = Field(..., ge=1, le=100)\n    total_pages: int\n</code></pre>"},{"location":"farm/models/#asignacion-de-usuarios-por-email","title":"Asignaci\u00f3n de Usuarios por Email","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para asignar usuarios a una finca mediante correos electr\u00f3nicos.</p> <p>Attributes:</p> Name Type Description <code>farm_id</code> <code>int</code> <p>ID de la finca a la que se asignar\u00e1n los usuarios.</p> <code>user_emails</code> <code>List[str]</code> <p>Lista de correos electr\u00f3nicos de los usuarios.</p> Source code in <code>app\\farm\\domain\\schemas.py</code> <pre><code>class FarmUserAssignmentByEmail(BaseModel):\n    \"\"\"Schema para asignar usuarios a una finca mediante correos electr\u00f3nicos.\n\n    Attributes:\n        farm_id (int): ID de la finca a la que se asignar\u00e1n los usuarios.\n        user_emails (List[str]): Lista de correos electr\u00f3nicos de los usuarios.\n    \"\"\"\n    farm_id: int\n    user_emails: List[str]\n\n    @field_validator('user_emails')\n    def validate_emails(cls, emails) -&gt; List[str]:\n        \"\"\"Valida el formato de todos los correos electr\u00f3nicos en la lista.\n\n        Args:\n            emails (List[str]): Lista de correos electr\u00f3nicos a validar.\n\n        Returns:\n            List[str]: Lista de correos electr\u00f3nicos validados.\n\n        Raises:\n            ValueError: Si alg\u00fan correo electr\u00f3nico tiene un formato inv\u00e1lido.\n        \"\"\"\n        validation_errors = []\n        for email in emails:\n            try:\n                validate_email_format(email)\n            except ValueError as e:\n                validation_errors.append(f\"Email '{email}': {str(e)}\")\n\n        if validation_errors:\n            raise ValueError(validation_errors)\n        return emails\n</code></pre>"},{"location":"farm/models/#app.farm.domain.schemas.FarmUserAssignmentByEmail.validate_emails","title":"<code>validate_emails(emails)</code>","text":"<p>Valida el formato de todos los correos electr\u00f3nicos en la lista.</p> <p>Parameters:</p> Name Type Description Default <code>emails</code> <code>List[str]</code> <p>Lista de correos electr\u00f3nicos a validar.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Lista de correos electr\u00f3nicos validados.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Si alg\u00fan correo electr\u00f3nico tiene un formato inv\u00e1lido.</p> Source code in <code>app\\farm\\domain\\schemas.py</code> <pre><code>@field_validator('user_emails')\ndef validate_emails(cls, emails) -&gt; List[str]:\n    \"\"\"Valida el formato de todos los correos electr\u00f3nicos en la lista.\n\n    Args:\n        emails (List[str]): Lista de correos electr\u00f3nicos a validar.\n\n    Returns:\n        List[str]: Lista de correos electr\u00f3nicos validados.\n\n    Raises:\n        ValueError: Si alg\u00fan correo electr\u00f3nico tiene un formato inv\u00e1lido.\n    \"\"\"\n    validation_errors = []\n    for email in emails:\n        try:\n            validate_email_format(email)\n        except ValueError as e:\n            validation_errors.append(f\"Email '{email}': {str(e)}\")\n\n    if validation_errors:\n        raise ValueError(validation_errors)\n    return emails\n</code></pre>"},{"location":"farm/models/#respuesta-paginada-de-usuarios-de-finca","title":"Respuesta Paginada de Usuarios de Finca","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para la respuesta paginada de lista de usuarios de una finca.</p> <p>Attributes:</p> Name Type Description <code>users</code> <code>List[UserForFarmResponse]</code> <p>Lista de usuarios para la p\u00e1gina actual.</p> <code>total_users</code> <code>int</code> <p>N\u00famero total de usuarios.</p> <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina actual (m\u00ednimo 1).</p> <code>per_page</code> <code>int</code> <p>Cantidad de elementos por p\u00e1gina (entre 1 y 100).</p> <code>total_pages</code> <code>int</code> <p>N\u00famero total de p\u00e1ginas.</p> Source code in <code>app\\farm\\domain\\schemas.py</code> <pre><code>class PaginatedFarmUserListResponse(BaseModel):\n    \"\"\"Schema para la respuesta paginada de lista de usuarios de una finca.\n\n    Attributes:\n        users (List[UserForFarmResponse]): Lista de usuarios para la p\u00e1gina actual.\n        total_users (int): N\u00famero total de usuarios.\n        page (int): N\u00famero de p\u00e1gina actual (m\u00ednimo 1).\n        per_page (int): Cantidad de elementos por p\u00e1gina (entre 1 y 100).\n        total_pages (int): N\u00famero total de p\u00e1ginas.\n    \"\"\"\n    users: List[UserForFarmResponse]\n    total_users: int\n    page: int = Field(..., ge=1)\n    per_page: int = Field(..., ge=1, le=100)\n    total_pages: int\n</code></pre>"},{"location":"farm/overview/","title":"Visi\u00f3n General del M\u00f3dulo de Finca","text":""},{"location":"farm/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>El m\u00f3dulo de Finca (Farm) es una parte fundamental del sistema AgroInsight que gestiona todo lo relacionado con las fincas o granjas agr\u00edcolas. Este m\u00f3dulo permite a los usuarios crear y administrar fincas, asignar roles a otros usuarios y gestionar la informaci\u00f3n b\u00e1sica de cada propiedad.</p>"},{"location":"farm/overview/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Creaci\u00f3n y gesti\u00f3n de fincas</li> <li>Asignaci\u00f3n de roles (administrador y trabajador)</li> <li>Gesti\u00f3n de usuarios por finca</li> <li>Control de acceso basado en roles</li> <li>Integraci\u00f3n con otros m\u00f3dulos (lotes, cultivos, pr\u00e1cticas culturales)</li> </ul>"},{"location":"farm/overview/#roles-del-sistema","title":"Roles del Sistema","text":"<p>El m\u00f3dulo maneja dos roles principales:</p> <ol> <li>Administrador de Finca: Puede crear y gestionar fincas, asignar usuarios y gestionar todas las operaciones.</li> <li>Trabajador: Puede acceder a la informaci\u00f3n y realizar tareas asignadas en la finca.</li> </ol>"},{"location":"farm/overview/#integracion-con-otros-modulos","title":"Integraci\u00f3n con Otros M\u00f3dulos","text":"<p>El m\u00f3dulo de Finca sirve como base para:</p> <ul> <li>Gesti\u00f3n de lotes (Plot)</li> <li>Gesti\u00f3n de cultivos (Crop)</li> <li>Pr\u00e1cticas culturales (Cultural Practices)</li> <li>Sistema de mediciones (Measurement)</li> </ul>"},{"location":"farm/use_cases/","title":"Casos de Uso de Finca","text":"<p>Este documento describe los casos de uso relacionados con la gesti\u00f3n de fincas en el sistema AgroInsight.</p>"},{"location":"farm/use_cases/#gestion-de-fincas","title":"Gesti\u00f3n de Fincas","text":""},{"location":"farm/use_cases/#caso-de-uso-creacion-de-finca","title":"Caso de Uso: Creaci\u00f3n de Finca","text":"<p>Caso de uso para la creaci\u00f3n de una nueva finca.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para crear una nueva finca, incluyendo las validaciones de unidades de medida y la asignaci\u00f3n de roles.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones con usuarios.</p> <code>user_service</code> <code>UserService</code> <p>Servicio para l\u00f3gica de negocio de usuarios.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>measurement_service</code> <code>MeasurementService</code> <p>Servicio para l\u00f3gica de medidas.</p> <code>measurement_repository</code> <code>MeasurementRepository</code> <p>Repositorio para operaciones con medidas.</p> Source code in <code>app\\farm\\application\\create_farm_use_case.py</code> <pre><code>class CreateFarmUseCase:\n    \"\"\"Caso de uso para la creaci\u00f3n de una nueva finca.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para crear una nueva finca,\n    incluyendo las validaciones de unidades de medida y la asignaci\u00f3n de roles.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n        user_repository (UserRepository): Repositorio para operaciones con usuarios.\n        user_service (UserService): Servicio para l\u00f3gica de negocio de usuarios.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        measurement_service (MeasurementService): Servicio para l\u00f3gica de medidas.\n        measurement_repository (MeasurementRepository): Repositorio para operaciones con medidas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.farm_repository = FarmRepository(db)\n        self.user_repository = UserRepository(db)\n        self.user_service = UserService(db)\n        self.farm_service = FarmService(db)\n        self.measurement_service = MeasurementService(db)\n        self.measurement_repository = MeasurementRepository(db)\n\n    def create_farm(self, farm_data: FarmCreate, current_user: UserInDB) -&gt; SuccessResponse:\n        \"\"\"Crea una nueva finca y asigna al usuario actual como administrador.\n\n        Este m\u00e9todo realiza las siguientes validaciones:\n        1. Verifica que la unidad de medida especificada exista\n        2. Confirma que la unidad de medida sea de tipo \u00e1rea\n        3. Valida que el usuario no tenga otra finca con el mismo nombre\n        4. Crea la finca y asigna el rol de administrador al usuario\n\n        Args:\n            farm_data (FarmCreate): Datos de la finca a crear.\n            current_user (UserInDB): Usuario que est\u00e1 creando la finca.\n\n        Returns:\n            SuccessResponse: Respuesta exitosa con mensaje de confirmaci\u00f3n.\n\n        Raises:\n            DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n                - 404: La unidad de medida no existe\n                - 400: La unidad de medida no es de tipo \u00e1rea\n                - 409: El usuario ya tiene una finca con ese nombre\n                - 500: Error al crear la finca\n        \"\"\"\n\n        # Validar que la unidad de medida exista\n        unit_of_measure = self.measurement_repository.get_unit_of_measure_by_id(farm_data.unidad_area_id)\n        if not unit_of_measure:\n            raise DomainException(\n                message=\"La unidad de medida no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar que la unidad de medida sea de area\n        if self.measurement_repository.get_unit_category_by_id(unit_of_measure.categoria_id).nombre != self.measurement_service.UNIT_CATEGORY_AREA_NAME:\n            raise DomainException(\n                message=\"La unidad de medida no es de \u00e1rea.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        existing_farm = self.farm_repository.get_farm_by_name(farm_data.nombre)\n\n        if existing_farm:\n            if self.farm_service.user_is_farm_admin(current_user.id, existing_farm.id):\n                raise DomainException(\n                    message=\"El usuario ya tiene una finca registrada con ese nombre. Por favor, escoja un nombre diferente.\",\n                    status_code=status.HTTP_409_CONFLICT\n                )\n\n        # Crear la finca\n        farm = self.farm_repository.create_farm(farm_data)\n        if not farm:\n            raise DomainException(\n                message=\"No se pudo crear la finca.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        admin_role = self.farm_service.get_admin_role()\n\n        # Asignar el rol de administrador a la finca\n        self.farm_repository.add_user_to_farm_with_role(current_user.id, farm.id, admin_role.id)\n\n        return SuccessResponse(message=\"Finca creada exitosamente\")\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para la creaci\u00f3n de nuevas fincas, incluyendo la validaci\u00f3n de datos y la asignaci\u00f3n del rol de administrador.</p>"},{"location":"farm/use_cases/#app.farm.application.create_farm_use_case.CreateFarmUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\farm\\application\\create_farm_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.farm_repository = FarmRepository(db)\n    self.user_repository = UserRepository(db)\n    self.user_service = UserService(db)\n    self.farm_service = FarmService(db)\n    self.measurement_service = MeasurementService(db)\n    self.measurement_repository = MeasurementRepository(db)\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.create_farm_use_case.CreateFarmUseCase.create_farm","title":"<code>create_farm(farm_data, current_user)</code>","text":"<p>Crea una nueva finca y asigna al usuario actual como administrador.</p> <p>Este m\u00e9todo realiza las siguientes validaciones: 1. Verifica que la unidad de medida especificada exista 2. Confirma que la unidad de medida sea de tipo \u00e1rea 3. Valida que el usuario no tenga otra finca con el mismo nombre 4. Crea la finca y asigna el rol de administrador al usuario</p> <p>Parameters:</p> Name Type Description Default <code>farm_data</code> <code>FarmCreate</code> <p>Datos de la finca a crear.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario que est\u00e1 creando la finca.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta exitosa con mensaje de confirmaci\u00f3n.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre alg\u00fan error de validaci\u00f3n: - 404: La unidad de medida no existe - 400: La unidad de medida no es de tipo \u00e1rea - 409: El usuario ya tiene una finca con ese nombre - 500: Error al crear la finca</p> Source code in <code>app\\farm\\application\\create_farm_use_case.py</code> <pre><code>def create_farm(self, farm_data: FarmCreate, current_user: UserInDB) -&gt; SuccessResponse:\n    \"\"\"Crea una nueva finca y asigna al usuario actual como administrador.\n\n    Este m\u00e9todo realiza las siguientes validaciones:\n    1. Verifica que la unidad de medida especificada exista\n    2. Confirma que la unidad de medida sea de tipo \u00e1rea\n    3. Valida que el usuario no tenga otra finca con el mismo nombre\n    4. Crea la finca y asigna el rol de administrador al usuario\n\n    Args:\n        farm_data (FarmCreate): Datos de la finca a crear.\n        current_user (UserInDB): Usuario que est\u00e1 creando la finca.\n\n    Returns:\n        SuccessResponse: Respuesta exitosa con mensaje de confirmaci\u00f3n.\n\n    Raises:\n        DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n            - 404: La unidad de medida no existe\n            - 400: La unidad de medida no es de tipo \u00e1rea\n            - 409: El usuario ya tiene una finca con ese nombre\n            - 500: Error al crear la finca\n    \"\"\"\n\n    # Validar que la unidad de medida exista\n    unit_of_measure = self.measurement_repository.get_unit_of_measure_by_id(farm_data.unidad_area_id)\n    if not unit_of_measure:\n        raise DomainException(\n            message=\"La unidad de medida no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar que la unidad de medida sea de area\n    if self.measurement_repository.get_unit_category_by_id(unit_of_measure.categoria_id).nombre != self.measurement_service.UNIT_CATEGORY_AREA_NAME:\n        raise DomainException(\n            message=\"La unidad de medida no es de \u00e1rea.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    existing_farm = self.farm_repository.get_farm_by_name(farm_data.nombre)\n\n    if existing_farm:\n        if self.farm_service.user_is_farm_admin(current_user.id, existing_farm.id):\n            raise DomainException(\n                message=\"El usuario ya tiene una finca registrada con ese nombre. Por favor, escoja un nombre diferente.\",\n                status_code=status.HTTP_409_CONFLICT\n            )\n\n    # Crear la finca\n    farm = self.farm_repository.create_farm(farm_data)\n    if not farm:\n        raise DomainException(\n            message=\"No se pudo crear la finca.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    admin_role = self.farm_service.get_admin_role()\n\n    # Asignar el rol de administrador a la finca\n    self.farm_repository.add_user_to_farm_with_role(current_user.id, farm.id, admin_role.id)\n\n    return SuccessResponse(message=\"Finca creada exitosamente\")\n</code></pre>"},{"location":"farm/use_cases/#caso-de-uso-listar-fincas","title":"Caso de Uso: Listar Fincas","text":"<p>Caso de uso para listar las fincas donde un usuario es administrador.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para obtener una lista paginada de las fincas donde un usuario espec\u00edfico tiene rol de administrador.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones con usuarios.</p> <code>user_service</code> <code>UserService</code> <p>Servicio para l\u00f3gica de negocio de usuarios.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> Source code in <code>app\\farm\\application\\list_farms_use_case.py</code> <pre><code>class ListFarmsUseCase:\n    \"\"\"Caso de uso para listar las fincas donde un usuario es administrador.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para obtener una lista paginada\n    de las fincas donde un usuario espec\u00edfico tiene rol de administrador.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n        user_repository (UserRepository): Repositorio para operaciones con usuarios.\n        user_service (UserService): Servicio para l\u00f3gica de negocio de usuarios.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.farm_repository = FarmRepository(db)\n        self.user_repository = UserRepository(db)\n        self.user_service = UserService(db)\n        self.farm_service = FarmService(db)\n\n    def list_farms(self, current_user: UserInDB, page: int, per_page: int) -&gt; PaginatedFarmListResponse:\n        \"\"\"Lista las fincas donde el usuario es administrador de forma paginada.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Obtiene el ID del rol de administrador de finca.\n        2. Filtra las fincas donde el usuario tiene rol de administrador.\n        3. Construye la respuesta paginada con la informaci\u00f3n de las fincas.\n\n        Args:\n            current_user (UserInDB): Usuario actual que solicita la lista de fincas.\n            page (int): N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.\n            per_page (int): Cantidad de fincas por p\u00e1gina.\n\n        Returns:\n            PaginatedFarmListResponse: Respuesta paginada que incluye:\n                - Lista de fincas para la p\u00e1gina actual\n                - Total de fincas\n                - N\u00famero de p\u00e1gina actual\n                - Elementos por p\u00e1gina\n                - Total de p\u00e1ginas\n        \"\"\"\n\n        # Obtener id del rol de administrador de finca\n        admin_role = self.farm_service.get_admin_role()\n\n        # Filtrar las fincas donde el usuario es administrador\n        total_farms, farms = self.farm_repository.list_farms_by_role_paginated(current_user.id, admin_role.id, page, per_page)\n\n        # Usar la funci\u00f3n de mapeo para construir FarmResponse para cada finca\n        farm_responses = [map_farm_to_response(farm) for farm in farms]\n\n        total_pages = ceil(total_farms / per_page)\n\n        return PaginatedFarmListResponse(\n            farms=farm_responses,\n            total_farms=total_farms,\n            page=page,\n            per_page=per_page,\n            total_pages=total_pages\n        )\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.list_farms_use_case.ListFarmsUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\farm\\application\\list_farms_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.farm_repository = FarmRepository(db)\n    self.user_repository = UserRepository(db)\n    self.user_service = UserService(db)\n    self.farm_service = FarmService(db)\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.list_farms_use_case.ListFarmsUseCase.list_farms","title":"<code>list_farms(current_user, page, per_page)</code>","text":"<p>Lista las fincas donde el usuario es administrador de forma paginada.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Obtiene el ID del rol de administrador de finca. 2. Filtra las fincas donde el usuario tiene rol de administrador. 3. Construye la respuesta paginada con la informaci\u00f3n de las fincas.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual que solicita la lista de fincas.</p> required <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.</p> required <code>per_page</code> <code>int</code> <p>Cantidad de fincas por p\u00e1gina.</p> required <p>Returns:</p> Name Type Description <code>PaginatedFarmListResponse</code> <code>PaginatedFarmListResponse</code> <p>Respuesta paginada que incluye: - Lista de fincas para la p\u00e1gina actual - Total de fincas - N\u00famero de p\u00e1gina actual - Elementos por p\u00e1gina - Total de p\u00e1ginas</p> Source code in <code>app\\farm\\application\\list_farms_use_case.py</code> <pre><code>def list_farms(self, current_user: UserInDB, page: int, per_page: int) -&gt; PaginatedFarmListResponse:\n    \"\"\"Lista las fincas donde el usuario es administrador de forma paginada.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Obtiene el ID del rol de administrador de finca.\n    2. Filtra las fincas donde el usuario tiene rol de administrador.\n    3. Construye la respuesta paginada con la informaci\u00f3n de las fincas.\n\n    Args:\n        current_user (UserInDB): Usuario actual que solicita la lista de fincas.\n        page (int): N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.\n        per_page (int): Cantidad de fincas por p\u00e1gina.\n\n    Returns:\n        PaginatedFarmListResponse: Respuesta paginada que incluye:\n            - Lista de fincas para la p\u00e1gina actual\n            - Total de fincas\n            - N\u00famero de p\u00e1gina actual\n            - Elementos por p\u00e1gina\n            - Total de p\u00e1ginas\n    \"\"\"\n\n    # Obtener id del rol de administrador de finca\n    admin_role = self.farm_service.get_admin_role()\n\n    # Filtrar las fincas donde el usuario es administrador\n    total_farms, farms = self.farm_repository.list_farms_by_role_paginated(current_user.id, admin_role.id, page, per_page)\n\n    # Usar la funci\u00f3n de mapeo para construir FarmResponse para cada finca\n    farm_responses = [map_farm_to_response(farm) for farm in farms]\n\n    total_pages = ceil(total_farms / per_page)\n\n    return PaginatedFarmListResponse(\n        farms=farm_responses,\n        total_farms=total_farms,\n        page=page,\n        per_page=per_page,\n        total_pages=total_pages\n    )\n</code></pre>"},{"location":"farm/use_cases/#caso-de-uso-asignar-usuarios-a-finca","title":"Caso de Uso: Asignar Usuarios a Finca","text":"<p>Caso de uso para asignar usuarios a una finca.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para asignar usuarios a una finca espec\u00edfica mediante sus correos electr\u00f3nicos, asegurando que el usuario que realiza la asignaci\u00f3n tenga los permisos adecuados.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones con usuarios.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>user_service</code> <code>UserService</code> <p>Servicio para l\u00f3gica de negocio de usuarios.</p> Source code in <code>app\\farm\\application\\assign_users_to_farm_use_case.py</code> <pre><code>class AssignUsersToFarmUseCase:\n    \"\"\"Caso de uso para asignar usuarios a una finca.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para asignar usuarios a una finca\n    espec\u00edfica mediante sus correos electr\u00f3nicos, asegurando que el usuario que realiza\n    la asignaci\u00f3n tenga los permisos adecuados.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n        user_repository (UserRepository): Repositorio para operaciones con usuarios.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        user_service (UserService): Servicio para l\u00f3gica de negocio de usuarios.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.farm_repository = FarmRepository(db)\n        self.user_repository = UserRepository(db)\n        self.farm_service = FarmService(db)\n        self.user_service = UserService(db)\n\n    def assign_users_by_emails(self, assignment_data: FarmUserAssignmentByEmail, current_user: UserInDB) -&gt; MultipleResponse:\n        \"\"\"Asigna usuarios a una finca utilizando sus correos electr\u00f3nicos.\n\n        Este m\u00e9todo realiza las siguientes validaciones:\n        1. Verifica que la finca especificada exista.\n        2. Confirma que el usuario actual tenga permisos de administrador en la finca.\n        3. Valida que los usuarios no tengan un rol asignado en la finca antes de asignarlos.\n\n        Args:\n            assignment_data (FarmUserAssignmentByEmail): Datos de asignaci\u00f3n que incluyen\n                el ID de la finca y los correos electr\u00f3nicos de los usuarios a asignar.\n            current_user (UserInDB): Usuario que est\u00e1 realizando la asignaci\u00f3n.\n\n        Returns:\n            MultipleResponse: Respuesta que incluye mensajes sobre el resultado de la\n            asignaci\u00f3n de usuarios y el c\u00f3digo de estado correspondiente.\n\n        Raises:\n            DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n                - 404: La finca especificada no existe.\n                - 403: El usuario actual no tiene permisos para asignar usuarios a la finca.\n        \"\"\"\n        farm = self.farm_repository.get_farm_by_id(assignment_data.farm_id)\n        if not farm:\n            raise DomainException(\n                message=\"La finca especificada no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n            raise DomainException(\n                message=\"No tienes permisos para asignar usuarios a esta finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        worker_role = self.farm_service.get_worker_role()\n\n        messages = []\n        success_count = 0\n        failure_count = 0\n\n        # Validar que los usuarios no tengan un rol asignado en la finca\n        for email in assignment_data.user_emails:\n            user = self.user_repository.get_user_by_email(email)\n            if not user:\n                messages.append(f\"El usuario con email {email} no existe.\")\n                failure_count += 1\n                continue\n\n            user_name = user.nombre + \" \" + user.apellido\n\n            # Validar que el usuario no tenga un rol asignado en la finca\n            existing_assignment = self.farm_repository.get_user_farm(user.id, assignment_data.farm_id)\n            if existing_assignment:\n                messages.append(f\"El usuario {user_name} ya tiene un rol asignado en la finca.\")\n                failure_count += 1\n                continue\n\n            self.farm_repository.add_user_to_farm_with_role(user.id, assignment_data.farm_id, worker_role.id)\n            messages.append(f\"El usuario {user_name} ha sido asignado exitosamente a la finca.\")\n            success_count += 1\n\n        if success_count &gt; 0 and failure_count &gt; 0:\n            status_code = status.HTTP_207_MULTI_STATUS\n        elif success_count == 0:\n            status_code = status.HTTP_400_BAD_REQUEST\n        else:\n            status_code = status.HTTP_200_OK\n\n        return MultipleResponse(messages=messages, status_code=status_code)\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.assign_users_to_farm_use_case.AssignUsersToFarmUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\farm\\application\\assign_users_to_farm_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.farm_repository = FarmRepository(db)\n    self.user_repository = UserRepository(db)\n    self.farm_service = FarmService(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.assign_users_to_farm_use_case.AssignUsersToFarmUseCase.assign_users_by_emails","title":"<code>assign_users_by_emails(assignment_data, current_user)</code>","text":"<p>Asigna usuarios a una finca utilizando sus correos electr\u00f3nicos.</p> <p>Este m\u00e9todo realiza las siguientes validaciones: 1. Verifica que la finca especificada exista. 2. Confirma que el usuario actual tenga permisos de administrador en la finca. 3. Valida que los usuarios no tengan un rol asignado en la finca antes de asignarlos.</p> <p>Parameters:</p> Name Type Description Default <code>assignment_data</code> <code>FarmUserAssignmentByEmail</code> <p>Datos de asignaci\u00f3n que incluyen el ID de la finca y los correos electr\u00f3nicos de los usuarios a asignar.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario que est\u00e1 realizando la asignaci\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>MultipleResponse</code> <code>MultipleResponse</code> <p>Respuesta que incluye mensajes sobre el resultado de la</p> <code>MultipleResponse</code> <p>asignaci\u00f3n de usuarios y el c\u00f3digo de estado correspondiente.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre alg\u00fan error de validaci\u00f3n: - 404: La finca especificada no existe. - 403: El usuario actual no tiene permisos para asignar usuarios a la finca.</p> Source code in <code>app\\farm\\application\\assign_users_to_farm_use_case.py</code> <pre><code>def assign_users_by_emails(self, assignment_data: FarmUserAssignmentByEmail, current_user: UserInDB) -&gt; MultipleResponse:\n    \"\"\"Asigna usuarios a una finca utilizando sus correos electr\u00f3nicos.\n\n    Este m\u00e9todo realiza las siguientes validaciones:\n    1. Verifica que la finca especificada exista.\n    2. Confirma que el usuario actual tenga permisos de administrador en la finca.\n    3. Valida que los usuarios no tengan un rol asignado en la finca antes de asignarlos.\n\n    Args:\n        assignment_data (FarmUserAssignmentByEmail): Datos de asignaci\u00f3n que incluyen\n            el ID de la finca y los correos electr\u00f3nicos de los usuarios a asignar.\n        current_user (UserInDB): Usuario que est\u00e1 realizando la asignaci\u00f3n.\n\n    Returns:\n        MultipleResponse: Respuesta que incluye mensajes sobre el resultado de la\n        asignaci\u00f3n de usuarios y el c\u00f3digo de estado correspondiente.\n\n    Raises:\n        DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n            - 404: La finca especificada no existe.\n            - 403: El usuario actual no tiene permisos para asignar usuarios a la finca.\n    \"\"\"\n    farm = self.farm_repository.get_farm_by_id(assignment_data.farm_id)\n    if not farm:\n        raise DomainException(\n            message=\"La finca especificada no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n        raise DomainException(\n            message=\"No tienes permisos para asignar usuarios a esta finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    worker_role = self.farm_service.get_worker_role()\n\n    messages = []\n    success_count = 0\n    failure_count = 0\n\n    # Validar que los usuarios no tengan un rol asignado en la finca\n    for email in assignment_data.user_emails:\n        user = self.user_repository.get_user_by_email(email)\n        if not user:\n            messages.append(f\"El usuario con email {email} no existe.\")\n            failure_count += 1\n            continue\n\n        user_name = user.nombre + \" \" + user.apellido\n\n        # Validar que el usuario no tenga un rol asignado en la finca\n        existing_assignment = self.farm_repository.get_user_farm(user.id, assignment_data.farm_id)\n        if existing_assignment:\n            messages.append(f\"El usuario {user_name} ya tiene un rol asignado en la finca.\")\n            failure_count += 1\n            continue\n\n        self.farm_repository.add_user_to_farm_with_role(user.id, assignment_data.farm_id, worker_role.id)\n        messages.append(f\"El usuario {user_name} ha sido asignado exitosamente a la finca.\")\n        success_count += 1\n\n    if success_count &gt; 0 and failure_count &gt; 0:\n        status_code = status.HTTP_207_MULTI_STATUS\n    elif success_count == 0:\n        status_code = status.HTTP_400_BAD_REQUEST\n    else:\n        status_code = status.HTTP_200_OK\n\n    return MultipleResponse(messages=messages, status_code=status_code)\n</code></pre>"},{"location":"farm/use_cases/#servicios-de-finca","title":"Servicios de Finca","text":""},{"location":"farm/use_cases/#servicio-de-finca","title":"Servicio de Finca","text":"<p>Servicio para la l\u00f3gica de negocio relacionada con las fincas.</p> <p>Esta clase proporciona m\u00e9todos para verificar roles de usuarios en fincas y obtener roles espec\u00edficos necesarios para la gesti\u00f3n de fincas.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones con usuarios.</p> <code>user_service</code> <code>UserService</code> <p>Servicio para l\u00f3gica de negocio de usuarios.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> Source code in <code>app\\farm\\application\\services\\farm_service.py</code> <pre><code>class FarmService:\n    \"\"\"Servicio para la l\u00f3gica de negocio relacionada con las fincas.\n\n    Esta clase proporciona m\u00e9todos para verificar roles de usuarios en fincas\n    y obtener roles espec\u00edficos necesarios para la gesti\u00f3n de fincas.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos.\n        user_repository (UserRepository): Repositorio para operaciones con usuarios.\n        user_service (UserService): Servicio para l\u00f3gica de negocio de usuarios.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el servicio de fincas con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.user_service = UserService(db)\n        self.farm_repository = FarmRepository(db)\n\n    def user_is_farm_admin(self, user_id: int, farm_id: int) -&gt; bool:\n        \"\"\"Verifica si un usuario tiene rol de administrador en una finca.\n\n        Args:\n            user_id (int): ID del usuario a verificar.\n            farm_id (int): ID de la finca a verificar.\n\n        Returns:\n            bool: True si el usuario es administrador de la finca, False en caso contrario.\n        \"\"\"\n        admin_role = self.get_admin_role()\n        return self.farm_repository.get_user_farm_role(user_id, farm_id, admin_role.id) is not None\n\n    def user_is_farm_worker(self, user_id: int, farm_id: int) -&gt; bool:\n        \"\"\"Verifica si un usuario tiene rol de trabajador en una finca.\n\n        Args:\n            user_id (int): ID del usuario a verificar.\n            farm_id (int): ID de la finca a verificar.\n\n        Returns:\n            bool: True si el usuario es trabajador de la finca, False en caso contrario.\n        \"\"\"\n        worker_role = self.get_worker_role()\n        return self.farm_repository.get_user_farm_role(user_id, farm_id, worker_role.id) is not None\n\n    def get_admin_role(self) -&gt; Optional[Role]:\n        \"\"\"Obtiene el rol de administrador de finca.\n\n        Returns:\n            Optional[Role]: Rol de administrador de finca.\n\n        Raises:\n            DomainException: Si no se puede obtener el rol de administrador.\n        \"\"\"\n        rol_administrador_finca = self.user_repository.get_role_by_name(self.user_service.ADMIN_ROLE_NAME)\n        if not rol_administrador_finca:\n            raise DomainException(\n                message=\"No se pudo obtener el rol de Administrador de Finca.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        return rol_administrador_finca\n\n    def get_worker_role(self) -&gt; Optional[Role]:\n        \"\"\"Obtiene el rol de trabajador de finca.\n\n        Returns:\n            Optional[Role]: Rol de trabajador de finca.\n\n        Raises:\n            DomainException: Si no se puede obtener el rol de trabajador.\n        \"\"\"\n        worker_role = self.user_repository.get_role_by_name(self.user_service.WORKER_ROLE_NAME)\n        if not worker_role:\n            raise DomainException(\n                message=\"No se pudo obtener el rol de Trabajador de Finca.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        return worker_role\n</code></pre> <p>Este servicio proporciona funcionalidades comunes utilizadas por varios casos de uso, como la verificaci\u00f3n de roles y permisos.</p>"},{"location":"farm/use_cases/#app.farm.application.services.farm_service.FarmService.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el servicio de fincas con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\farm\\application\\services\\farm_service.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el servicio de fincas con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.user_service = UserService(db)\n    self.farm_repository = FarmRepository(db)\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.services.farm_service.FarmService.get_admin_role","title":"<code>get_admin_role()</code>","text":"<p>Obtiene el rol de administrador de finca.</p> <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>Optional[Role]: Rol de administrador de finca.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se puede obtener el rol de administrador.</p> Source code in <code>app\\farm\\application\\services\\farm_service.py</code> <pre><code>def get_admin_role(self) -&gt; Optional[Role]:\n    \"\"\"Obtiene el rol de administrador de finca.\n\n    Returns:\n        Optional[Role]: Rol de administrador de finca.\n\n    Raises:\n        DomainException: Si no se puede obtener el rol de administrador.\n    \"\"\"\n    rol_administrador_finca = self.user_repository.get_role_by_name(self.user_service.ADMIN_ROLE_NAME)\n    if not rol_administrador_finca:\n        raise DomainException(\n            message=\"No se pudo obtener el rol de Administrador de Finca.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return rol_administrador_finca\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.services.farm_service.FarmService.get_worker_role","title":"<code>get_worker_role()</code>","text":"<p>Obtiene el rol de trabajador de finca.</p> <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>Optional[Role]: Rol de trabajador de finca.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se puede obtener el rol de trabajador.</p> Source code in <code>app\\farm\\application\\services\\farm_service.py</code> <pre><code>def get_worker_role(self) -&gt; Optional[Role]:\n    \"\"\"Obtiene el rol de trabajador de finca.\n\n    Returns:\n        Optional[Role]: Rol de trabajador de finca.\n\n    Raises:\n        DomainException: Si no se puede obtener el rol de trabajador.\n    \"\"\"\n    worker_role = self.user_repository.get_role_by_name(self.user_service.WORKER_ROLE_NAME)\n    if not worker_role:\n        raise DomainException(\n            message=\"No se pudo obtener el rol de Trabajador de Finca.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return worker_role\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.services.farm_service.FarmService.user_is_farm_admin","title":"<code>user_is_farm_admin(user_id, farm_id)</code>","text":"<p>Verifica si un usuario tiene rol de administrador en una finca.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario a verificar.</p> required <code>farm_id</code> <code>int</code> <p>ID de la finca a verificar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario es administrador de la finca, False en caso contrario.</p> Source code in <code>app\\farm\\application\\services\\farm_service.py</code> <pre><code>def user_is_farm_admin(self, user_id: int, farm_id: int) -&gt; bool:\n    \"\"\"Verifica si un usuario tiene rol de administrador en una finca.\n\n    Args:\n        user_id (int): ID del usuario a verificar.\n        farm_id (int): ID de la finca a verificar.\n\n    Returns:\n        bool: True si el usuario es administrador de la finca, False en caso contrario.\n    \"\"\"\n    admin_role = self.get_admin_role()\n    return self.farm_repository.get_user_farm_role(user_id, farm_id, admin_role.id) is not None\n</code></pre>"},{"location":"farm/use_cases/#app.farm.application.services.farm_service.FarmService.user_is_farm_worker","title":"<code>user_is_farm_worker(user_id, farm_id)</code>","text":"<p>Verifica si un usuario tiene rol de trabajador en una finca.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario a verificar.</p> required <code>farm_id</code> <code>int</code> <p>ID de la finca a verificar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario es trabajador de la finca, False en caso contrario.</p> Source code in <code>app\\farm\\application\\services\\farm_service.py</code> <pre><code>def user_is_farm_worker(self, user_id: int, farm_id: int) -&gt; bool:\n    \"\"\"Verifica si un usuario tiene rol de trabajador en una finca.\n\n    Args:\n        user_id (int): ID del usuario a verificar.\n        farm_id (int): ID de la finca a verificar.\n\n    Returns:\n        bool: True si el usuario es trabajador de la finca, False en caso contrario.\n    \"\"\"\n    worker_role = self.get_worker_role()\n    return self.farm_repository.get_user_farm_role(user_id, farm_id, worker_role.id) is not None\n</code></pre>"},{"location":"guides/faq/","title":"Preguntas Frecuentes (FAQ)","text":""},{"location":"guides/faq/#que-es-agroinsight","title":"\u00bfQu\u00e9 es AgroInsight?","text":"<p>AgroInsight es una aplicaci\u00f3n de gesti\u00f3n agr\u00edcola dise\u00f1ada para optimizar el cultivo de ma\u00edz en la regi\u00f3n del Huila, Colombia. Utiliza tecnolog\u00edas modernas como FastAPI, React Native, y TensorFlow para ofrecer funcionalidades avanzadas como an\u00e1lisis de suelos, detecci\u00f3n de plagas, y recomendaciones personalizadas.</p>"},{"location":"guides/faq/#como-puedo-empezar-a-contribuir-al-proyecto","title":"\u00bfC\u00f3mo puedo empezar a contribuir al proyecto?","text":"<p>Para comenzar a contribuir, sigue estos pasos:</p> <ol> <li>Clona el repositorio desde GitHub.</li> <li>Configura tu entorno de desarrollo siguiendo la Gu\u00eda de Instalaci\u00f3n.</li> <li>Revisa la Gu\u00eda de Contribuci\u00f3n para entender las normas y el flujo de trabajo del proyecto.</li> </ol>"},{"location":"guides/faq/#cuales-son-los-requisitos-del-sistema-para-ejecutar-agroinsight","title":"\u00bfCu\u00e1les son los requisitos del sistema para ejecutar AgroInsight?","text":"<p>Los requisitos principales incluyen:</p> <ul> <li>Python 3.12 o superior</li> <li>Docker</li> <li>PostgreSQL 16.2</li> <li>Poetry para la gesti\u00f3n de dependencias</li> </ul> <p>Para m\u00e1s detalles, consulta la secci\u00f3n de Requisitos del Sistema.</p>"},{"location":"guides/faq/#como-se-maneja-la-autenticacion-en-agroinsight","title":"\u00bfC\u00f3mo se maneja la autenticaci\u00f3n en AgroInsight?","text":"<p>AgroInsight utiliza autenticaci\u00f3n de dos factores (2FA) para mejorar la seguridad. Los usuarios deben verificar su identidad mediante un PIN enviado a su correo electr\u00f3nico. Para m\u00e1s detalles, revisa el endpoint <code>/login/verify</code> en la documentaci\u00f3n de la API.</p>"},{"location":"guides/faq/#que-debo-hacer-si-encuentro-un-error-durante-la-instalacion","title":"\u00bfQu\u00e9 debo hacer si encuentro un error durante la instalaci\u00f3n?","text":"<p>Si encuentras problemas durante la instalaci\u00f3n, verifica lo siguiente:</p> <ul> <li>Aseg\u00farate de que todas las dependencias est\u00e1n instaladas correctamente.</li> <li>Revisa que las variables de entorno en el archivo <code>.env</code> est\u00e9n configuradas correctamente.</li> <li>Consulta la secci\u00f3n de Soluci\u00f3n de Problemas Comunes para m\u00e1s ayuda.</li> </ul>"},{"location":"guides/faq/#como-se-gestionan-los-roles-de-usuario-en-el-sistema","title":"\u00bfC\u00f3mo se gestionan los roles de usuario en el sistema?","text":"<p>Los roles de usuario se gestionan a trav\u00e9s de la base de datos y se asignan durante la creaci\u00f3n del usuario. Los roles determinan los permisos y accesos dentro del sistema. Para m\u00e1s informaci\u00f3n, revisa el m\u00f3dulo de usuarios en la documentaci\u00f3n del c\u00f3digo.</p>"},{"location":"guides/faq/#donde-puedo-encontrar-la-documentacion-de-la-api","title":"\u00bfD\u00f3nde puedo encontrar la documentaci\u00f3n de la API?","text":"<p>La documentaci\u00f3n de la API se genera autom\u00e1ticamente y est\u00e1 disponible en:</p> <ul> <li>Swagger UI: <code>http://localhost:8000/docs</code></li> <li>ReDoc: <code>http://localhost:8000/redoc</code></li> </ul>"},{"location":"guides/faq/#como-se-despliega-agroinsight","title":"\u00bfC\u00f3mo se despliega AgroInsight?","text":"<p>El despliegue se realiza autom\u00e1ticamente en la plataforma Railway al fusionar cambios en la rama <code>main</code>. Aseg\u00farate de que todas las pruebas pasen antes de fusionar tus cambios. Para m\u00e1s detalles, consulta la secci\u00f3n de Despliegue.</p>"},{"location":"guides/faq/#como-puedo-reportar-un-problema-o-sugerir-una-mejora","title":"\u00bfC\u00f3mo puedo reportar un problema o sugerir una mejora?","text":"<p>Puedes reportar problemas o sugerir mejoras creando un issue en el repositorio de GitHub. Aseg\u00farate de proporcionar una descripci\u00f3n detallada y, si es posible, pasos para reproducir el problema.</p>"},{"location":"guides/faq/#donde-puedo-encontrar-mas-informacion-sobre-las-practicas-de-codificacion","title":"\u00bfD\u00f3nde puedo encontrar m\u00e1s informaci\u00f3n sobre las pr\u00e1cticas de codificaci\u00f3n?","text":"<p>Revisa la Gu\u00eda de Est\u00e1ndares de Codificaci\u00f3n para conocer las convenciones y pr\u00e1cticas recomendadas en el proyecto.</p>"},{"location":"guides/getting_started/","title":"Gu\u00eda de Inicio R\u00e1pido para Desarrolladores Backend de AgroInsight","text":""},{"location":"guides/getting_started/#introduccion","title":"Introducci\u00f3n","text":"<p>Bienvenido al equipo de desarrollo backend de AgroInsight. Esta gu\u00eda te proporcionar\u00e1 la informaci\u00f3n necesaria para comenzar a contribuir al proyecto. AgroInsight es una aplicaci\u00f3n de gesti\u00f3n agr\u00edcola dise\u00f1ada para optimizar el cultivo de ma\u00edz en la regi\u00f3n del Huila, Colombia, utilizando tecnolog\u00edas modernas y pr\u00e1cticas de desarrollo \u00e1gil.</p>"},{"location":"guides/getting_started/#estructura-del-proyecto","title":"Estructura del Proyecto","text":"<p>El proyecto sigue una arquitectura limpia y est\u00e1 organizado en m\u00f3dulos, cada uno con sus propias capas. La estructura general es la siguiente:</p> <pre><code>app/\n\u251c\u2500\u2500 [nombre_del_modulo]/\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 infrastructure/\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u251c\u2500\u2500 common/\n\u2502   \u251c\u2500\u2500 database/\n\u2502   \u251c\u2500\u2500 security/\n\u2502   \u2514\u2500\u2500 services/\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"guides/getting_started/#estructura-de-un-modulo","title":"Estructura de un M\u00f3dulo","text":"<p>Cuando se desarrolla un nuevo m\u00f3dulo, se debe crear una carpeta con el nombre del m\u00f3dulo dentro de <code>app/</code> y dentro de ella las siguientes subcarpetas y archivos:</p> <ul> <li><code>application/</code>: Contiene los casos de uso (archivos <code>*_use_case.py</code>).</li> <li><code>domain/</code>: Define las entidades y reglas de negocio.</li> <li><code>schemas.py</code>: Define los esquemas Pydantic del m\u00f3dulo.</li> <li><code>infrastructure/</code>:</li> <li><code>api.py</code>: Define los endpoints del m\u00f3dulo.</li> <li><code>sql_repository.py</code>: Contiene las transacciones de la base de datos.</li> <li><code>orm_models.py</code>: Define los modelos ORM del m\u00f3dulo.</li> </ul>"},{"location":"guides/getting_started/#infraestructura-comun","title":"Infraestructura Com\u00fan","text":"<p>La carpeta <code>app/infrastructure</code> contiene archivos comunes a todo el proyecto, incluyendo:</p> <ul> <li>Conexi\u00f3n a la base de datos</li> <li>Middleware JWT</li> <li>Servicios para env\u00edo de emails</li> <li>Servicios para generaci\u00f3n de PINs de seguridad</li> <li>Servicios de encriptaci\u00f3n de contrase\u00f1as</li> <li>Servicios de generaci\u00f3n de tokens de acceso</li> <li>Validadores</li> <li>Response mappers</li> <li>Importaciones de variables de entorno</li> <li>Errores personalizados</li> <li>Manejadores de errores</li> <li>C\u00f3digo com\u00fan utilizado en todos los m\u00f3dulos</li> </ul>"},{"location":"guides/getting_started/#principios-de-desarrollo","title":"Principios de Desarrollo","text":""},{"location":"guides/getting_started/#clean-code-y-arquitectura-limpia","title":"Clean Code y Arquitectura Limpia","text":"<p>El proyecto AgroInsight sigue los principios de Clean Code y Arquitectura Limpia. Esto implica:</p> <ol> <li>Separaci\u00f3n clara de responsabilidades entre capas.</li> <li>Dependencias apuntando hacia el dominio.</li> <li>Entidades de negocio independientes de frameworks y detalles de implementaci\u00f3n.</li> <li>Casos de uso que encapsulan la l\u00f3gica de la aplicaci\u00f3n.</li> </ol>"},{"location":"guides/getting_started/#convenciones-de-codigo","title":"Convenciones de C\u00f3digo","text":"<ul> <li>Seguimos la gu\u00eda de estilo PEP 8 para Python.</li> <li>Utilizamos Type Hints para anotaciones de tipo.</li> <li>Documentamos las funciones y clases utilizando docstrings en formato Google.</li> <li>Utilizamos Black para el formateo autom\u00e1tico del c\u00f3digo.</li> <li>Empleamos Flake8 para el linting del c\u00f3digo.</li> </ul>"},{"location":"guides/getting_started/#practicas-de-codificacion","title":"Pr\u00e1cticas de Codificaci\u00f3n","text":"<ol> <li> <p>Early Return: Preferimos el estilo de \"early return\" para mejorar la legibilidad y reducir la anidaci\u00f3n.</p> </li> <li> <p>DRY (Don't Repeat Yourself): Si notas que est\u00e1s repitiendo el mismo c\u00f3digo en m\u00faltiples lugares, refactoriza ese c\u00f3digo en una funci\u00f3n o m\u00e9todo reutilizable.</p> </li> <li> <p>Estructura del Proyecto: Al desarrollar o refactorizar una funcionalidad de un m\u00f3dulo existente, sigue la estructura ya definida para mantener la consistencia.</p> </li> <li> <p>Nombres Descriptivos: Usa nombres claros y significativos para variables, funciones y clases.</p> </li> <li> <p>Funciones Peque\u00f1as: Las funciones deben ser cortas y hacer una sola cosa.</p> </li> <li> <p>Comentarios \u00datiles: Los comentarios deben explicar el \"por qu\u00e9\", no el \"qu\u00e9\". El c\u00f3digo debe ser autoexplicativo.</p> </li> <li> <p>Manejo de Errores: Implementa un manejo de errores personalizado para la l\u00f3gica de negocio, la validaci\u00f3n de datos de entrada y los errores inesperados. Los mensajes deben ser claros y consistente.</p> </li> </ol>"},{"location":"guides/getting_started/#flujo-de-trabajo-de-desarrollo","title":"Flujo de Trabajo de Desarrollo","text":"<ol> <li>Crea una nueva rama para tu feature o bugfix:</li> </ol> <pre><code>git checkout -b feature/nombre-de-la-caracteristica\n</code></pre> <ol> <li> <p>Desarrolla tu c\u00f3digo siguiendo las convenciones y principios establecidos.</p> </li> <li> <p>Ejecuta las pruebas unitarias y aseg\u00farate de que pasen:</p> </li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Formatea tu c\u00f3digo:</li> </ol> <pre><code>black .\n</code></pre> <ol> <li>Ejecuta el linter:</li> </ol> <pre><code>flake8\n</code></pre> <ol> <li>Realiza un commit de tus cambios:</li> </ol> <pre><code>git add .\ngit commit -m \"Descripci\u00f3n concisa de los cambios\"\n</code></pre> <ol> <li>Sube tus cambios a GitHub:</li> </ol> <pre><code>git push origin feature/nombre-de-la-caracteristica\n</code></pre> <ol> <li>Crea un Pull Request en GitHub para revisi\u00f3n.</li> </ol>"},{"location":"guides/getting_started/#trabajando-con-la-base-de-datos","title":"Trabajando con la Base de Datos","text":"<p>AgroInsight utiliza Postgresql 16.2 como sistema de gesti\u00f3n de base de datos. La estructura de la base de datos se administra a trav\u00e9s de PgAdmin utilizando lenguaje SQL. La estructura est\u00e1 documentada en https://dbdocs.io/davidvalencia0526/AgroInsight.</p>"},{"location":"guides/getting_started/#integracion-con-servicios-externos","title":"Integraci\u00f3n con Servicios Externos","text":"<p>AgroInsight integra varios servicios externos. Aseg\u00farate de tener las credenciales necesarias en tu archivo <code>.env</code>:</p> <ul> <li>API de OpenWeatherMap para datos meteorol\u00f3gicos</li> <li>Servicio de correo electr\u00f3nico (SMTP) para notificaciones</li> <li>Servicios de almacenamiento en la nube para im\u00e1genes y archivos</li> </ul>"},{"location":"guides/getting_started/#pruebas","title":"Pruebas","text":"<p>Ejecutamos pruebas unitarias, de integraci\u00f3n y end-to-end. Para ejecutar todas las pruebas:</p> <pre><code>pytest\n</code></pre> <p>Para ejecutar pruebas espec\u00edficas:</p> <pre><code>pytest tests/unit\npytest tests/integration\npytest tests/e2e\n</code></pre>"},{"location":"guides/getting_started/#documentacion","title":"Documentaci\u00f3n","text":"<p>La documentaci\u00f3n del API se genera autom\u00e1ticamente y est\u00e1 disponible en:</p> <ul> <li>Swagger UI: <code>http://localhost:8000/docs</code></li> <li>ReDoc: <code>http://localhost:8000/redoc</code></li> </ul> <p>Para generar la documentaci\u00f3n del proyecto:</p> <pre><code>mkdocs serve\n</code></pre> <p>Esto iniciar\u00e1 un servidor local con la documentaci\u00f3n en <code>http://localhost:8000</code>.</p>"},{"location":"guides/getting_started/#despliegue","title":"Despliegue","text":"<p>El despliegue se realiza autom\u00e1ticamente a trav\u00e9s de Railway cuando se fusiona c\u00f3digo en la rama <code>main</code>. Aseg\u00farate de que todas las pruebas pasen antes de fusionar tus cambios.</p>"},{"location":"guides/getting_started/#ejemplo-de-creacion-de-un-nuevo-modulo","title":"Ejemplo de Creaci\u00f3n de un Nuevo M\u00f3dulo","text":"<p>Para ilustrar c\u00f3mo crear un nuevo m\u00f3dulo en AgroInsight, vamos a desarrollar un m\u00f3dulo de \"An\u00e1lisis de Suelo\". Este m\u00f3dulo permitir\u00e1 a los usuarios registrar y consultar an\u00e1lisis de suelo para sus lotes.</p>"},{"location":"guides/getting_started/#1-estructura-del-modulo","title":"1. Estructura del M\u00f3dulo","text":"<p>Primero, creamos la estructura de carpetas para el nuevo m\u00f3dulo:</p> <pre><code>app/\n\u2514\u2500\u2500 soil_analysis/\n    \u251c\u2500\u2500 application/\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 domain/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 schemas.py\n    \u2514\u2500\u2500 infrastructure/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py\n        \u251c\u2500\u2500 orm_models.py\n        \u2514\u2500\u2500 sql_repository.py\n</code></pre>"},{"location":"guides/getting_started/#2-definicion-de-esquemas-domainschemaspy","title":"2. Definici\u00f3n de Esquemas (domain/schemas.py)","text":"<pre><code>from pydantic import BaseModel, Field\nfrom datetime import date\nfrom typing import Optional\n\nclass SoilAnalysisBase(BaseModel):\n    lote_id: int\n    fecha_analisis: date\n    ph: float = Field(..., ge=0, le=14)\n    materia_organica: float = Field(..., ge=0, le=100)\n    nitrogeno: float = Field(..., ge=0)\n    fosforo: float = Field(..., ge=0)\n    potasio: float = Field(..., ge=0)\n    observaciones: Optional[str] = None\n\nclass SoilAnalysisCreate(SoilAnalysisBase):\n    pass\n\nclass SoilAnalysisResponse(SoilAnalysisBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"guides/getting_started/#3-definicion-de-modelos-orm-infrastructureorm_modelspy","title":"3. Definici\u00f3n de Modelos ORM (infrastructure/orm_models.py)","text":"<pre><code>from sqlalchemy import Column, Integer, Float, Date, ForeignKey, Text\nfrom app.infrastructure.database.database import Base\n\nclass SoilAnalysis(Base):\n    __tablename__ = \"analisis_suelo\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    lote_id = Column(Integer, ForeignKey(\"lote.id\"), nullable=False)\n    fecha_analisis = Column(Date, nullable=False)\n    ph = Column(Float, nullable=False)\n    materia_organica = Column(Float, nullable=False)\n    nitrogeno = Column(Float, nullable=False)\n    fosforo = Column(Float, nullable=False)\n    potasio = Column(Float, nullable=False)\n    observaciones = Column(Text)\n</code></pre>"},{"location":"guides/getting_started/#4-implementacion-del-repositorio-infrastructuresql_repositorypy","title":"4. Implementaci\u00f3n del Repositorio (infrastructure/sql_repository.py)","text":"<pre><code>from sqlalchemy.orm import Session\nfrom app.soil_analysis.infrastructure.orm_models import SoilAnalysis\nfrom app.soil_analysis.domain.schemas import SoilAnalysisCreate\n\nclass SoilAnalysisRepository:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def create_soil_analysis(self, soil_analysis: SoilAnalysisCreate) -&gt; SoilAnalysis:\n        db_soil_analysis = SoilAnalysis(**soil_analysis.model_dump())\n        self.db.add(db_soil_analysis)\n        self.db.commit()\n        self.db.refresh(db_soil_analysis)\n        return db_soil_analysis\n\n    def get_soil_analysis(self, soil_analysis_id: int) -&gt; SoilAnalysis:\n        return self.db.query(SoilAnalysis).filter(SoilAnalysis.id == soil_analysis_id).first()\n\n    def get_soil_analyses_by_lote(self, lote_id: int):\n        return self.db.query(SoilAnalysis).filter(SoilAnalysis.lote_id == lote_id).all()\n</code></pre>"},{"location":"guides/getting_started/#5-implementacion-del-caso-de-uso-applicationcreate_soil_analysis_use_casepy","title":"5. Implementaci\u00f3n del Caso de Uso (application/create_soil_analysis_use_case.py)","text":"<pre><code>from sqlalchemy.orm import Session\nfrom app.soil_analysis.infrastructure.sql_repository import SoilAnalysisRepository\nfrom app.soil_analysis.domain.schemas import SoilAnalysisCreate, SoilAnalysisResponse\nfrom app.infrastructure.common.common_exceptions import DomainException\nfrom app.user.domain.schemas import UserInDB\nfrom fastapi import status\n\nclass CreateSoilAnalysisUseCase:\n    def __init__(self, db: Session):\n        self.db = db\n        self.soil_analysis_repository = SoilAnalysisRepository(db)\n\n    def execute(self, soil_analysis_data: SoilAnalysisCreate, current_user: UserInDB) -&gt; SoilAnalysisResponse:\n        if not self.user_can_create_soil_analysis(current_user):\n            raise DomainException(\n                message=\"No tienes permisos para crear un an\u00e1lisis de suelo.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # Aqu\u00ed podr\u00edas agregar m\u00e1s validaciones, como verificar si el lote existe y pertenece al usuario\n\n        soil_analysis = self.soil_analysis_repository.create_soil_analysis(soil_analysis_data)\n        return SoilAnalysisResponse.model_validate(soil_analysis)\n\n    def user_can_create_soil_analysis(self, user: UserInDB) -&gt; bool:\n        allowed_roles = [\"Administrador de Finca\", \"Agr\u00f3nomo\"]\n        return any(role.nombre in allowed_roles for role in user.roles)\n</code></pre>"},{"location":"guides/getting_started/#6-definicion-de-la-api-infrastructureapipy","title":"6. Definici\u00f3n de la API (infrastructure/api.py)","text":"<pre><code>from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.infrastructure.database.database import getDb\nfrom app.soil_analysis.domain.schemas import SoilAnalysisCreate, SoilAnalysisResponse\nfrom app.soil_analysis.application.create_soil_analysis_use_case import CreateSoilAnalysisUseCase\nfrom app.infrastructure.security.security_utils import get_current_user\nfrom app.user.domain.schemas import UserInDB\n\nrouter = APIRouter(prefix=\"/soil-analysis\", tags=[\"Soil Analysis\"])\n\n@router.post(\"/\", response_model=SoilAnalysisResponse)\ndef create_soil_analysis(\n    soil_analysis: SoilAnalysisCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n):\n    use_case = CreateSoilAnalysisUseCase(db)\n    try:\n        return use_case.execute(soil_analysis, current_user)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, \n            detail=f\"Error interneo al crear el an\u00e1lisis de suelo: {str(e)}\"\n            )\n</code></pre>"},{"location":"guides/getting_started/#7-integracion-con-el-sistema-principal-mainpy","title":"7. Integraci\u00f3n con el Sistema Principal (main.py)","text":"<p>Finalmente, incluimos el router del nuevo m\u00f3dulo en el archivo principal de la aplicaci\u00f3n:</p> <pre><code>from fastapi import FastAPI\nfrom app.soil_analysis.infrastructure.api import router as soil_analysis_router\n\napp = FastAPI()\n\n# ... otros imports y configuraciones ...\n\napp.include_router(soil_analysis_router)\n</code></pre>"},{"location":"guides/getting_started/#uso-de-servicios-comunes","title":"Uso de Servicios Comunes","text":"<p>En este ejemplo, hemos utilizado varios servicios y componentes comunes del proyecto:</p> <ol> <li>Base de datos: Utilizamos la sesi\u00f3n de base de datos proporcionada por <code>getDb()</code>.</li> <li>Autenticaci\u00f3n: Usamos <code>get_current_user()</code> para obtener el usuario autenticado.</li> <li>Manejo de excepciones: Empleamos <code>DomainException</code> para errores de dominio personalizados.</li> <li>Modelos ORM: Extendemos <code>Base</code> de SQLAlchemy para nuestro modelo ORM.</li> <li>Validaci\u00f3n de datos: Utilizamos Pydantic para la validaci\u00f3n de datos de entrada y salida.</li> </ol>"},{"location":"guides/getting_started/#recursos-adicionales","title":"Recursos Adicionales","text":"<ul> <li>Documentaci\u00f3n oficial de FastAPI</li> <li>Documentaci\u00f3n de SQLAlchemy</li> <li>Gu\u00eda de Railway para despliegue</li> <li>Documentaci\u00f3n de TensorFlow</li> </ul>"},{"location":"guides/getting_started/#soporte","title":"Soporte","text":"<p>Si encuentras alg\u00fan problema o tienes preguntas, no dudes en contactar al equipo de desarrollo a trav\u00e9s del canal #backend-support en Slack.</p> <p>\u00a1Bienvenido al equipo y feliz codificaci\u00f3n!</p>"},{"location":"guides/installation/","title":"Gu\u00eda de Instalaci\u00f3n de AgroInsight","text":"<p>Esta gu\u00eda proporciona instrucciones detalladas para configurar el entorno de desarrollo del proyecto AgroInsight. Sigue cada paso cuidadosamente para asegurar una instalaci\u00f3n correcta y completa.</p>"},{"location":"guides/installation/#prerrequisitos","title":"Prerrequisitos","text":"<p>Antes de comenzar, aseg\u00farate de tener instalado lo siguiente:</p> <ol> <li>Python 3.12 o superior: Descarga e instala desde python.org.</li> <li>VS Code: Descarga e instala desde code.visualstudio.com.</li> <li>PostgreSQL 16.2: Descarga e instala desde postgresql.org.</li> <li>PgAdmin: Descarga e instala desde pgadmin.org.</li> <li>pip: Generalmente se instala con Python. Verifica con <code>pip --version</code>.</li> <li>Poetry: Instala ejecutando <code>pip install poetry</code>.</li> <li>Git: Descarga e instala desde git-scm.com.</li> <li>Cuenta de GitHub: Crea una cuenta en github.com.</li> <li>Docker Desktop: Descarga e instala desde docker.com.</li> </ol>"},{"location":"guides/installation/#pasos-de-instalacion-del-proyecto","title":"Pasos de Instalaci\u00f3n del proyecto","text":""},{"location":"guides/installation/#1-clonar-los-repositorios","title":"1. Clonar los Repositorios","text":"<pre><code>git clone https://github.com/DavidValenciaX/agroinsight-backend.git\ncd agroinsight-backend\n</code></pre>"},{"location":"guides/installation/#2-configurar-el-entorno-virtual-para-el-backend","title":"2. Configurar el Entorno Virtual para el Backend","text":"<pre><code>poetry config virtualenvs.in-project true\npoetry install\n</code></pre>"},{"location":"guides/installation/#3-instalar-dependencias-del-backend","title":"3. Instalar Dependencias del Backend","text":"<pre><code>poetry install\n</code></pre>"},{"location":"guides/installation/#4-configurar-variables-de-entorno","title":"4. Configurar Variables de Entorno","text":"<p>Crea un archivo <code>.env</code> en la ra\u00edz del proyecto backend y a\u00f1ade las siguientes variables:</p> <pre><code>DATABASE_URL=\"postgresql://user:password@host:port/database\"\nSECRET_KEY=tu_clave_secreta\nGMAIL_USER=tu_correo@gmail.com\nGMAIL_APP_PASSWORD=tu_contrase\u00f1a_de_aplicacion\n</code></pre> <p>Solicita los valores reales a un miembro del equipo.</p>"},{"location":"guides/installation/#5-correr-el-servidor-backend","title":"5. Correr el servidor Backend","text":"<pre><code>poetry run uvicorn app.main:app --reload\n</code></pre>"},{"location":"guides/installation/#verificacion-de-la-instalacion","title":"Verificaci\u00f3n de la Instalaci\u00f3n","text":"<ol> <li>Backend: Visita <code>http://localhost:8000/docs</code> para ver la documentaci\u00f3n Swagger de la API.</li> </ol>"},{"location":"guides/installation/#solucion-de-problemas-comunes","title":"Soluci\u00f3n de Problemas Comunes","text":"<ul> <li>Problemas con dependencias de Python: Aseg\u00farate de usar Python 3.12 y que el entorno virtual est\u00e9 activado.</li> <li>Errores de base de datos: Verifica que el contenedor Docker de Postgresql est\u00e9 corriendo y las credenciales en <code>.env</code> sean correctas.</li> <li>Problemas con TensorFlow o OpenCV: Aseg\u00farate de que tu sistema cumple con los requisitos de hardware para IA.</li> </ul>"},{"location":"guides/installation/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Revisa la Gu\u00eda de Inicio R\u00e1pido para comenzar a desarrollar.</li> <li>Familiar\u00edzate con la estructura del proyecto y los est\u00e1ndares de c\u00f3digo.</li> <li>Configura tu entorno de desarrollo siguiendo las mejores pr\u00e1cticas del equipo.</li> </ul> <p>Para cualquier problema adicional, consulta la secci\u00f3n de FAQ o contacta al equipo de desarrollo a trav\u00e9s de Slack.</p>"},{"location":"plot/endpoints/","title":"Endpoints del M\u00f3dulo de Lotes","text":"<p>Este documento describe los endpoints disponibles para la gesti\u00f3n de lotes en el sistema AgroInsight.</p>"},{"location":"plot/endpoints/#gestion-de-lotes","title":"Gesti\u00f3n de Lotes","text":""},{"location":"plot/endpoints/#crear-lote","title":"Crear Lote","text":"<p>Crea un nuevo lote en el sistema dentro de una finca espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>PlotCreate</code> <p>Datos del lote a crear.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Un objeto SuccessResponse indicando que el lote fue creado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la creaci\u00f3n del lote o si hay inconsistencia en los IDs de finca.</p> Source code in <code>app\\plot\\infrastructure\\api.py</code> <pre><code>@router.post(\"/plot/create\", response_model=SuccessResponse, status_code=status.HTTP_201_CREATED)\ndef create_plot(\n    plot: PlotCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n)-&gt; SuccessResponse:\n    \"\"\"\n    Crea un nuevo lote en el sistema dentro de una finca espec\u00edfica.\n\n    Parameters:\n        plot (PlotCreate): Datos del lote a crear.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Un objeto SuccessResponse indicando que el lote fue creado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la creaci\u00f3n del lote o si hay inconsistencia en los IDs de finca.\n    \"\"\"\n    create_plot_use_case = CreatePlotUseCase(db)\n    try:\n        return create_plot_use_case.create_plot(plot, current_user)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al crear el lote: {str(e)}\"\n        )\n</code></pre> <p>Endpoint para crear un nuevo lote en una finca espec\u00edfica.</p>"},{"location":"plot/endpoints/#listar-lotes-por-finca","title":"Listar Lotes por Finca","text":"<p>Lista todos los lotes de una finca espec\u00edfica.</p> <p>Parameters:</p> Name Type Description Default <code>farm_id</code> <code>int</code> <p>ID de la finca.</p> required <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina.</p> <code>Query(1, ge=1, description='Page number')</code> <code>per_page</code> <code>int</code> <p>Elementos por p\u00e1gina.</p> <code>Query(10, ge=1, le=100, description='Items per page')</code> <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>PaginatedPlotListResponse</code> <code>PaginatedPlotListResponse</code> <p>Una lista paginada de lotes.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la obtenci\u00f3n de la lista de lotes.</p> Source code in <code>app\\plot\\infrastructure\\api.py</code> <pre><code>@router.get(\"/farm/{farm_id}/plot/list\", response_model=PaginatedPlotListResponse, status_code=status.HTTP_200_OK)\ndef list_plots_by_farm(\n    farm_id: int,\n    page: int = Query(1, ge=1, description=\"Page number\"),\n    per_page: int = Query(10, ge=1, le=100, description=\"Items per page\"),\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n)-&gt; PaginatedPlotListResponse:\n    \"\"\"\n    Lista todos los lotes de una finca espec\u00edfica.\n\n    Parameters:\n        farm_id (int): ID de la finca.\n        page (int): N\u00famero de p\u00e1gina.\n        per_page (int): Elementos por p\u00e1gina.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        PaginatedPlotListResponse: Una lista paginada de lotes.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la obtenci\u00f3n de la lista de lotes.\n    \"\"\"\n    list_plots_use_case = ListPlotsUseCase(db)\n    try:\n        return list_plots_use_case.list_plots(current_user, farm_id, page, per_page)\n    except DomainException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al listar los lotes: {str(e)}\"\n        )\n</code></pre> <p>Endpoint para obtener una lista paginada de los lotes pertenecientes a una finca.</p>"},{"location":"plot/endpoints/#estructura-de-rutas","title":"Estructura de Rutas","text":"<p>El m\u00f3dulo de lotes utiliza el prefijo <code>/plot</code> para todos sus endpoints y est\u00e1 etiquetado como \"plot\" en la documentaci\u00f3n de la API.</p>"},{"location":"plot/endpoints/#autenticacion-y-autorizacion","title":"Autenticaci\u00f3n y Autorizaci\u00f3n","text":"<p>Todos los endpoints requieren autenticaci\u00f3n mediante JWT y verifican los permisos del usuario sobre la finca a la que pertenece el lote.</p>"},{"location":"plot/models/","title":"Modelos del M\u00f3dulo de Lotes","text":"<p>Este documento describe los modelos utilizados para la gesti\u00f3n de lotes en el sistema AgroInsight.</p>"},{"location":"plot/models/#modelos-de-base-de-datos","title":"Modelos de Base de Datos","text":""},{"location":"plot/models/#lote-plot","title":"Lote (Plot)","text":"<p>               Bases: <code>Base</code></p> <p>Modelo ORM que representa un lote en el sistema.</p> <p>Esta clase define la estructura y relaciones de la tabla 'lote' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del lote.</p> <code>nombre</code> <code>str</code> <p>Nombre del lote. Debe tener un m\u00e1ximo de 100 caracteres.</p> <code>area</code> <code>Decimal</code> <p>\u00c1rea del lote. Debe ser un valor positivo con precisi\u00f3n de 2 decimales.</p> <code>unidad_area_id</code> <code>int</code> <p>Clave for\u00e1nea que referencia la unidad de medida del \u00e1rea.</p> <code>latitud</code> <code>Decimal</code> <p>Latitud del lote con precisi\u00f3n de 8 decimales.</p> <code>longitud</code> <code>Decimal</code> <p>Longitud del lote con precisi\u00f3n de 8 decimales.</p> <code>finca_id</code> <code>int</code> <p>Clave for\u00e1nea que referencia la finca a la que pertenece el lote.</p> <code>unidad_area</code> <code>UnitOfMeasure</code> <p>Relaci\u00f3n con la unidad de medida del \u00e1rea.</p> <code>finca</code> <code>Farm</code> <p>Relaci\u00f3n con la finca a la que pertenece el lote.</p> <code>tareas</code> <code>List[CulturalTask]</code> <p>Relaci\u00f3n con las tareas culturales asociadas al lote.</p> <code>cultivos</code> <code>List[Crop]</code> <p>Relaci\u00f3n con los cultivos asociados al lote.</p> Source code in <code>app\\plot\\infrastructure\\orm_models.py</code> <pre><code>class Plot(Base):\n    \"\"\"Modelo ORM que representa un lote en el sistema.\n\n    Esta clase define la estructura y relaciones de la tabla 'lote' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del lote.\n        nombre (str): Nombre del lote. Debe tener un m\u00e1ximo de 100 caracteres.\n        area (Decimal): \u00c1rea del lote. Debe ser un valor positivo con precisi\u00f3n de 2 decimales.\n        unidad_area_id (int): Clave for\u00e1nea que referencia la unidad de medida del \u00e1rea.\n        latitud (Decimal): Latitud del lote con precisi\u00f3n de 8 decimales.\n        longitud (Decimal): Longitud del lote con precisi\u00f3n de 8 decimales.\n        finca_id (int): Clave for\u00e1nea que referencia la finca a la que pertenece el lote.\n        unidad_area (UnitOfMeasure): Relaci\u00f3n con la unidad de medida del \u00e1rea.\n        finca (Farm): Relaci\u00f3n con la finca a la que pertenece el lote.\n        tareas (List[CulturalTask]): Relaci\u00f3n con las tareas culturales asociadas al lote.\n        cultivos (List[Crop]): Relaci\u00f3n con los cultivos asociados al lote.\n    \"\"\"\n\n    __tablename__ = \"lote\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(100), nullable=False)\n    area = Column(DECIMAL(10, 2), nullable=False)\n    unidad_area_id = Column(Integer, ForeignKey('unidad_medida.id'), nullable=False)\n    latitud = Column(DECIMAL(10, 8), nullable=False)\n    longitud = Column(DECIMAL(11, 8), nullable=False)\n    finca_id = Column(Integer, ForeignKey('finca.id'), nullable=False)\n\n    unidad_area = relationship(\"UnitOfMeasure\")\n    finca = relationship(\"Farm\", back_populates=\"lotes\")\n    registros_meteorologicos = relationship(\"WeatherLog\", back_populates=\"lote\")\n    tareas = relationship(\"CulturalTask\", back_populates=\"lote\")\n    cultivos = relationship(\"Crop\", back_populates=\"lote\")\n</code></pre> <p>Modelo principal que representa un lote o parcela agr\u00edcola dentro de una finca.</p>"},{"location":"plot/models/#esquemas-de-datos","title":"Esquemas de Datos","text":""},{"location":"plot/models/#crear-lote","title":"Crear Lote","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para la creaci\u00f3n de un nuevo lote.</p> <p>Este modelo define los datos necesarios para crear un lote en el sistema.</p> <p>Attributes:</p> Name Type Description <code>nombre</code> <code>str</code> <p>Nombre del lote. Debe tener entre 1 y 100 caracteres.</p> <code>area</code> <code>Decimal</code> <p>\u00c1rea del lote. Debe ser un valor positivo.</p> <code>unidad_area_id</code> <code>int</code> <p>ID de la unidad de medida del \u00e1rea.</p> <code>latitud</code> <code>Decimal</code> <p>Latitud del lote. Debe estar entre -90 y 90.</p> <code>longitud</code> <code>Decimal</code> <p>Longitud del lote. Debe estar entre -180 y 180.</p> <code>finca_id</code> <code>int</code> <p>ID de la finca a la que pertenece el lote.</p> Source code in <code>app\\plot\\domain\\schemas.py</code> <pre><code>class PlotCreate(BaseModel):\n    \"\"\"Schema para la creaci\u00f3n de un nuevo lote.\n\n    Este modelo define los datos necesarios para crear un lote en el sistema.\n\n    Attributes:\n        nombre (str): Nombre del lote. Debe tener entre 1 y 100 caracteres.\n        area (Decimal): \u00c1rea del lote. Debe ser un valor positivo.\n        unidad_area_id (int): ID de la unidad de medida del \u00e1rea.\n        latitud (Decimal): Latitud del lote. Debe estar entre -90 y 90.\n        longitud (Decimal): Longitud del lote. Debe estar entre -180 y 180.\n        finca_id (int): ID de la finca a la que pertenece el lote.\n    \"\"\"\n    nombre: str = Field(..., min_length=1, max_length=100)\n    area: Decimal = Field(..., gt=0)\n    unidad_area_id: int\n    latitud: Decimal = Field(..., ge=-90, le=90)\n    longitud: Decimal = Field(..., ge=-180, le=180)\n    finca_id: int\n\n    @field_validator('nombre')\n    def validate_no_emojis_nombre(cls: Type['PlotCreate'], v: str) -&gt; str:\n        \"\"\"Valida que el nombre no contenga emojis.\n\n        Args:\n            cls: Clase del validador.\n            v (str): Valor del nombre a validar.\n\n        Returns:\n            str: El valor validado.\n\n        Raises:\n            ValueError: Si el nombre contiene emojis.\n        \"\"\"\n        return validate_no_emojis(v)\n\n    @field_validator('nombre')\n    def validate_no_special_chars_nombre(cls: Type['PlotCreate'], v: str) -&gt; str:\n        \"\"\"Valida que el nombre no contenga caracteres especiales.\n\n        Args:\n            cls: Clase del validador.\n            v (str): Valor del nombre a validar.\n\n        Returns:\n            str: El valor validado.\n\n        Raises:\n            ValueError: Si el nombre contiene caracteres especiales.\n        \"\"\"\n        return validate_no_special_chars(v)\n\n    @field_validator('nombre')\n    def validate_no_xss_nombre(cls: Type['PlotCreate'], v: str) -&gt; str:\n        \"\"\"Valida que el nombre no contenga XSS.\n\n        Args:\n            cls: Clase del validador.\n            v (str): Valor del nombre a validar.\n\n        Returns:\n            str: El valor validado.\n\n        Raises:\n            ValueError: Si el nombre contiene XSS.\n        \"\"\"\n        return validate_no_xss(v)\n</code></pre> <p>Esquema para la creaci\u00f3n de nuevos lotes.</p>"},{"location":"plot/models/#app.plot.domain.schemas.PlotCreate.validate_no_emojis_nombre","title":"<code>validate_no_emojis_nombre(v)</code>","text":"<p>Valida que el nombre no contenga emojis.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[PlotCreate]</code> <p>Clase del validador.</p> required <code>v</code> <code>str</code> <p>Valor del nombre a validar.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>El valor validado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Si el nombre contiene emojis.</p> Source code in <code>app\\plot\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_no_emojis_nombre(cls: Type['PlotCreate'], v: str) -&gt; str:\n    \"\"\"Valida que el nombre no contenga emojis.\n\n    Args:\n        cls: Clase del validador.\n        v (str): Valor del nombre a validar.\n\n    Returns:\n        str: El valor validado.\n\n    Raises:\n        ValueError: Si el nombre contiene emojis.\n    \"\"\"\n    return validate_no_emojis(v)\n</code></pre>"},{"location":"plot/models/#app.plot.domain.schemas.PlotCreate.validate_no_special_chars_nombre","title":"<code>validate_no_special_chars_nombre(v)</code>","text":"<p>Valida que el nombre no contenga caracteres especiales.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[PlotCreate]</code> <p>Clase del validador.</p> required <code>v</code> <code>str</code> <p>Valor del nombre a validar.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>El valor validado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Si el nombre contiene caracteres especiales.</p> Source code in <code>app\\plot\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_no_special_chars_nombre(cls: Type['PlotCreate'], v: str) -&gt; str:\n    \"\"\"Valida que el nombre no contenga caracteres especiales.\n\n    Args:\n        cls: Clase del validador.\n        v (str): Valor del nombre a validar.\n\n    Returns:\n        str: El valor validado.\n\n    Raises:\n        ValueError: Si el nombre contiene caracteres especiales.\n    \"\"\"\n    return validate_no_special_chars(v)\n</code></pre>"},{"location":"plot/models/#app.plot.domain.schemas.PlotCreate.validate_no_xss_nombre","title":"<code>validate_no_xss_nombre(v)</code>","text":"<p>Valida que el nombre no contenga XSS.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[PlotCreate]</code> <p>Clase del validador.</p> required <code>v</code> <code>str</code> <p>Valor del nombre a validar.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>El valor validado.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Si el nombre contiene XSS.</p> Source code in <code>app\\plot\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_no_xss_nombre(cls: Type['PlotCreate'], v: str) -&gt; str:\n    \"\"\"Valida que el nombre no contenga XSS.\n\n    Args:\n        cls: Clase del validador.\n        v (str): Valor del nombre a validar.\n\n    Returns:\n        str: El valor validado.\n\n    Raises:\n        ValueError: Si el nombre contiene XSS.\n    \"\"\"\n    return validate_no_xss(v)\n</code></pre>"},{"location":"plot/models/#respuesta-de-lote","title":"Respuesta de Lote","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para la respuesta con informaci\u00f3n de un lote.</p> <p>Este modelo define la estructura de la respuesta que incluye los detalles de un lote.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del lote.</p> <code>nombre</code> <code>str</code> <p>Nombre del lote.</p> <code>area</code> <code>Decimal</code> <p>\u00c1rea del lote.</p> <code>unidad_area</code> <code>str</code> <p>Unidad de medida del \u00e1rea.</p> <code>latitud</code> <code>Decimal</code> <p>Latitud del lote.</p> <code>longitud</code> <code>Decimal</code> <p>Longitud del lote.</p> <code>finca_id</code> <code>int</code> <p>ID de la finca a la que pertenece el lote.</p> Source code in <code>app\\plot\\domain\\schemas.py</code> <pre><code>class PlotResponse(BaseModel):\n    \"\"\"Schema para la respuesta con informaci\u00f3n de un lote.\n\n    Este modelo define la estructura de la respuesta que incluye los detalles de un lote.\n\n    Attributes:\n        id (int): Identificador \u00fanico del lote.\n        nombre (str): Nombre del lote.\n        area (Decimal): \u00c1rea del lote.\n        unidad_area (str): Unidad de medida del \u00e1rea.\n        latitud (Decimal): Latitud del lote.\n        longitud (Decimal): Longitud del lote.\n        finca_id (int): ID de la finca a la que pertenece el lote.\n    \"\"\"\n    id: int\n    nombre: str\n    area: Decimal\n    unidad_area: str\n    latitud: Decimal\n    longitud: Decimal\n    finca_id: int\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre> <p>Esquema para la respuesta con informaci\u00f3n de un lote.</p>"},{"location":"plot/models/#respuesta-paginada-de-lotes","title":"Respuesta Paginada de Lotes","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema para la respuesta paginada de lista de lotes.</p> <p>Este modelo define la estructura de la respuesta que incluye una lista de lotes y la informaci\u00f3n de paginaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>plots</code> <code>List[PlotResponse]</code> <p>Lista de lotes para la p\u00e1gina actual.</p> <code>total_plots</code> <code>int</code> <p>N\u00famero total de lotes.</p> <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina actual.</p> <code>per_page</code> <code>int</code> <p>Cantidad de elementos por p\u00e1gina.</p> <code>total_pages</code> <code>int</code> <p>N\u00famero total de p\u00e1ginas.</p> Source code in <code>app\\plot\\domain\\schemas.py</code> <pre><code>class PaginatedPlotListResponse(BaseModel):\n    \"\"\"Schema para la respuesta paginada de lista de lotes.\n\n    Este modelo define la estructura de la respuesta que incluye una lista de lotes\n    y la informaci\u00f3n de paginaci\u00f3n.\n\n    Attributes:\n        plots (List[PlotResponse]): Lista de lotes para la p\u00e1gina actual.\n        total_plots (int): N\u00famero total de lotes.\n        page (int): N\u00famero de p\u00e1gina actual.\n        per_page (int): Cantidad de elementos por p\u00e1gina.\n        total_pages (int): N\u00famero total de p\u00e1ginas.\n    \"\"\"\n    plots: List[PlotResponse]\n    total_plots: int\n    page: int\n    per_page: int\n    total_pages: int\n</code></pre> <p>Esquema para la respuesta paginada de listas de lotes.</p>"},{"location":"plot/models/#relaciones","title":"Relaciones","text":"<p>Los lotes mantienen relaciones con:</p> <ul> <li>Fincas (Farm): Relaci\u00f3n padre-hijo</li> <li>Cultivos (Crop): Relaci\u00f3n uno a muchos</li> <li>Pr\u00e1cticas Culturales (CulturalTask): Relaci\u00f3n uno a muchos</li> </ul>"},{"location":"plot/overview/","title":"Visi\u00f3n General del M\u00f3dulo de Lotes","text":""},{"location":"plot/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>El m\u00f3dulo de Lotes (Plot) es un componente esencial del sistema AgroInsight que gestiona la informaci\u00f3n y operaciones relacionadas con las parcelas o lotes agr\u00edcolas dentro de una finca. Este m\u00f3dulo permite la organizaci\u00f3n espacial de los cultivos y sirve como base para el seguimiento de las actividades agr\u00edcolas.</p>"},{"location":"plot/overview/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"plot/overview/#1-gestion-de-lotes","title":"1. Gesti\u00f3n de Lotes","text":"<ul> <li>Creaci\u00f3n y administraci\u00f3n de lotes</li> <li>Registro de caracter\u00edsticas del terreno</li> <li>Asignaci\u00f3n a fincas espec\u00edficas</li> <li>Seguimiento del estado del lote</li> </ul>"},{"location":"plot/overview/#2-informacion-geografica","title":"2. Informaci\u00f3n Geogr\u00e1fica","text":"<ul> <li>Registro de \u00e1rea y dimensiones</li> <li>Ubicaci\u00f3n dentro de la finca</li> <li>Caracter\u00edsticas del suelo</li> <li>Topograf\u00eda y orientaci\u00f3n</li> </ul>"},{"location":"plot/overview/#3-integracion-con-cultivos","title":"3. Integraci\u00f3n con Cultivos","text":"<ul> <li>Historial de cultivos por lote</li> <li>Estado actual de uso</li> <li>Planificaci\u00f3n de rotaci\u00f3n de cultivos</li> <li>Capacidad productiva</li> </ul>"},{"location":"plot/overview/#4-practicas-culturales","title":"4. Pr\u00e1cticas Culturales","text":"<ul> <li>Registro de labores agr\u00edcolas por lote</li> <li>Seguimiento de actividades</li> <li>Asignaci\u00f3n de tareas</li> <li>Control de intervenciones</li> </ul>"},{"location":"plot/overview/#integracion-con-otros-modulos","title":"Integraci\u00f3n con Otros M\u00f3dulos","text":"<p>El m\u00f3dulo de Lotes se integra estrechamente con:</p> <ul> <li>M\u00f3dulo de Fincas: Para la organizaci\u00f3n jer\u00e1rquica de la propiedad</li> <li>M\u00f3dulo de Cultivos: Para el registro y seguimiento de la producci\u00f3n</li> <li>M\u00f3dulo de Pr\u00e1cticas Culturales: Para la gesti\u00f3n de labores agr\u00edcolas</li> <li>M\u00f3dulo de Mediciones: Para el registro de datos espec\u00edficos del lote</li> </ul>"},{"location":"plot/overview/#casos-de-uso-comunes","title":"Casos de Uso Comunes","text":"<ol> <li>Registro de nuevo lote</li> <li>Asignaci\u00f3n de cultivos</li> <li>Planificaci\u00f3n de labores culturales</li> <li>Consulta de historial de uso</li> <li>An\u00e1lisis de productividad</li> </ol>"},{"location":"plot/overview/#estructura-tecnica","title":"Estructura T\u00e9cnica","text":"<p>El m\u00f3dulo sigue una arquitectura limpia con:</p> <ul> <li>Domain: Definici\u00f3n de entidades y reglas de negocio</li> <li>Application: Implementaci\u00f3n de casos de uso</li> <li>Infrastructure: Acceso a datos y servicios externos</li> </ul>"},{"location":"plot/overview/#beneficios","title":"Beneficios","text":"<ul> <li>Organizaci\u00f3n eficiente del espacio agr\u00edcola</li> <li>Mejor planificaci\u00f3n de cultivos</li> <li>Seguimiento detallado de actividades</li> <li>Optimizaci\u00f3n de recursos</li> <li>Toma de decisiones informada</li> </ul>"},{"location":"plot/overview/#documentacion-relacionada","title":"Documentaci\u00f3n Relacionada","text":"<ul> <li>Endpoints de Lotes</li> <li>Modelos de Datos</li> <li>Casos de Uso</li> </ul>"},{"location":"plot/use_cases/","title":"Casos de Uso del M\u00f3dulo de Lotes","text":"<p>Este documento describe los casos de uso relacionados con la gesti\u00f3n de lotes en el sistema AgroInsight.</p>"},{"location":"plot/use_cases/#gestion-de-lotes","title":"Gesti\u00f3n de Lotes","text":""},{"location":"plot/use_cases/#caso-de-uso-creacion-de-lote","title":"Caso de Uso: Creaci\u00f3n de Lote","text":"<p>Caso de uso para crear un nuevo lote.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para crear un lote en una finca, incluyendo validaciones de permisos y existencia de recursos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>plot_repository</code> <code>PlotRepository</code> <p>Repositorio para operaciones con lotes.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> <code>measurement_service</code> <code>MeasurementService</code> <p>Servicio para l\u00f3gica de negocio de medidas.</p> <code>measurement_repository</code> <code>MeasurementRepository</code> <p>Repositorio para operaciones con medidas.</p> Source code in <code>app\\plot\\application\\create_plot_use_case.py</code> <pre><code>class CreatePlotUseCase:\n    \"\"\"Caso de uso para crear un nuevo lote.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para crear un lote en una finca,\n    incluyendo validaciones de permisos y existencia de recursos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        plot_repository (PlotRepository): Repositorio para operaciones con lotes.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n        measurement_service (MeasurementService): Servicio para l\u00f3gica de negocio de medidas.\n        measurement_repository (MeasurementRepository): Repositorio para operaciones con medidas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.plot_repository = PlotRepository(db)\n        self.farm_repository = FarmRepository(db)\n        self.farm_service = FarmService(db)\n        self.measurement_service = MeasurementService(db)\n        self.measurement_repository = MeasurementRepository(db)\n\n    def create_plot(self, plot_data: PlotCreate, current_user: UserInDB) -&gt; SuccessResponse:\n        \"\"\"Crea un nuevo lote en la base de datos.\n\n        Este m\u00e9todo realiza las siguientes validaciones antes de crear el lote:\n        1. Verifica que la unidad de medida exista.\n        2. Confirma que la unidad de medida sea de tipo \u00e1rea.\n        3. Verifica que la finca exista.\n        4. Valida que el usuario tenga permisos para crear lotes en la finca.\n        5. Asegura que no exista un lote con el mismo nombre en la finca.\n        6. Comprueba que el \u00e1rea del lote no exceda el \u00e1rea total de la finca.\n\n        Args:\n            plot_data (PlotCreate): Datos del lote a crear.\n            current_user (UserInDB): Usuario que est\u00e1 creando el lote.\n\n        Returns:\n            SuccessResponse: Respuesta exitosa con un mensaje de confirmaci\u00f3n.\n\n        Raises:\n            DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n                - 404: La unidad de medida o la finca no existen.\n                - 400: La unidad de medida no es de \u00e1rea o el \u00e1rea del lote excede la del finca.\n                - 403: El usuario no tiene permisos para crear lotes en la finca.\n                - 409: Ya existe un lote con el mismo nombre en la finca.\n                - 500: Error al crear el lote.\n        \"\"\"\n        # Validar que la unidad de area exista\n        unit_of_measure = self.measurement_repository.get_unit_of_measure_by_id(plot_data.unidad_area_id)\n        if not unit_of_measure:\n            raise DomainException(\n                message=\"La unidad de medida no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # validar que la unidad de medida sea de area\n        if self.measurement_repository.get_unit_category_by_id(unit_of_measure.categoria_id).nombre != self.measurement_service.UNIT_CATEGORY_AREA_NAME:\n            raise DomainException(\n                message=\"La unidad de medida no es de \u00e1rea.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        # validar que la finca exista\n        farm = self.farm_repository.get_farm_by_id(plot_data.finca_id)\n        if not farm:\n            raise DomainException(\n                message=\"La finca no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Validar si el usuario tiene permiso para crear lotes en la finca\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n            raise DomainException(\n                message=\"No tienes permisos para crear lotes en esta finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # Verificar si ya existe un lote con el mismo nombre en la misma finca\n        existing_plot = self.plot_repository.get_plot_by_name_and_farm(plot_data.nombre, farm.id)\n        if existing_plot:\n            raise DomainException(\n                message=\"Ya existe un lote con este nombre en la finca.\",\n                status_code=status.HTTP_409_CONFLICT\n            )\n\n        # validar que el area del lote que se quiere crear no exceda el area de la finca\n        if plot_data.area &gt; farm.area_total:\n            raise DomainException(\n                message=\"El \u00e1rea del lote que se quiere crear no puede ser mayor al \u00e1rea de la finca.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        # Crear el lote\n        plot = self.plot_repository.create_plot(plot_data)\n        if not plot:\n            raise DomainException(\n                message=\"No se pudo crear el lote.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessResponse(message=\"Lote creado exitosamente\")\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para la creaci\u00f3n de nuevos lotes, incluyendo:</p> <ul> <li>Validaci\u00f3n de permisos del usuario</li> <li>Verificaci\u00f3n de la existencia de la finca</li> <li>Validaci\u00f3n de datos del lote</li> <li>Creaci\u00f3n del registro en la base de datos</li> </ul>"},{"location":"plot/use_cases/#app.plot.application.create_plot_use_case.CreatePlotUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\plot\\application\\create_plot_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.plot_repository = PlotRepository(db)\n    self.farm_repository = FarmRepository(db)\n    self.farm_service = FarmService(db)\n    self.measurement_service = MeasurementService(db)\n    self.measurement_repository = MeasurementRepository(db)\n</code></pre>"},{"location":"plot/use_cases/#app.plot.application.create_plot_use_case.CreatePlotUseCase.create_plot","title":"<code>create_plot(plot_data, current_user)</code>","text":"<p>Crea un nuevo lote en la base de datos.</p> <p>Este m\u00e9todo realiza las siguientes validaciones antes de crear el lote: 1. Verifica que la unidad de medida exista. 2. Confirma que la unidad de medida sea de tipo \u00e1rea. 3. Verifica que la finca exista. 4. Valida que el usuario tenga permisos para crear lotes en la finca. 5. Asegura que no exista un lote con el mismo nombre en la finca. 6. Comprueba que el \u00e1rea del lote no exceda el \u00e1rea total de la finca.</p> <p>Parameters:</p> Name Type Description Default <code>plot_data</code> <code>PlotCreate</code> <p>Datos del lote a crear.</p> required <code>current_user</code> <code>UserInDB</code> <p>Usuario que est\u00e1 creando el lote.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta exitosa con un mensaje de confirmaci\u00f3n.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre alg\u00fan error de validaci\u00f3n: - 404: La unidad de medida o la finca no existen. - 400: La unidad de medida no es de \u00e1rea o el \u00e1rea del lote excede la del finca. - 403: El usuario no tiene permisos para crear lotes en la finca. - 409: Ya existe un lote con el mismo nombre en la finca. - 500: Error al crear el lote.</p> Source code in <code>app\\plot\\application\\create_plot_use_case.py</code> <pre><code>def create_plot(self, plot_data: PlotCreate, current_user: UserInDB) -&gt; SuccessResponse:\n    \"\"\"Crea un nuevo lote en la base de datos.\n\n    Este m\u00e9todo realiza las siguientes validaciones antes de crear el lote:\n    1. Verifica que la unidad de medida exista.\n    2. Confirma que la unidad de medida sea de tipo \u00e1rea.\n    3. Verifica que la finca exista.\n    4. Valida que el usuario tenga permisos para crear lotes en la finca.\n    5. Asegura que no exista un lote con el mismo nombre en la finca.\n    6. Comprueba que el \u00e1rea del lote no exceda el \u00e1rea total de la finca.\n\n    Args:\n        plot_data (PlotCreate): Datos del lote a crear.\n        current_user (UserInDB): Usuario que est\u00e1 creando el lote.\n\n    Returns:\n        SuccessResponse: Respuesta exitosa con un mensaje de confirmaci\u00f3n.\n\n    Raises:\n        DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n            - 404: La unidad de medida o la finca no existen.\n            - 400: La unidad de medida no es de \u00e1rea o el \u00e1rea del lote excede la del finca.\n            - 403: El usuario no tiene permisos para crear lotes en la finca.\n            - 409: Ya existe un lote con el mismo nombre en la finca.\n            - 500: Error al crear el lote.\n    \"\"\"\n    # Validar que la unidad de area exista\n    unit_of_measure = self.measurement_repository.get_unit_of_measure_by_id(plot_data.unidad_area_id)\n    if not unit_of_measure:\n        raise DomainException(\n            message=\"La unidad de medida no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # validar que la unidad de medida sea de area\n    if self.measurement_repository.get_unit_category_by_id(unit_of_measure.categoria_id).nombre != self.measurement_service.UNIT_CATEGORY_AREA_NAME:\n        raise DomainException(\n            message=\"La unidad de medida no es de \u00e1rea.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # validar que la finca exista\n    farm = self.farm_repository.get_farm_by_id(plot_data.finca_id)\n    if not farm:\n        raise DomainException(\n            message=\"La finca no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Validar si el usuario tiene permiso para crear lotes en la finca\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm.id):\n        raise DomainException(\n            message=\"No tienes permisos para crear lotes en esta finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    # Verificar si ya existe un lote con el mismo nombre en la misma finca\n    existing_plot = self.plot_repository.get_plot_by_name_and_farm(plot_data.nombre, farm.id)\n    if existing_plot:\n        raise DomainException(\n            message=\"Ya existe un lote con este nombre en la finca.\",\n            status_code=status.HTTP_409_CONFLICT\n        )\n\n    # validar que el area del lote que se quiere crear no exceda el area de la finca\n    if plot_data.area &gt; farm.area_total:\n        raise DomainException(\n            message=\"El \u00e1rea del lote que se quiere crear no puede ser mayor al \u00e1rea de la finca.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Crear el lote\n    plot = self.plot_repository.create_plot(plot_data)\n    if not plot:\n        raise DomainException(\n            message=\"No se pudo crear el lote.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(message=\"Lote creado exitosamente\")\n</code></pre>"},{"location":"plot/use_cases/#caso-de-uso-listar-lotes-por-finca","title":"Caso de Uso: Listar Lotes por Finca","text":"<p>Caso de uso para listar los lotes de una finca.</p> <p>Esta clase maneja la l\u00f3gica de negocio necesaria para obtener una lista paginada de los lotes que pertenecen a una finca espec\u00edfica, asegurando que el usuario tenga los permisos adecuados.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> <code>plot_repository</code> <code>PlotRepository</code> <p>Repositorio para operaciones con lotes.</p> <code>farm_repository</code> <code>FarmRepository</code> <p>Repositorio para operaciones con fincas.</p> <code>farm_service</code> <code>FarmService</code> <p>Servicio para l\u00f3gica de negocio de fincas.</p> Source code in <code>app\\plot\\application\\list_plots_use_case.py</code> <pre><code>class ListPlotsUseCase:\n    \"\"\"Caso de uso para listar los lotes de una finca.\n\n    Esta clase maneja la l\u00f3gica de negocio necesaria para obtener una lista paginada\n    de los lotes que pertenecen a una finca espec\u00edfica, asegurando que el usuario\n    tenga los permisos adecuados.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        plot_repository (PlotRepository): Repositorio para operaciones con lotes.\n        farm_repository (FarmRepository): Repositorio para operaciones con fincas.\n        farm_service (FarmService): Servicio para l\u00f3gica de negocio de fincas.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n        \"\"\"\n        self.db = db\n        self.plot_repository = PlotRepository(db)\n        self.farm_repository = FarmRepository(db)\n        self.farm_service = FarmService(db)\n\n    def list_plots(self, current_user: UserInDB, farm_id: int, page: int, per_page: int) -&gt; PaginatedPlotListResponse:\n        \"\"\"Lista los lotes de una finca de forma paginada.\n\n        Este m\u00e9todo realiza las siguientes validaciones:\n        1. Verifica que la finca especificada exista.\n        2. Confirma que el usuario actual tenga permisos de administrador en la finca.\n\n        Args:\n            current_user (UserInDB): Usuario que est\u00e1 solicitando la lista de lotes.\n            farm_id (int): ID de la finca de la cual se quieren listar los lotes.\n            page (int): N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.\n            per_page (int): Cantidad de lotes por p\u00e1gina.\n\n        Returns:\n            PaginatedPlotListResponse: Respuesta paginada que incluye:\n                - Lista de lotes para la p\u00e1gina actual.\n                - Total de lotes.\n                - N\u00famero de p\u00e1gina actual.\n                - Cantidad de elementos por p\u00e1gina.\n                - Total de p\u00e1ginas.\n\n        Raises:\n            DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n                - 404: La finca especificada no existe.\n                - 403: El usuario no tiene permisos para obtener informaci\u00f3n de los lotes de la finca.\n        \"\"\"\n        farm = self.farm_repository.get_farm_by_id(farm_id)\n        if not farm:\n            raise DomainException(\n                message=\"La finca especificada no existe.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n            raise DomainException(\n                message=\"No tienes permisos para obtener informaci\u00f3n de los lotes de esta finca.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        total_plots, plots = self.plot_repository.list_plots_by_farm_paginated(farm_id, page, per_page)\n\n        # Usar la funci\u00f3n de mapeo para construir PlotResponse para cada lote\n        plot_responses = [map_plot_to_response(plot) for plot in plots]\n\n        total_pages = ceil(total_plots / per_page)\n\n        return PaginatedPlotListResponse(\n            plots=plot_responses,\n            total_plots=total_plots,\n            page=page,\n            per_page=per_page,\n            total_pages=total_pages\n        )\n</code></pre> <p>Este caso de uso gestiona la obtenci\u00f3n paginada de lotes pertenecientes a una finca espec\u00edfica.</p>"},{"location":"plot/use_cases/#app.plot.application.list_plots_use_case.ListPlotsUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa el caso de uso con las dependencias necesarias.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\plot\\application\\list_plots_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"Inicializa el caso de uso con las dependencias necesarias.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n    self.plot_repository = PlotRepository(db)\n    self.farm_repository = FarmRepository(db)\n    self.farm_service = FarmService(db)\n</code></pre>"},{"location":"plot/use_cases/#app.plot.application.list_plots_use_case.ListPlotsUseCase.list_plots","title":"<code>list_plots(current_user, farm_id, page, per_page)</code>","text":"<p>Lista los lotes de una finca de forma paginada.</p> <p>Este m\u00e9todo realiza las siguientes validaciones: 1. Verifica que la finca especificada exista. 2. Confirma que el usuario actual tenga permisos de administrador en la finca.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario que est\u00e1 solicitando la lista de lotes.</p> required <code>farm_id</code> <code>int</code> <p>ID de la finca de la cual se quieren listar los lotes.</p> required <code>page</code> <code>int</code> <p>N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.</p> required <code>per_page</code> <code>int</code> <p>Cantidad de lotes por p\u00e1gina.</p> required <p>Returns:</p> Name Type Description <code>PaginatedPlotListResponse</code> <code>PaginatedPlotListResponse</code> <p>Respuesta paginada que incluye: - Lista de lotes para la p\u00e1gina actual. - Total de lotes. - N\u00famero de p\u00e1gina actual. - Cantidad de elementos por p\u00e1gina. - Total de p\u00e1ginas.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre alg\u00fan error de validaci\u00f3n: - 404: La finca especificada no existe. - 403: El usuario no tiene permisos para obtener informaci\u00f3n de los lotes de la finca.</p> Source code in <code>app\\plot\\application\\list_plots_use_case.py</code> <pre><code>def list_plots(self, current_user: UserInDB, farm_id: int, page: int, per_page: int) -&gt; PaginatedPlotListResponse:\n    \"\"\"Lista los lotes de una finca de forma paginada.\n\n    Este m\u00e9todo realiza las siguientes validaciones:\n    1. Verifica que la finca especificada exista.\n    2. Confirma que el usuario actual tenga permisos de administrador en la finca.\n\n    Args:\n        current_user (UserInDB): Usuario que est\u00e1 solicitando la lista de lotes.\n        farm_id (int): ID de la finca de la cual se quieren listar los lotes.\n        page (int): N\u00famero de p\u00e1gina actual para la paginaci\u00f3n.\n        per_page (int): Cantidad de lotes por p\u00e1gina.\n\n    Returns:\n        PaginatedPlotListResponse: Respuesta paginada que incluye:\n            - Lista de lotes para la p\u00e1gina actual.\n            - Total de lotes.\n            - N\u00famero de p\u00e1gina actual.\n            - Cantidad de elementos por p\u00e1gina.\n            - Total de p\u00e1ginas.\n\n    Raises:\n        DomainException: Si ocurre alg\u00fan error de validaci\u00f3n:\n            - 404: La finca especificada no existe.\n            - 403: El usuario no tiene permisos para obtener informaci\u00f3n de los lotes de la finca.\n    \"\"\"\n    farm = self.farm_repository.get_farm_by_id(farm_id)\n    if not farm:\n        raise DomainException(\n            message=\"La finca especificada no existe.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if not self.farm_service.user_is_farm_admin(current_user.id, farm_id):\n        raise DomainException(\n            message=\"No tienes permisos para obtener informaci\u00f3n de los lotes de esta finca.\",\n            status_code=status.HTTP_403_FORBIDDEN\n        )\n\n    total_plots, plots = self.plot_repository.list_plots_by_farm_paginated(farm_id, page, per_page)\n\n    # Usar la funci\u00f3n de mapeo para construir PlotResponse para cada lote\n    plot_responses = [map_plot_to_response(plot) for plot in plots]\n\n    total_pages = ceil(total_plots / per_page)\n\n    return PaginatedPlotListResponse(\n        plots=plot_responses,\n        total_plots=total_plots,\n        page=page,\n        per_page=per_page,\n        total_pages=total_pages\n    )\n</code></pre>"},{"location":"user/endpoints/","title":"Endpoints de Usuario","text":"<p>Este documento describe los endpoints disponibles para la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/endpoints/#autenticacion-y-autorizacion","title":"Autenticaci\u00f3n y Autorizaci\u00f3n","text":""},{"location":"user/endpoints/#registro-de-usuario","title":"Registro de Usuario","text":"<p>Registra un nuevo usuario en el sistema.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserCreate</code> <p>Datos del usuario a registrar.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto con mensaje de \u00e9xito.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el registro.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/register\", response_model=SuccessResponse, status_code=status.HTTP_201_CREATED)\ndef register_user(\n    user: UserCreate,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb),\n) -&gt; SuccessResponse:\n    \"\"\"\n    Registra un nuevo usuario en el sistema.\n\n    Args:\n        user (UserCreate): Datos del usuario a registrar.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto con mensaje de \u00e9xito.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el registro.\n    \"\"\"\n    creation_use_case = UserRegisterUseCase(db)\n    # Llamamos al caso de uso sin manejar excepciones aqu\u00ed\n    try:\n        return creation_use_case.register_user(user, background_tasks)\n    except (DomainException, UserStateException) as e:\n        # Permite que los manejadores de excepciones globales de FastAPI manejen las excepciones\n        raise e\n    except Exception as e:\n        # Para cualquier otra excepci\u00f3n no esperada, lanza un error HTTP 500 gen\u00e9rico\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno en el registro de usuario: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#confirmacion-de-registro","title":"Confirmaci\u00f3n de Registro","text":"<p>Confirma el registro de un usuario utilizando un PIN.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>ConfirmationRequest</code> <p>Datos de confirmaci\u00f3n del usuario.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el registro fue confirmado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la confirmaci\u00f3n del registro.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/confirm\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef confirm_user_registration(\n    confirmation: ConfirmationRequest,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el registro de un usuario utilizando un PIN.\n\n    Args:\n        confirmation (ConfirmationRequest): Datos de confirmaci\u00f3n del usuario.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el registro fue confirmado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la confirmaci\u00f3n del registro.\n    \"\"\"\n    confirmation_use_case = ConfirmationUseCase(db)\n    try:\n        return confirmation_use_case.confirm_user(confirmation.email, confirmation.pin)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al confirmar el registro de usuario: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#reenvio-de-pin-de-confirmacion","title":"Reenv\u00edo de PIN de Confirmaci\u00f3n","text":"<p>Reenv\u00eda el PIN de confirmaci\u00f3n al correo electr\u00f3nico del usuario.</p> <p>Parameters:</p> Name Type Description Default <code>resend_request</code> <code>ResendPinConfirmRequest</code> <p>Solicitud de reenv\u00edo de PIN.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN fue reenviado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el reenv\u00edo del PIN.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/resend-confirm-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef resend_confirmation_pin_endpoint(\n    resend_request: ResendPinConfirmRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de confirmaci\u00f3n al correo electr\u00f3nico del usuario.\n\n    Args:\n        resend_request (ResendPinConfirmRequest): Solicitud de reenv\u00edo de PIN.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN fue reenviado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el reenv\u00edo del PIN.\n    \"\"\"\n    resend_confirmation_use_case = ResendConfirmationUseCase(db)\n    try:\n        return resend_confirmation_use_case.resend_confirmation(resend_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al reenviar el PIN de confirmaci\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#inicio-de-sesion","title":"Inicio de Sesi\u00f3n","text":"<p>Inicia el proceso de doble factor de autenticaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>login_request</code> <code>LoginRequest</code> <p>Datos de inicio de sesi\u00f3n del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto con el token de acceso.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el inicio de sesi\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/login\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef login_for_access_token(login_request: LoginRequest, background_tasks: BackgroundTasks, db: Session = Depends(getDb)) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de doble factor de autenticaci\u00f3n.\n\n    Args:\n        login_request (LoginRequest): Datos de inicio de sesi\u00f3n del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto con el token de acceso.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el inicio de sesi\u00f3n.\n    \"\"\"\n    login_use_case = LoginUseCase(db)\n    try:\n        return login_use_case.login_user(login_request.email, login_request.password, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al procesar el inicio de sesi\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#verificacion-de-autenticacion-de-dos-factores","title":"Verificaci\u00f3n de Autenticaci\u00f3n de Dos Factores","text":"<p>Verifica el inicio de sesi\u00f3n utilizando el PIN de doble factor de autenticaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>auth_request</code> <code>TwoFactorAuthRequest</code> <p>Datos de autenticaci\u00f3n de dos factores.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>TokenResponse</code> <code>TokenResponse</code> <p>Objeto con el token de acceso.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la verificaci\u00f3n del inicio de sesi\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/login/verify\", response_model=TokenResponse, status_code=status.HTTP_200_OK)\ndef verify_login(auth_request: TwoFactorAuthRequest, db: Session = Depends(getDb)) -&gt; TokenResponse:\n    \"\"\"\n    Verifica el inicio de sesi\u00f3n utilizando el PIN de doble factor de autenticaci\u00f3n.\n\n    Args:\n        auth_request (TwoFactorAuthRequest): Datos de autenticaci\u00f3n de dos factores.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        TokenResponse: Objeto con el token de acceso.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la verificaci\u00f3n del inicio de sesi\u00f3n.\n    \"\"\"\n    verify_use_case = VerifyUseCase(db)\n    try:\n        return verify_use_case.verify_2fa(auth_request.email, auth_request.pin)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al verificar el inicio de sesi\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#reenvio-de-pin-de-autenticacion-de-dos-factores","title":"Reenv\u00edo de PIN de Autenticaci\u00f3n de Dos Factores","text":"<p>Reenv\u00eda el PIN de doble factor de autenticaci\u00f3n al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>resend_request</code> <code>Resend2FARequest</code> <p>Solicitud de reenv\u00edo de PIN de 2FA.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN de 2FA fue reenviado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el reenv\u00edo del PIN de 2FA.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/resend-2fa-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef resend_2fa_pin_endpoint(\n    resend_request: Resend2FARequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de doble factor de autenticaci\u00f3n al usuario.\n\n    Args:\n        resend_request (Resend2FARequest): Solicitud de reenv\u00edo de PIN de 2FA.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN de 2FA fue reenviado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el reenv\u00edo del PIN de 2FA.\n    \"\"\"\n    resend_2fa_use_case = Resend2faUseCase(db)\n    try:\n        return resend_2fa_use_case.resend_2fa(resend_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al reenviar el PIN de doble factor de autenticaci\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#cierre-de-sesion","title":"Cierre de Sesi\u00f3n","text":"<p>Cierra la sesi\u00f3n del usuario actual.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>credentials</code> <code>HTTPAuthorizationCredentials</code> <p>Credenciales de autorizaci\u00f3n HTTP.</p> <code>Security(security_scheme)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que la sesi\u00f3n fue cerrada exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el cierre de sesi\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/logout\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef logout(\n    current_user: UserInDB = Depends(get_current_user),\n    db: Session = Depends(getDb),\n    credentials: HTTPAuthorizationCredentials = Security(security_scheme)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Cierra la sesi\u00f3n del usuario actual.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado.\n        db (Session): Sesi\u00f3n de base de datos.\n        credentials (HTTPAuthorizationCredentials): Credenciales de autorizaci\u00f3n HTTP.\n\n    Returns:\n        SuccessResponse: Objeto indicando que la sesi\u00f3n fue cerrada exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el cierre de sesi\u00f3n.\n    \"\"\"\n    token = credentials.credentials\n    logout_use_case = LogoutUseCase(db)\n    try:\n        return logout_use_case.logout(token, current_user.id)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"No se pudo cerrar la sesi\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#gestion-de-contrasenas","title":"Gesti\u00f3n de Contrase\u00f1as","text":""},{"location":"user/endpoints/#recuperacion-de-contrasena","title":"Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.</p> <p>Parameters:</p> Name Type Description Default <code>recovery_request</code> <code>PasswordRecoveryRequest</code> <p>Solicitud de recuperaci\u00f3n de contrase\u00f1a.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el proceso de recuperaci\u00f3n fue iniciado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el inicio del proceso de recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/password-recovery\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef initiate_password_recovery(\n    recovery_request: PasswordRecoveryRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n    Args:\n        recovery_request (PasswordRecoveryRequest): Solicitud de recuperaci\u00f3n de contrase\u00f1a.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el proceso de recuperaci\u00f3n fue iniciado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el inicio del proceso de recuperaci\u00f3n.\n    \"\"\"\n    password_recovery_use_case = PasswordRecoveryUseCase(db)\n    try:\n        return password_recovery_use_case.recovery_password(recovery_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al iniciar el proceso de recuperaci\u00f3n de contrase\u00f1a: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#confirmacion-de-pin-de-recuperacion","title":"Confirmaci\u00f3n de PIN de Recuperaci\u00f3n","text":"<p>Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Parameters:</p> Name Type Description Default <code>pin_confirmation</code> <code>PinConfirmationRequest</code> <p>Datos de confirmaci\u00f3n del PIN de recuperaci\u00f3n.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN de recuperaci\u00f3n fue confirmado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la confirmaci\u00f3n del PIN de recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/confirm-recovery-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef confirm_recovery_pin(\n    pin_confirmation: PinConfirmationRequest,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Args:\n        pin_confirmation (PinConfirmationRequest): Datos de confirmaci\u00f3n del PIN de recuperaci\u00f3n.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN de recuperaci\u00f3n fue confirmado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la confirmaci\u00f3n del PIN de recuperaci\u00f3n.\n    \"\"\"\n    password_recovery_use_case = ConfirmRecoveryPinUseCase(db)\n    try:\n        return password_recovery_use_case.confirm_recovery(pin_confirmation.email, pin_confirmation.pin)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error al confirmar el PIN de recuperaci\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#reenvio-de-pin-de-recuperacion","title":"Reenv\u00edo de PIN de Recuperaci\u00f3n","text":"<p>Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>recovery_request</code> <code>PasswordRecoveryRequest</code> <p>Solicitud de reenv\u00edo de PIN de recuperaci\u00f3n.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN de recuperaci\u00f3n fue reenviado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el reenv\u00edo del PIN de recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/resend-recovery-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef resend_recovery_pin(\n    recovery_request: PasswordRecoveryRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a al usuario.\n\n    Args:\n        recovery_request (PasswordRecoveryRequest): Solicitud de reenv\u00edo de PIN de recuperaci\u00f3n.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN de recuperaci\u00f3n fue reenviado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el reenv\u00edo del PIN de recuperaci\u00f3n.\n    \"\"\"\n    password_recovery_use_case = ResendRecoveryUseCase(db)\n    try:\n        return password_recovery_use_case.resend_recovery(recovery_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno en el reenvio del PIN de recuperaci\u00f3n de contrase\u00f1a: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#restablecimiento-de-contrasena","title":"Restablecimiento de Contrase\u00f1a","text":"<p>Restablece la contrase\u00f1a de un usuario.</p> <p>Parameters:</p> Name Type Description Default <code>reset_request</code> <code>PasswordResetRequest</code> <p>Solicitud de restablecimiento de contrase\u00f1a.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que la contrase\u00f1a fue restablecida exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el restablecimiento de la contrase\u00f1a.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/reset-password\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef reset_password(\n    reset_request: PasswordResetRequest,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Restablece la contrase\u00f1a de un usuario.\n\n    Args:\n        reset_request (PasswordResetRequest): Solicitud de restablecimiento de contrase\u00f1a.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que la contrase\u00f1a fue restablecida exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el restablecimiento de la contrase\u00f1a.\n    \"\"\"\n    password_recovery_use_case = ResetPasswordUseCase(db)\n    try:\n        return password_recovery_use_case.reset_password(reset_request.email, reset_request.new_password)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al reestablecer la contrase\u00f1a: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#gestion-de-perfil-de-usuario","title":"Gesti\u00f3n de Perfil de Usuario","text":""},{"location":"user/endpoints/#obtener-usuario-actual","title":"Obtener Usuario Actual","text":"<p>Obtiene el usuario actual autenticado a partir de las credenciales JWT.</p> <p>Parameters:</p> Name Type Description Default <code>credentials</code> <code>Optional[HTTPAuthorizationCredentials]</code> <p>Credenciales de autorizaci\u00f3n HTTP Bearer.</p> <code>Security(security_scheme)</code> <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para realizar consultas.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>El usuario autenticado.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si el token es inv\u00e1lido, ha expirado, o el usuario no est\u00e1 registrado.</p> Source code in <code>app\\infrastructure\\security\\jwt_middleware.py</code> <pre><code>def get_current_user(\n    credentials: Optional[HTTPAuthorizationCredentials] = Security(security_scheme),\n    db: Session = Depends(getDb)\n) -&gt; User:\n    \"\"\"\n    Obtiene el usuario actual autenticado a partir de las credenciales JWT.\n\n    Args:\n        credentials (Optional[HTTPAuthorizationCredentials]): Credenciales de autorizaci\u00f3n HTTP Bearer.\n        db (Session): Sesi\u00f3n de base de datos para realizar consultas.\n\n    Returns:\n        User: El usuario autenticado.\n\n    Raises:\n        HTTPException: Si el token es inv\u00e1lido, ha expirado, o el usuario no est\u00e1 registrado.\n    \"\"\"\n    if credentials is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Se requiere un token de autenticaci\u00f3n\")\n\n    token = credentials.credentials\n    user_repository = UserRepository(db)\n\n    # Verificar si el token est\u00e1 en la lista negra\n    if user_repository.is_token_blacklisted(token):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Token inv\u00e1lido o ya ha sido cerrada la sesi\u00f3n.\")\n\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n\n        # Obtener el email del payload\n        email: str = payload.get(\"sub\")\n        if email is None:\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"No se pudo validar el email\")\n\n        # Obtener el tiempo de expiraci\u00f3n del payload\n        exp = payload.get(\"exp\")\n        if exp is None:\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"El token no tiene expiraci\u00f3n.\")\n\n        # Convertir el tiempo de expiraci\u00f3n a un objeto datetime\n        expiration_time = datetime.fromtimestamp(exp, tz=timezone.utc)\n\n        # Comparar el tiempo de expiraci\u00f3n con el tiempo actual\n        current_time = datetime_utc_time()\n\n        if expiration_time &lt; current_time:\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"El token ha expirado.\")\n    except JWTError as e:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=f\"No se pudieron validar las credenciales. {e}\")\n\n    user = user_repository.get_user_by_email(email)\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"La cuenta con este email no est\u00e1 registrada\")\n    return user\n</code></pre>"},{"location":"user/endpoints/#actualizar-informacion-de-usuario","title":"Actualizar Informaci\u00f3n de Usuario","text":"<p>Actualiza la informaci\u00f3n del usuario actual.</p> <p>Parameters:</p> Name Type Description Default <code>user_update</code> <code>UserUpdate</code> <p>Datos de actualizaci\u00f3n del usuario.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que la informaci\u00f3n fue actualizada exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la actualizaci\u00f3n de la informaci\u00f3n del usuario.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.put(\"/me/update\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef update_user_info(\n    user_update: UserUpdate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Actualiza la informaci\u00f3n del usuario actual.\n\n    Args:\n        user_update (UserUpdate): Datos de actualizaci\u00f3n del usuario.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Objeto indicando que la informaci\u00f3n fue actualizada exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la actualizaci\u00f3n de la informaci\u00f3n del usuario.\n    \"\"\"\n    update_user_info_use_case = UpdateUserInfoUseCase(db)\n    try:\n        return update_user_info_use_case.update_user_info(current_user, user_update)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"No se pudo actualizar la informaci\u00f3n del usuario: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/models/","title":"Modelos de Usuario","text":"<p>Este documento describe los modelos ORM utilizados para la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/models/#modelos-de-base-de-datos","title":"Modelos de Base de Datos","text":""},{"location":"user/models/#usuario","title":"Usuario","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'usuario' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>email</code> <code>str</code> <p>Correo electr\u00f3nico \u00fanico del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> <code>failed_attempts</code> <code>int</code> <p>N\u00famero de intentos fallidos de inicio de sesi\u00f3n.</p> <code>locked_until</code> <code>datetime</code> <p>Fecha y hora hasta la cual el usuario est\u00e1 bloqueado.</p> <code>state_id</code> <code>int</code> <p>Identificador del estado del usuario.</p> <code>estado</code> <code>UserState</code> <p>Estado actual del usuario.</p> <code>confirmacion</code> <code>UserConfirmation</code> <p>Informaci\u00f3n de confirmaci\u00f3n del usuario.</p> <code>verificacion_dos_pasos</code> <code>TwoStepVerification</code> <p>Informaci\u00f3n de verificaci\u00f3n de dos pasos.</p> <code>recuperacion_contrasena</code> <code>PasswordRecovery</code> <p>Informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a.</p> <code>blacklisted_tokens</code> <code>List[BlacklistedToken]</code> <p>Lista de tokens en lista negra.</p> <code>asignaciones</code> <code>List[Assignment]</code> <p>Lista de asignaciones del usuario.</p> <code>roles_fincas</code> <code>List[UserFarmRole]</code> <p>Lista de roles del usuario en diferentes fincas.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class User(Base):\n    \"\"\"\n    Representa la tabla 'usuario' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        email (str): Correo electr\u00f3nico \u00fanico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n        failed_attempts (int): N\u00famero de intentos fallidos de inicio de sesi\u00f3n.\n        locked_until (datetime): Fecha y hora hasta la cual el usuario est\u00e1 bloqueado.\n        state_id (int): Identificador del estado del usuario.\n        estado (UserState): Estado actual del usuario.\n        confirmacion (UserConfirmation): Informaci\u00f3n de confirmaci\u00f3n del usuario.\n        verificacion_dos_pasos (TwoStepVerification): Informaci\u00f3n de verificaci\u00f3n de dos pasos.\n        recuperacion_contrasena (PasswordRecovery): Informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a.\n        blacklisted_tokens (List[BlacklistedToken]): Lista de tokens en lista negra.\n        asignaciones (List[Assignment]): Lista de asignaciones del usuario.\n        roles_fincas (List[UserFarmRole]): Lista de roles del usuario en diferentes fincas.\n    \"\"\"\n    __tablename__ = \"usuario\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), nullable=False, index=True)\n    apellido = Column(String(50), nullable=False, index=True)\n    email = Column(String(100), unique=True, nullable=False, index=True)\n    password = Column(String(255), nullable=False)\n    failed_attempts = Column(Integer, default=0, nullable=False)\n    locked_until = Column(TIMESTAMP(timezone=True), nullable=True)  # Actualizado a TIMESTAMP\n    state_id = Column(Integer, ForeignKey('estado_usuario.id'), nullable=False)\n    acepta_terminos = Column(Boolean, nullable=False, default=False)\n\n    estado = relationship(\"UserState\")\n    confirmacion = relationship(\"UserConfirmation\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    verificacion_dos_pasos = relationship(\"TwoStepVerification\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    recuperacion_contrasena = relationship(\"PasswordRecovery\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    blacklisted_tokens = relationship(\"BlacklistedToken\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    asignaciones = relationship(\"Assignment\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    roles_fincas = relationship(\"UserFarmRole\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n</code></pre>"},{"location":"user/models/#rol","title":"Rol","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'rol' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del rol.</p> <code>nombre</code> <code>str</code> <p>Nombre \u00fanico del rol.</p> <code>descripcion</code> <code>str</code> <p>Descripci\u00f3n del rol.</p> <code>usuario_fincas</code> <code>List[UserFarmRole]</code> <p>Lista de relaciones usuario-finca-rol asociadas a este rol.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class Role(Base):\n    \"\"\"\n    Representa la tabla 'rol' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del rol.\n        nombre (str): Nombre \u00fanico del rol.\n        descripcion (str): Descripci\u00f3n del rol.\n        usuario_fincas (List[UserFarmRole]): Lista de relaciones usuario-finca-rol asociadas a este rol.\n    \"\"\"\n    __tablename__ = \"rol\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), unique=True, nullable=False, index=True)\n    descripcion = Column(Text)\n\n    usuario_fincas = relationship(\"UserFarmRole\", back_populates=\"rol\")\n</code></pre>"},{"location":"user/models/#estado-de-usuario","title":"Estado de Usuario","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'estado_usuario' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del estado.</p> <code>nombre</code> <code>str</code> <p>Nombre \u00fanico del estado.</p> <code>descripcion</code> <code>str</code> <p>Descripci\u00f3n del estado.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class UserState(Base):\n    \"\"\"\n    Representa la tabla 'estado_usuario' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del estado.\n        nombre (str): Nombre \u00fanico del estado.\n        descripcion (str): Descripci\u00f3n del estado.\n    \"\"\"\n    __tablename__ = \"estado_usuario\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), unique=True, nullable=False, index=True)\n    descripcion = Column(Text)\n</code></pre>"},{"location":"user/models/#confirmacion-de-usuario","title":"Confirmaci\u00f3n de Usuario","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'confirmacion_usuario' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la confirmaci\u00f3n.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>pin</code> <code>str</code> <p>PIN \u00fanico de confirmaci\u00f3n.</p> <code>expiracion</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n del PIN.</p> <code>intentos</code> <code>int</code> <p>N\u00famero de intentos de confirmaci\u00f3n.</p> <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n del registro.</p> <code>resends</code> <code>int</code> <p>N\u00famero de reenv\u00edos del PIN.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado a la confirmaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class UserConfirmation(Base):\n    \"\"\"\n    Representa la tabla 'confirmacion_usuario' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la confirmaci\u00f3n.\n        usuario_id (int): Identificador del usuario asociado.\n        pin (str): PIN \u00fanico de confirmaci\u00f3n.\n        expiracion (datetime): Fecha y hora de expiraci\u00f3n del PIN.\n        intentos (int): N\u00famero de intentos de confirmaci\u00f3n.\n        created_at (datetime): Fecha y hora de creaci\u00f3n del registro.\n        resends (int): N\u00famero de reenv\u00edos del PIN.\n        usuario (User): Usuario asociado a la confirmaci\u00f3n.\n    \"\"\"\n    __tablename__ = \"confirmacion_usuario\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID, ondelete=\"CASCADE\"), nullable=False)\n    pin = Column(String(64), nullable=False, unique=True, index=True)\n    expiracion = Column(TIMESTAMP(timezone=True), nullable=False)\n    intentos = Column(Integer, default=0)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    resends = Column(Integer, default=0)\n\n    usuario = relationship(\"User\", back_populates=\"confirmacion\")\n</code></pre>"},{"location":"user/models/#verificacion-de-dos-pasos","title":"Verificaci\u00f3n de Dos Pasos","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'verificacion_dos_pasos' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la verificaci\u00f3n.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>pin</code> <code>str</code> <p>PIN \u00fanico de verificaci\u00f3n.</p> <code>expiracion</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n del PIN.</p> <code>intentos</code> <code>int</code> <p>N\u00famero de intentos de verificaci\u00f3n.</p> <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n del registro.</p> <code>resends</code> <code>int</code> <p>N\u00famero de reenv\u00edos del PIN.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado a la verificaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class TwoStepVerification(Base):\n    \"\"\"\n    Representa la tabla 'verificacion_dos_pasos' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la verificaci\u00f3n.\n        usuario_id (int): Identificador del usuario asociado.\n        pin (str): PIN \u00fanico de verificaci\u00f3n.\n        expiracion (datetime): Fecha y hora de expiraci\u00f3n del PIN.\n        intentos (int): N\u00famero de intentos de verificaci\u00f3n.\n        created_at (datetime): Fecha y hora de creaci\u00f3n del registro.\n        resends (int): N\u00famero de reenv\u00edos del PIN.\n        usuario (User): Usuario asociado a la verificaci\u00f3n.\n    \"\"\"\n    __tablename__ = \"verificacion_dos_pasos\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID, ondelete=\"CASCADE\"), nullable=False)\n    pin = Column(String(64), nullable=False, unique=True, index=True)\n    expiracion = Column(TIMESTAMP(timezone=True), nullable=False)\n    intentos = Column(Integer, default=0)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    resends = Column(Integer, default=0)\n\n    usuario = relationship(\"User\", back_populates=\"verificacion_dos_pasos\")\n</code></pre>"},{"location":"user/models/#recuperacion-de-contrasena","title":"Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'recuperacion_contrasena' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la recuperaci\u00f3n.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>pin</code> <code>str</code> <p>PIN \u00fanico de recuperaci\u00f3n.</p> <code>expiracion</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n del PIN.</p> <code>intentos</code> <code>int</code> <p>N\u00famero de intentos de recuperaci\u00f3n.</p> <code>pin_confirmado</code> <code>bool</code> <p>Indica si el PIN ha sido confirmado.</p> <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n del registro.</p> <code>resends</code> <code>int</code> <p>N\u00famero de reenv\u00edos del PIN.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado a la recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class PasswordRecovery(Base):\n    \"\"\"\n    Representa la tabla 'recuperacion_contrasena' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la recuperaci\u00f3n.\n        usuario_id (int): Identificador del usuario asociado.\n        pin (str): PIN \u00fanico de recuperaci\u00f3n.\n        expiracion (datetime): Fecha y hora de expiraci\u00f3n del PIN.\n        intentos (int): N\u00famero de intentos de recuperaci\u00f3n.\n        pin_confirmado (bool): Indica si el PIN ha sido confirmado.\n        created_at (datetime): Fecha y hora de creaci\u00f3n del registro.\n        resends (int): N\u00famero de reenv\u00edos del PIN.\n        usuario (User): Usuario asociado a la recuperaci\u00f3n.\n    \"\"\"\n    __tablename__ = \"recuperacion_contrasena\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID, ondelete=\"CASCADE\"), nullable=False)\n    pin = Column(String(64), nullable=False, unique=True, index=True)\n    expiracion = Column(TIMESTAMP(timezone=True), nullable=False)\n    intentos = Column(Integer, default=0)\n    pin_confirmado = Column(Boolean, default=False, nullable=False)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    resends = Column(Integer, default=0)\n\n    usuario = relationship(\"User\", back_populates=\"recuperacion_contrasena\")\n</code></pre>"},{"location":"user/models/#token-en-lista-negra","title":"Token en Lista Negra","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'blacklisted_tokens' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del token en lista negra.</p> <code>token</code> <code>str</code> <p>Token \u00fanico en lista negra.</p> <code>blacklisted_at</code> <code>datetime</code> <p>Fecha y hora en que el token fue a\u00f1adido a la lista negra.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado al token en lista negra.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class BlacklistedToken(Base):\n    \"\"\"\n    Representa la tabla 'blacklisted_tokens' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del token en lista negra.\n        token (str): Token \u00fanico en lista negra.\n        blacklisted_at (datetime): Fecha y hora en que el token fue a\u00f1adido a la lista negra.\n        usuario_id (int): Identificador del usuario asociado.\n        usuario (User): Usuario asociado al token en lista negra.\n    \"\"\"\n    __tablename__ = \"blacklisted_tokens\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    token = Column(String(500), unique=True, nullable=False, index=True)\n    blacklisted_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID), nullable=False)\n\n    usuario = relationship(\"User\", back_populates=\"blacklisted_tokens\")\n</code></pre>"},{"location":"user/overview/","title":"Visi\u00f3n General del M\u00f3dulo de Usuario","text":""},{"location":"user/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>Bienvenido al m\u00f3dulo de usuario de AgroInsight. Esta secci\u00f3n proporciona una visi\u00f3n general de las funcionalidades y caracter\u00edsticas disponibles para los usuarios de nuestra plataforma agr\u00edcola inteligente.</p>"},{"location":"user/overview/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"user/overview/#1-gestion-de-perfil","title":"1. Gesti\u00f3n de Perfil","text":"<ul> <li>Creaci\u00f3n y edici\u00f3n de perfiles de usuario</li> <li>Configuraci\u00f3n de preferencias personales</li> <li>Gesti\u00f3n de informaci\u00f3n de contacto y notificaciones</li> </ul>"},{"location":"user/overview/#2-panel-de-control","title":"2. Panel de Control","text":"<ul> <li>Visualizaci\u00f3n de datos agr\u00edcolas en tiempo real</li> <li>Resumen de actividades recientes</li> <li>Acceso r\u00e1pido a herramientas y funciones clave</li> </ul>"},{"location":"user/overview/#3-gestion-de-parcelas","title":"3. Gesti\u00f3n de Parcelas","text":"<ul> <li>Registro y seguimiento de parcelas agr\u00edcolas</li> <li>Visualizaci\u00f3n de mapas interactivos</li> <li>Monitoreo de condiciones del suelo y cultivos</li> </ul>"},{"location":"user/overview/#4-planificacion-de-cultivos","title":"4. Planificaci\u00f3n de Cultivos","text":"<ul> <li>Calendario de siembra y cosecha</li> <li>Recomendaciones personalizadas basadas en datos</li> <li>Seguimiento del progreso de los cultivos</li> </ul>"},{"location":"user/overview/#5-analisis-y-reportes","title":"5. An\u00e1lisis y Reportes","text":"<ul> <li>Generaci\u00f3n de informes detallados</li> <li>An\u00e1lisis de rendimiento de cultivos</li> <li>Comparativas hist\u00f3ricas y proyecciones</li> </ul>"},{"location":"user/overview/#primeros-pasos","title":"Primeros Pasos","text":"<p>Para comenzar a utilizar el m\u00f3dulo de usuario de AgroInsight, siga estos pasos:</p> <ol> <li>Reg\u00edstrese o inicie sesi\u00f3n en su cuenta</li> <li>Complete su perfil de usuario</li> <li>Agregue su primera parcela</li> <li>Explore las diferentes funcionalidades del panel de control</li> </ol>"},{"location":"user/overview/#soporte-y-ayuda","title":"Soporte y Ayuda","text":"<p>Si necesita asistencia adicional, puede:</p> <ul> <li>Consultar nuestra secci\u00f3n de Preguntas Frecuentes</li> <li>Contactar a nuestro equipo de soporte</li> <li>Participar en nuestra comunidad de usuarios</li> </ul>"},{"location":"user/overview/#proximas-actualizaciones","title":"Pr\u00f3ximas Actualizaciones","text":"<p>Estamos constantemente mejorando AgroInsight. Mant\u00e9ngase atento a las pr\u00f3ximas actualizaciones que incluir\u00e1n:</p> <ul> <li>Integraci\u00f3n con dispositivos IoT para monitoreo en tiempo real</li> <li>M\u00f3dulo de gesti\u00f3n de recursos h\u00eddricos</li> <li>Herramientas avanzadas de predicci\u00f3n de cosechas</li> </ul> <p>\u00a1Gracias por elegir AgroInsight para optimizar sus operaciones agr\u00edcolas!</p>"},{"location":"user/repository/","title":"Documentaci\u00f3n del Repositorio de Usuarios","text":""},{"location":"user/repository/#vision-general","title":"Visi\u00f3n General","text":"<p>El m\u00f3dulo <code>UserRepository</code> proporciona una interfaz para interactuar con la base de datos en relaci\u00f3n con los usuarios y entidades relacionadas. Esta clase encapsula todas las operaciones de base de datos relacionadas con usuarios, incluyendo creaci\u00f3n, lectura, actualizaci\u00f3n y eliminaci\u00f3n (CRUD), as\u00ed como operaciones espec\u00edficas para la gesti\u00f3n de usuarios como confirmaciones, verificaci\u00f3n de dos pasos y recuperaci\u00f3n de contrase\u00f1as.</p>"},{"location":"user/repository/#clase-userrepository","title":"Clase: UserRepository","text":""},{"location":"user/repository/#constructor","title":"Constructor","text":"<p>Inicializa el repositorio de usuarios.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa el repositorio de usuarios.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n</code></pre>"},{"location":"user/repository/#metodos-de-usuario","title":"M\u00e9todos de Usuario","text":""},{"location":"user/repository/#obtener-usuario-por-email","title":"Obtener Usuario por Email","text":"<p>Obtiene un usuario por su direcci\u00f3n de correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_by_email(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario por su direcci\u00f3n de correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-usuario-por-id","title":"Obtener Usuario por ID","text":"<p>Obtiene un usuario por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_by_id(self, user_id: int) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario por su ID.\n\n    Args:\n        user_id (int): ID del usuario.\n\n    Returns:\n        Optional[User]: El usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).get(user_id)\n</code></pre>"},{"location":"user/repository/#obtener-usuario-con-confirmacion","title":"Obtener Usuario con Confirmaci\u00f3n","text":"<p>Obtiene un usuario con su informaci\u00f3n de confirmaci\u00f3n por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario con informaci\u00f3n de confirmaci\u00f3n si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_with_confirmation(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario con su informaci\u00f3n de confirmaci\u00f3n por correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario con informaci\u00f3n de confirmaci\u00f3n si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.confirmacion)).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-usuario-con-verificacion-de-dos-pasos","title":"Obtener Usuario con Verificaci\u00f3n de Dos Pasos","text":"<p>Obtiene un usuario con su informaci\u00f3n de verificaci\u00f3n de dos pasos por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario con informaci\u00f3n de verificaci\u00f3n de dos pasos si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_with_two_factor_verification(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario con su informaci\u00f3n de verificaci\u00f3n de dos pasos por correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario con informaci\u00f3n de verificaci\u00f3n de dos pasos si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.verificacion_dos_pasos)).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-usuario-con-recuperacion-de-contrasena","title":"Obtener Usuario con Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Obtiene un usuario con su informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario con informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_with_password_recovery(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario con su informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a por correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario con informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.recuperacion_contrasena)).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-todos-los-usuarios","title":"Obtener Todos los Usuarios","text":"<p>Obtiene todos los usuarios con su informaci\u00f3n de estado.</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>List[User]: Lista de todos los usuarios con su estado.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_all_users(self) -&gt; List[User]:\n    \"\"\"\n    Obtiene todos los usuarios con su informaci\u00f3n de estado.\n\n    Returns:\n        List[User]: Lista de todos los usuarios con su estado.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.estado)).all()\n</code></pre>"},{"location":"user/repository/#agregar-usuario","title":"Agregar Usuario","text":"<p>Agrega un nuevo usuario a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario a agregar.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario agregado si tiene \u00e9xito, None en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_user(self, user: UserCreate, state_id: int) -&gt; Optional[User]:\n    \"\"\"\n    Agrega un nuevo usuario a la base de datos.\n\n    Args:\n        user (User): Objeto de usuario a agregar.\n\n    Returns:\n        Optional[User]: El usuario agregado si tiene \u00e9xito, None en caso de error.\n    \"\"\"\n    try:\n        new_user = User(\n            nombre=user.nombre,\n            apellido=user.apellido,\n            email=user.email,\n            password=user.password,\n            acepta_terminos=user.acepta_terminos,\n            state_id=state_id\n        )\n        self.db.add(new_user)\n        self.db.commit()\n        self.db.refresh(new_user)\n        return new_user\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al crear el usuario: {e}\")\n        return None\n</code></pre>"},{"location":"user/repository/#actualizar-usuario","title":"Actualizar Usuario","text":"<p>Actualiza un usuario existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario con los datos actualizados.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario actualizado si tiene \u00e9xito, None en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_user(self, user: UserInDB) -&gt; Optional[User]:\n    \"\"\"\n    Actualiza un usuario existente en la base de datos.\n\n    Args:\n        user (User): Objeto de usuario con los datos actualizados.\n\n    Returns:\n        Optional[User]: El usuario actualizado si tiene \u00e9xito, None en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(user)\n        return user\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar el usuario: {e}\")\n        return None\n</code></pre>"},{"location":"user/repository/#eliminar-usuario","title":"Eliminar Usuario","text":"<p>Elimina un usuario de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserInDB</code> <p>Objeto de usuario a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_user(self, user: UserInDB) -&gt; bool:\n    \"\"\"\n    Elimina un usuario de la base de datos.\n\n    Args:\n        user (UserInDB): Objeto de usuario a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(user)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar el usuario: {str(e)}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-confirmacion-de-usuario","title":"M\u00e9todos de Confirmaci\u00f3n de Usuario","text":""},{"location":"user/repository/#agregar-confirmacion-de-usuario","title":"Agregar Confirmaci\u00f3n de Usuario","text":"<p>Agrega una confirmaci\u00f3n de usuario a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario.</p> required <code>pin_hash</code> <code>str</code> <p>Hash del PIN.</p> required <code>expiration_datetime</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n del PIN.</p> required <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n del registro.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_user_confirmation(self, user_id: int, pin_hash: str, expiration_datetime: datetime, created_at: datetime) -&gt; bool:\n    \"\"\"\n    Agrega una confirmaci\u00f3n de usuario a la base de datos.\n\n    Args:\n        user_id (int): ID del usuario.\n        pin_hash (str): Hash del PIN.\n        expiration_datetime (datetime): Fecha y hora de expiraci\u00f3n del PIN.\n        created_at (datetime): Fecha y hora de creaci\u00f3n del registro.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        confirmation = UserConfirmation(\n            usuario_id=user_id,\n            pin=pin_hash,\n            expiracion=expiration_datetime,\n            created_at=created_at\n        )\n        self.db.add(confirmation)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al agregar la confirmaci\u00f3n del usuario: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#actualizar-confirmacion-de-usuario","title":"Actualizar Confirmaci\u00f3n de Usuario","text":"<p>Actualiza una confirmaci\u00f3n de usuario existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n de usuario con los datos actualizados.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se actualiz\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_user_confirmation(self, confirmation: UserConfirmation) -&gt; bool:\n    \"\"\"\n    Actualiza una confirmaci\u00f3n de usuario existente en la base de datos.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n de usuario con los datos actualizados.\n\n    Returns:\n        bool: True si se actualiz\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(confirmation)\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar la confirmaci\u00f3n del usuario: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#eliminar-confirmacion-de-usuario","title":"Eliminar Confirmaci\u00f3n de Usuario","text":"<p>Elimina una confirmaci\u00f3n de usuario de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n de usuario a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_user_confirmation(self, confirmation: UserConfirmation) -&gt; bool:\n    \"\"\"\n    Elimina una confirmaci\u00f3n de usuario de la base de datos.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n de usuario a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(confirmation)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar la confirmaci\u00f3n del usuario: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-verificacion-de-dos-pasos","title":"M\u00e9todos de Verificaci\u00f3n de Dos Pasos","text":""},{"location":"user/repository/#agregar-verificacion-de-dos-pasos","title":"Agregar Verificaci\u00f3n de Dos Pasos","text":"<p>Agrega una verificaci\u00f3n de dos pasos a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario.</p> required <code>pin_hash</code> <code>str</code> <p>Hash del PIN de verificaci\u00f3n.</p> required <code>expiration_datetime</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n.</p> required <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_two_factor_verification(self, user_id: int, pin_hash: str, expiration_datetime: datetime, created_at: datetime) -&gt; bool:\n    \"\"\"\n    Agrega una verificaci\u00f3n de dos pasos a la base de datos.\n\n    Args:\n        user_id (int): ID del usuario.\n        pin_hash (str): Hash del PIN de verificaci\u00f3n.\n        expiration_datetime (datetime): Fecha y hora de expiraci\u00f3n.\n        created_at (datetime): Fecha y hora de creaci\u00f3n.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        verification = TwoStepVerification(\n            usuario_id=user_id,\n            pin=pin_hash,\n            expiracion=expiration_datetime,\n            created_at=created_at\n        )\n        self.db.add(verification)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al agregar la verificaci\u00f3n de dos pasos: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#actualizar-verificacion-de-dos-pasos","title":"Actualizar Verificaci\u00f3n de Dos Pasos","text":"<p>Actualiza una verificaci\u00f3n de dos pasos existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos pasos con los datos actualizados.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se actualiz\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_two_factor_verification(self, verification: TwoStepVerification) -&gt; bool:\n    \"\"\"\n    Actualiza una verificaci\u00f3n de dos pasos existente en la base de datos.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos con los datos actualizados.\n\n    Returns:\n        bool: True si se actualiz\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(verification)\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar la verificacion en dos pasos: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#eliminar-verificacion-de-dos-pasos","title":"Eliminar Verificaci\u00f3n de Dos Pasos","text":"<p>Elimina una verificaci\u00f3n de dos pasos de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos pasos a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_two_factor_verification(self, verification: TwoStepVerification) -&gt; bool:\n    \"\"\"\n    Elimina una verificaci\u00f3n de dos pasos de la base de datos.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(verification)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar la verificaci\u00f3n de dos pasos: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-recuperacion-de-contrasena","title":"M\u00e9todos de Recuperaci\u00f3n de Contrase\u00f1a","text":""},{"location":"user/repository/#agregar-recuperacion-de-contrasena","title":"Agregar Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Agrega una recuperaci\u00f3n de contrase\u00f1a a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n.</p> required <code>expiration_datetime</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n.</p> required <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_password_recovery(self, user_id: int, pin: str, expiration_datetime: datetime, created_at: datetime) -&gt; bool:\n    \"\"\"\n    Agrega una recuperaci\u00f3n de contrase\u00f1a a la base de datos.\n\n    Args:\n        user_id (int): ID del usuario.\n        pin (str): PIN de recuperaci\u00f3n.\n        expiration_datetime (datetime): Fecha y hora de expiraci\u00f3n.\n        created_at (datetime): Fecha y hora de creaci\u00f3n.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        recovery = PasswordRecovery(\n            usuario_id=user_id,\n            pin=pin,\n            expiracion=expiration_datetime,\n            created_at=created_at\n        )\n        self.db.add(recovery)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al agregar la recuperaci\u00f3n de contrase\u00f1a: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#actualizar-recuperacion-de-contrasena","title":"Actualizar Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Actualiza una recuperaci\u00f3n de contrase\u00f1a existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a con los datos actualizados.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se actualiz\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_password_recovery(self, recovery: PasswordRecovery) -&gt; bool:\n    \"\"\"\n    Actualiza una recuperaci\u00f3n de contrase\u00f1a existente en la base de datos.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a con los datos actualizados.\n\n    Returns:\n        bool: True si se actualiz\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(recovery)\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar la recuperaci\u00f3n de contrase\u00f1a: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#eliminar-recuperacion-de-contrasena","title":"Eliminar Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Elimina una recuperaci\u00f3n de contrase\u00f1a de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_password_recovery(self, recovery: PasswordRecovery) -&gt; bool:\n    \"\"\"\n    Elimina una recuperaci\u00f3n de contrase\u00f1a de la base de datos.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(recovery)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar la recuperaci\u00f3n: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-gestion-de-tokens","title":"M\u00e9todos de Gesti\u00f3n de Tokens","text":""},{"location":"user/repository/#agregar-token-a-lista-negra","title":"Agregar Token a Lista Negra","text":"<p>Agrega un token a la lista negra en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>blacklisted</code> <code>BlacklistedToken</code> <p>Objeto de token en lista negra a agregar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def blacklist_token(self, blacklisted: BlacklistedToken) -&gt; bool:\n    \"\"\"\n    Agrega un token a la lista negra en la base de datos.\n\n    Args:\n        blacklisted (BlacklistedToken): Objeto de token en lista negra a agregar.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.add(blacklisted)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al blacklistear el token: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#verificar-si-un-token-esta-en-lista-negra","title":"Verificar si un Token est\u00e1 en Lista Negra","text":"<p>Verifica si un token est\u00e1 en la lista negra.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token a verificar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el token est\u00e1 en la lista negra, False en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def is_token_blacklisted(self, token: str) -&gt; bool:\n    \"\"\"\n    Verifica si un token est\u00e1 en la lista negra.\n\n    Args:\n        token (str): Token a verificar.\n\n    Returns:\n        bool: True si el token est\u00e1 en la lista negra, False en caso contrario.\n    \"\"\"\n    return self.db.query(BlacklistedToken).filter(BlacklistedToken.token == token).first() is not None\n</code></pre>"},{"location":"user/repository/#metodos-de-estado-de-usuario","title":"M\u00e9todos de Estado de Usuario","text":""},{"location":"user/repository/#obtener-estado-por-id","title":"Obtener Estado por ID","text":"<p>Obtiene un estado de usuario por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>ID del estado de usuario.</p> required <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_state_by_id(self, state_id: int) -&gt; Optional[UserState]:\n    \"\"\"\n    Obtiene un estado de usuario por su ID.\n\n    Args:\n        state_id (int): ID del estado de usuario.\n\n    Returns:\n        Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(UserState).filter(UserState.id == state_id).first()\n</code></pre>"},{"location":"user/repository/#obtener-estado-por-nombre","title":"Obtener Estado por Nombre","text":"<p>Obtiene un estado de usuario por su nombre.</p> <p>Parameters:</p> Name Type Description Default <code>state_name</code> <code>str</code> <p>Nombre del estado de usuario.</p> required <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_state_by_name(self, state_name: str) -&gt; Optional[UserState]:\n    \"\"\"\n    Obtiene un estado de usuario por su nombre.\n\n    Args:\n        state_name (str): Nombre del estado de usuario.\n\n    Returns:\n        Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(UserState).filter(UserState.nombre == state_name).first()\n</code></pre>"},{"location":"user/repository/#metodos-de-rol","title":"M\u00e9todos de Rol","text":""},{"location":"user/repository/#obtener-rol-por-id","title":"Obtener Rol por ID","text":"<p>Obtiene un rol por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>int</code> <p>ID del rol.</p> required <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>Optional[Role]: El rol si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_role_by_id(self, role_id: int) -&gt; Optional[Role]:\n    \"\"\"\n    Obtiene un rol por su ID.\n\n    Args:\n        role_id (int): ID del rol.\n\n    Returns:\n        Optional[Role]: El rol si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(Role).filter(Role.id == role_id).first()\n</code></pre>"},{"location":"user/repository/#obtener-rol-por-nombre","title":"Obtener Rol por Nombre","text":"<p>Obtiene un rol por su nombre.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Nombre del rol.</p> required <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>Optional[Role]: El rol si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_role_by_name(self, role_name: str) -&gt; Optional[Role]:\n    \"\"\"\n    Obtiene un rol por su nombre.\n\n    Args:\n        role_name (str): Nombre del rol.\n\n    Returns:\n        Optional[Role]: El rol si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(Role).filter(Role.nombre == role_name).first()\n</code></pre>"},{"location":"user/repository/#constantes","title":"Constantes","text":"<p>El m\u00f3dulo define las siguientes constantes:</p> <ul> <li><code>ADMIN_ROLE_NAME</code>: Nombre del rol de administrador de finca.</li> <li><code>WORKER_ROLE_NAME</code>: Nombre del rol de trabajador agr\u00edcola.</li> <li><code>ACTIVE_STATE_NAME</code>: Nombre del estado activo de usuario.</li> <li><code>LOCKED_STATE_NAME</code>: Nombre del estado bloqueado de usuario.</li> <li><code>PENDING_STATE_NAME</code>: Nombre del estado pendiente de usuario.</li> <li><code>INACTIVE_STATE_NAME</code>: Nombre del estado inactivo de usuario.</li> </ul>"},{"location":"user/repository/#manejo-de-errores","title":"Manejo de Errores","text":"<p>Todos los m\u00e9todos que interact\u00faan con la base de datos est\u00e1n envueltos en bloques try-except para manejar posibles errores. En caso de error, se realiza un rollback de la transacci\u00f3n y se imprime un mensaje de error. Los m\u00e9todos que devuelven un valor booleano retornan <code>False</code> en caso de error, mientras que los m\u00e9todos que devuelven un objeto retornan <code>None</code>.</p>"},{"location":"user/repository/#mejores-practicas","title":"Mejores Pr\u00e1cticas","text":"<ol> <li>Uso de Sesiones: Siempre use la sesi\u00f3n de base de datos proporcionada al constructor para realizar operaciones de base de datos.</li> <li>Manejo de Transacciones: Use <code>self.db.commit()</code> para confirmar cambios y <code>self.db.rollback()</code> en caso de error.</li> <li>Logging: Considere reemplazar los <code>print</code> statements con un sistema de logging apropiado para un mejor seguimiento de errores en producci\u00f3n.</li> <li>Tipado: El uso de type hints mejora la legibilidad y permite un mejor an\u00e1lisis est\u00e1tico del c\u00f3digo.</li> <li>Documentaci\u00f3n: Mantenga los docstrings actualizados y detallados para facilitar el uso y mantenimiento del c\u00f3digo.</li> </ol>"},{"location":"user/schemas/","title":"Modelos de Usuario","text":"<p>Este documento describe los modelos Pydantic utilizados para la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/schemas/#esquemas-de-solicitud-y-respuesta","title":"Esquemas de Solicitud y Respuesta","text":""},{"location":"user/schemas/#crear-usuario","title":"Crear Usuario","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para crear un nuevo usuario.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserCreate(BaseModel):\n    \"\"\"\n    Esquema para crear un nuevo usuario.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        password (str): Contrase\u00f1a del usuario.\n    \"\"\"\n    email: str\n    nombre: str = Field(..., min_length=2)\n    apellido: str = Field(..., min_length=2)\n    password: str\n    acepta_terminos: bool = False\n\n    @field_validator('acepta_terminos')\n    def validate_terms_acceptance(cls, v):\n        if not v:\n            raise ValueError(\"Debes aceptar los t\u00e9rminos y condiciones para registrarte\")\n        return v\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n\n    @field_validator('password')\n    def validate_password(cls, v):\n        return validate_password(v)\n\n    @field_validator('nombre')\n    def validate_no_emojis_nombre(cls, v):\n        return validate_no_emojis(v)\n\n    @field_validator('nombre')\n    def validate_no_special_chars_nombre(cls, v):\n        return validate_no_special_chars(v)\n\n    @field_validator('nombre')\n    def validate_no_xss_nombre(cls, v):\n        return validate_no_xss(v)\n\n    @field_validator('apellido')\n    def validate_no_emojis_apellido(cls, v):\n        return validate_no_emojis(v)\n\n    @field_validator('apellido')\n    def validate_no_special_chars_apellido(cls, v):\n        return validate_no_special_chars(v)\n\n    @field_validator('apellido')\n    def validate_no_xss_apellido(cls, v):\n        return validate_no_xss(v)\n</code></pre>"},{"location":"user/schemas/#reenvio-de-pin-de-confirmacion","title":"Reenv\u00edo de PIN de Confirmaci\u00f3n","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para solicitar el reenv\u00edo del PIN de confirmaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class ResendPinConfirmRequest(BaseModel):\n    \"\"\"\n    Esquema para solicitar el reenv\u00edo del PIN de confirmaci\u00f3n.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n    \"\"\"\n    email: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#confirmacion-de-registro","title":"Confirmaci\u00f3n de Registro","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para confirmar el registro de un usuario mediante PIN.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n enviado al correo.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class ConfirmationRequest(BaseModel):\n    \"\"\"\n    Esquema para confirmar el registro de un usuario mediante PIN.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n enviado al correo.\n    \"\"\"\n    email: str\n    pin: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#inicio-de-sesion","title":"Inicio de Sesi\u00f3n","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para solicitar un inicio de sesi\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class LoginRequest(BaseModel):\n    \"\"\"\n    Esquema para solicitar un inicio de sesi\u00f3n.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n    \"\"\"\n    email: str\n    password: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#reenvio-de-pin-de-autenticacion-de-dos-factores","title":"Reenv\u00edo de PIN de Autenticaci\u00f3n de Dos Factores","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para solicitar el reenv\u00edo del PIN de autenticaci\u00f3n de dos factores.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class Resend2FARequest(BaseModel):\n    \"\"\"\n    Esquema para solicitar el reenv\u00edo del PIN de autenticaci\u00f3n de dos factores.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n    \"\"\"\n    email: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#verificacion-de-inicio-de-sesion-con-dos-factores","title":"Verificaci\u00f3n de Inicio de Sesi\u00f3n con Dos Factores","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para verificar el inicio de sesi\u00f3n con autenticaci\u00f3n de dos factores.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>pin</code> <code>str</code> <p>PIN de autenticaci\u00f3n de dos factores.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class TwoFactorAuthRequest(BaseModel):\n    \"\"\"\n    Esquema para verificar el inicio de sesi\u00f3n con autenticaci\u00f3n de dos factores.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de autenticaci\u00f3n de dos factores.\n    \"\"\"\n    email: str\n    pin: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#respuesta-de-token","title":"Respuesta de Token","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para la respuesta que contiene el token de acceso.</p> <p>Attributes:</p> Name Type Description <code>access_token</code> <code>str</code> <p>Token de acceso JWT.</p> <code>token_type</code> <code>str</code> <p>Tipo de token, generalmente \"bearer\".</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class TokenResponse(BaseModel):\n    \"\"\"\n    Esquema para la respuesta que contiene el token de acceso.\n\n    Attributes:\n        access_token (str): Token de acceso JWT.\n        token_type (str): Tipo de token, generalmente \"bearer\".\n    \"\"\"\n    access_token: str\n    token_type: str\n</code></pre>"},{"location":"user/schemas/#respuesta-de-usuario","title":"Respuesta de Usuario","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para la respuesta que contiene informaci\u00f3n del usuario.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>email</code> <code>str</code> <p>Correo electr\u00f3nico \u00fanico del usuario.</p> <code>estado</code> <code>str</code> <p>Estado actual del usuario.</p> <code>roles_fincas</code> <code>List[RoleFarm]</code> <p>Lista de roles y fincas del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserResponse(BaseModel):\n    \"\"\"\n    Esquema para la respuesta que contiene informaci\u00f3n del usuario.\n\n    Attributes:\n        id (int): Identificador \u00fanico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        email (str): Correo electr\u00f3nico \u00fanico del usuario.\n        estado (str): Estado actual del usuario.\n        roles_fincas (List[RoleFarm]): Lista de roles y fincas del usuario.\n    \"\"\"\n    id: int\n    nombre: str\n    apellido: str\n    email: EmailStr\n    estado: str\n    roles_fincas: List[RoleFarm]\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"user/schemas/#actualizar-informacion-de-usuario","title":"Actualizar Informaci\u00f3n de Usuario","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para actualizar la informaci\u00f3n del usuario actual.</p> <p>Attributes:</p> Name Type Description <code>nombre</code> <code>str</code> <p>Nuevo nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Nuevo apellido del usuario.</p> <code>email</code> <code>str</code> <p>Nuevo correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserUpdate(BaseModel):\n    \"\"\"\n    Esquema para actualizar la informaci\u00f3n del usuario actual.\n\n    Attributes:\n        nombre (str): Nuevo nombre del usuario.\n        apellido (str): Nuevo apellido del usuario.\n        email (str): Nuevo correo electr\u00f3nico del usuario.\n    \"\"\"\n    nombre: str\n    apellido: str\n    email: str\n\n    model_config = ConfigDict(from_attributes=True)\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#recuperacion-de-contrasena","title":"Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para iniciar el proceso de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class PasswordRecoveryRequest(BaseModel):\n    \"\"\"\n    Esquema para iniciar el proceso de recuperaci\u00f3n de contrase\u00f1a.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n    \"\"\"\n    email: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#confirmacion-de-pin-de-recuperacion","title":"Confirmaci\u00f3n de PIN de Recuperaci\u00f3n","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n enviado al correo.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class PinConfirmationRequest(BaseModel):\n    \"\"\"\n    Esquema para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de recuperaci\u00f3n enviado al correo.\n    \"\"\"\n    email: str\n    pin: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n</code></pre>"},{"location":"user/schemas/#restablecer-contrasena","title":"Restablecer Contrase\u00f1a","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para restablecer la contrase\u00f1a del usuario.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>new_password</code> <code>str</code> <p>Nueva contrase\u00f1a del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class PasswordResetRequest(BaseModel):\n    \"\"\"\n    Esquema para restablecer la contrase\u00f1a del usuario.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        new_password (str): Nueva contrase\u00f1a del usuario.\n    \"\"\"\n    email: str\n    new_password: str\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n\n    @field_validator('new_password')\n    def validate_password(cls, v):\n        return validate_password(v)\n</code></pre>"},{"location":"user/schemas/#usuario-en-la-base-de-datos","title":"Usuario en la Base de Datos","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema que representa al usuario almacenado en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>email</code> <code>str</code> <p>Correo electr\u00f3nico \u00fanico del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a encriptada del usuario.</p> <code>failed_attempts</code> <code>int</code> <p>N\u00famero de intentos fallidos de inicio de sesi\u00f3n.</p> <code>locked_until</code> <code>datetime</code> <p>Fecha y hora hasta la que el usuario est\u00e1 bloqueado.</p> <code>state_id</code> <code>int</code> <p>Identificador del estado del usuario.</p> <code>roles_fincas</code> <code>List[RoleFarm]</code> <p>Lista de roles y fincas del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserInDB(BaseModel):\n    \"\"\"\n    Esquema que representa al usuario almacenado en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        email (str): Correo electr\u00f3nico \u00fanico del usuario.\n        password (str): Contrase\u00f1a encriptada del usuario.\n        failed_attempts (int): N\u00famero de intentos fallidos de inicio de sesi\u00f3n.\n        locked_until (datetime): Fecha y hora hasta la que el usuario est\u00e1 bloqueado.\n        state_id (int): Identificador del estado del usuario.\n        roles_fincas (List[RoleFarm]): Lista de roles y fincas del usuario.\n    \"\"\"\n    id: int\n    nombre: str\n    apellido: str\n    email: str\n    password: str\n    failed_attempts: int\n    locked_until: datetime\n    state_id: int\n    roles_fincas: List[RoleFarm]\n\n    model_config = ConfigDict(from_attributes=True)\n\n    @field_validator('email')\n    def validate_email(cls, v):\n        return validate_email(v)\n\n    @field_validator('password')\n    def validate_password(cls, v):\n        return validate_password(v)\n</code></pre>"},{"location":"user/use_cases/","title":"Casos de Uso de Usuario","text":"<p>Este documento describe los casos de uso relacionados con la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/use_cases/#proceso-de-creacion-de-usuario","title":"Proceso de Creaci\u00f3n de Usuario","text":""},{"location":"user/use_cases/#caso-de-uso-creacion-de-usuario","title":"Caso de Uso: Creaci\u00f3n de Usuario","text":"<p>Caso de uso para la creaci\u00f3n de un nuevo usuario en el sistema.</p> <p>Esta clase maneja la l\u00f3gica de negocio para el registro de nuevos usuarios, incluyendo la validaci\u00f3n de datos, la creaci\u00f3n del usuario en la base de datos, y el env\u00edo de correos de confirmaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>class UserRegisterUseCase:\n    \"\"\"\n    Caso de uso para la creaci\u00f3n de un nuevo usuario en el sistema.\n\n    Esta clase maneja la l\u00f3gica de negocio para el registro de nuevos usuarios,\n    incluyendo la validaci\u00f3n de datos, la creaci\u00f3n del usuario en la base de datos,\n    y el env\u00edo de correos de confirmaci\u00f3n.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de UserRegisterUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def register_user(self, user_data: UserCreate, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Crea un nuevo usuario en el sistema.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Verifica si el usuario ya existe.\n        2. Verifica si la confirmaci\u00f3n del usuario ha expirado.\n        3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada.\n        4. Crea un nuevo usuario con estado pendiente.\n        5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.\n\n        Args:\n            user_data (UserCreate): Datos del usuario a crear.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n        Raises:\n            DomainException: Si ocurre un error durante el proceso de creaci\u00f3n.\n            UserStateException: Si el estado del usuario no es v\u00e1lido.\n        \"\"\"\n        user = self.user_repository.get_user_with_confirmation(user_data.email)\n\n        if user:\n            confirmations = self.user_service.get_last(user.confirmacion)\n            expired_confirmation = confirmations if confirmations and self.user_service.is_expired(confirmations) else None\n            if expired_confirmation:\n                self.user_repository.delete_user(user)\n            else:\n                state_validation_result = self.state_validator.validate_user_state(\n                    user,\n                    disallowed_states=[UserState.ACTIVE, UserState.PENDING, UserState.INACTIVE, UserState.LOCKED]\n                )\n                if state_validation_result:\n                    return state_validation_result\n\n        if not user_data.acepta_terminos:\n            raise DomainException(\n                message=\"Debes aceptar los t\u00e9rminos y condiciones para registrarte.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        # Obtener estado \"pendiente\" del usuario (cach\u00e9 o consulta \u00fanica)\n        pending_state_id = self.user_service.get_user_state(self.user_service.PENDING_STATE_NAME).id\n        if not pending_state_id:\n            raise UserStateException(\n                message=\"No se pudo encontrar el estado de usuario pendiente.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n\n        # Hash del password\n        hashed_password = hash_password(user_data.password)\n\n        user_data.password = hashed_password\n\n        # Crear nuevo usuario\n        created_user = self.user_repository.add_user(user_data, pending_state_id)\n\n        # Generar PIN y su hash\n        pin, pin_hash = generate_pin()\n\n        expiration_datetime = self.user_service.expiration_time()\n\n        if not self.user_repository.add_user_confirmation(user_id=created_user.id, pin_hash=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time()):\n            raise DomainException(\n                message=\"Error al agregar la confirmaci\u00f3n del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        # Enviar correo de confirmaci\u00f3n de manera as\u00edncrona\n        background_tasks.add_task(self.send_confirmation_email, created_user.email, pin)\n\n        return SuccessResponse(\n                message=\"Usuario creado. Por favor, revisa tu email para confirmar el registro.\"\n            )\n\n    def send_confirmation_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n            pin (str): PIN de confirmaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n        \"\"\"\n        subject = \"Confirma tu registro en AgroInSight\"\n        text_content = f\"Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        return send_email(email, subject, text_content, html_content)\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para el registro de nuevos usuarios, incluyendo la validaci\u00f3n de datos, la creaci\u00f3n del usuario en la base de datos, y el env\u00edo de correos de confirmaci\u00f3n.</p>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de UserRegisterUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de UserRegisterUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.register_user","title":"<code>register_user(user_data, background_tasks)</code>","text":"<p>Crea un nuevo usuario en el sistema.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario ya existe. 2. Verifica si la confirmaci\u00f3n del usuario ha expirado. 3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada. 4. Crea un nuevo usuario con estado pendiente. 5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>UserCreate</code> <p>Datos del usuario a crear.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre un error durante el proceso de creaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def register_user(self, user_data: UserCreate, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Crea un nuevo usuario en el sistema.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario ya existe.\n    2. Verifica si la confirmaci\u00f3n del usuario ha expirado.\n    3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada.\n    4. Crea un nuevo usuario con estado pendiente.\n    5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.\n\n    Args:\n        user_data (UserCreate): Datos del usuario a crear.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        DomainException: Si ocurre un error durante el proceso de creaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(user_data.email)\n\n    if user:\n        confirmations = self.user_service.get_last(user.confirmacion)\n        expired_confirmation = confirmations if confirmations and self.user_service.is_expired(confirmations) else None\n        if expired_confirmation:\n            self.user_repository.delete_user(user)\n        else:\n            state_validation_result = self.state_validator.validate_user_state(\n                user,\n                disallowed_states=[UserState.ACTIVE, UserState.PENDING, UserState.INACTIVE, UserState.LOCKED]\n            )\n            if state_validation_result:\n                return state_validation_result\n\n    if not user_data.acepta_terminos:\n        raise DomainException(\n            message=\"Debes aceptar los t\u00e9rminos y condiciones para registrarte.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Obtener estado \"pendiente\" del usuario (cach\u00e9 o consulta \u00fanica)\n    pending_state_id = self.user_service.get_user_state(self.user_service.PENDING_STATE_NAME).id\n    if not pending_state_id:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario pendiente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    # Hash del password\n    hashed_password = hash_password(user_data.password)\n\n    user_data.password = hashed_password\n\n    # Crear nuevo usuario\n    created_user = self.user_repository.add_user(user_data, pending_state_id)\n\n    # Generar PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    if not self.user_repository.add_user_confirmation(user_id=created_user.id, pin_hash=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time()):\n        raise DomainException(\n            message=\"Error al agregar la confirmaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar correo de confirmaci\u00f3n de manera as\u00edncrona\n    background_tasks.add_task(self.send_confirmation_email, created_user.email, pin)\n\n    return SuccessResponse(\n            message=\"Usuario creado. Por favor, revisa tu email para confirmar el registro.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.send_confirmation_email","title":"<code>send_confirmation_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def send_confirmation_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"Confirma tu registro en AgroInSight\"\n    text_content = f\"Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-creacion-de-usuario","title":"M\u00e9todos Principales de creaci\u00f3n de usuario","text":""},{"location":"user/use_cases/#register_user","title":"register_user","text":"<p>Crea un nuevo usuario en el sistema.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario ya existe. 2. Verifica si la confirmaci\u00f3n del usuario ha expirado. 3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada. 4. Crea un nuevo usuario con estado pendiente. 5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>UserCreate</code> <p>Datos del usuario a crear.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre un error durante el proceso de creaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def register_user(self, user_data: UserCreate, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Crea un nuevo usuario en el sistema.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario ya existe.\n    2. Verifica si la confirmaci\u00f3n del usuario ha expirado.\n    3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada.\n    4. Crea un nuevo usuario con estado pendiente.\n    5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.\n\n    Args:\n        user_data (UserCreate): Datos del usuario a crear.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        DomainException: Si ocurre un error durante el proceso de creaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(user_data.email)\n\n    if user:\n        confirmations = self.user_service.get_last(user.confirmacion)\n        expired_confirmation = confirmations if confirmations and self.user_service.is_expired(confirmations) else None\n        if expired_confirmation:\n            self.user_repository.delete_user(user)\n        else:\n            state_validation_result = self.state_validator.validate_user_state(\n                user,\n                disallowed_states=[UserState.ACTIVE, UserState.PENDING, UserState.INACTIVE, UserState.LOCKED]\n            )\n            if state_validation_result:\n                return state_validation_result\n\n    if not user_data.acepta_terminos:\n        raise DomainException(\n            message=\"Debes aceptar los t\u00e9rminos y condiciones para registrarte.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Obtener estado \"pendiente\" del usuario (cach\u00e9 o consulta \u00fanica)\n    pending_state_id = self.user_service.get_user_state(self.user_service.PENDING_STATE_NAME).id\n    if not pending_state_id:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario pendiente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    # Hash del password\n    hashed_password = hash_password(user_data.password)\n\n    user_data.password = hashed_password\n\n    # Crear nuevo usuario\n    created_user = self.user_repository.add_user(user_data, pending_state_id)\n\n    # Generar PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    if not self.user_repository.add_user_confirmation(user_id=created_user.id, pin_hash=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time()):\n        raise DomainException(\n            message=\"Error al agregar la confirmaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar correo de confirmaci\u00f3n de manera as\u00edncrona\n    background_tasks.add_task(self.send_confirmation_email, created_user.email, pin)\n\n    return SuccessResponse(\n            message=\"Usuario creado. Por favor, revisa tu email para confirmar el registro.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#send_confirmation_email","title":"send_confirmation_email","text":"<p>Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def send_confirmation_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"Confirma tu registro en AgroInSight\"\n    text_content = f\"Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-confirmacion-de-usuario","title":"Caso de Uso: Confirmaci\u00f3n de Usuario","text":"<p>Caso de uso para la confirmaci\u00f3n del registro de un usuario en el sistema.</p> <p>Esta clase maneja la l\u00f3gica de negocio para confirmar el registro de usuarios, incluyendo la validaci\u00f3n del PIN, la activaci\u00f3n del usuario y la gesti\u00f3n de intentos fallidos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>class ConfirmationUseCase:\n    \"\"\"\n    Caso de uso para la confirmaci\u00f3n del registro de un usuario en el sistema.\n\n    Esta clase maneja la l\u00f3gica de negocio para confirmar el registro de usuarios,\n    incluyendo la validaci\u00f3n del PIN, la activaci\u00f3n del usuario y la gesti\u00f3n de intentos fallidos.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ConfirmationUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def confirm_user(self, email: str, pin: str) -&gt; SuccessResponse:\n        \"\"\"\n        Confirma el registro de un usuario mediante un PIN.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Obtiene el usuario por correo electr\u00f3nico.\n        2. Valida el estado del usuario.\n        3. Verifica la existencia de una confirmaci\u00f3n pendiente.\n        4. Comprueba si la confirmaci\u00f3n ha expirado.\n        5. Verifica el PIN proporcionado.\n        6. Activa el usuario si el PIN es correcto.\n        7. Elimina el registro de confirmaci\u00f3n.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            pin (str): PIN de confirmaci\u00f3n proporcionado por el usuario.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si ocurre un error durante el proceso de confirmaci\u00f3n.\n            UserStateException: Si el estado del usuario no es v\u00e1lido.\n        \"\"\"\n        # Obtener el usuario por correo electr\u00f3nico\n        user = self.user_repository.get_user_with_confirmation(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        # Validar el estado del usuario\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.PENDING],\n            disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        # Verificar si hay una confirmaci\u00f3n pendiente\n        confirmation = self.user_service.get_last(user.confirmacion)\n        if not confirmation:\n            raise DomainException(\n                message=\"No hay un registro de confirmaci\u00f3n para este usuario.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Verificar si la confirmaci\u00f3n est\u00e1 expirada\n        if self.user_service.is_expired(confirmation):\n            # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n            self.user_repository.delete_user(user)\n            raise DomainException(\n                message=\"La confirmaci\u00f3n ha expirado. Por favor, inicie el proceso de registro nuevamente.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        # Hashear el PIN proporcionado\n        confirm_pin = self.user_service.verify_pin(confirmation, pin)\n\n        if not confirm_pin:\n            # Manejar intentos fallidos de confirmaci\u00f3n\n            intentos = self.user_service.increment_attempts(confirmation)\n            if intentos &gt;= 3:\n                # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n                self.user_repository.delete_user(user)\n                raise DomainException(\n                    message=\"Demasiados intentos. Por favor, inicie el proceso de registro nuevamente.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n            raise DomainException(\n                message=\"PIN de confirmaci\u00f3n incorrecto.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n\n        self.activate_user(user)\n\n        # Eliminar el registro de confirmaci\u00f3n\n        self.user_repository.delete_user_confirmation(confirmation)\n\n        return SuccessResponse(\n                message=\"Usuario confirmado exitosamente.\"\n            )\n\n    def activate_user(self, user: UserInDB) -&gt; None:\n        \"\"\"\n        Activa el usuario cambiando su estado a activo.\n\n        Args:\n            user (User): Objeto de usuario a activar.\n\n        Raises:\n            UserStateException: Si no se puede encontrar el estado de usuario activo.\n        \"\"\"\n        active_state = self.user_service.get_user_state(self.user_service.ACTIVE_STATE_NAME)\n        if not active_state:\n            raise UserStateException(\n                message=\"No se pudo encontrar el estado de usuario activo.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n        user.state_id = active_state.id\n        self.user_repository.update_user(user)\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para confirmar el registro de usuarios mediante un PIN, incluyendo la validaci\u00f3n del PIN, la activaci\u00f3n del usuario y la gesti\u00f3n de intentos fallidos.</p>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ConfirmationUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ConfirmationUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.activate_user","title":"<code>activate_user(user)</code>","text":"<p>Activa el usuario cambiando su estado a activo.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario a activar.</p> required <p>Raises:</p> Type Description <code>UserStateException</code> <p>Si no se puede encontrar el estado de usuario activo.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def activate_user(self, user: UserInDB) -&gt; None:\n    \"\"\"\n    Activa el usuario cambiando su estado a activo.\n\n    Args:\n        user (User): Objeto de usuario a activar.\n\n    Raises:\n        UserStateException: Si no se puede encontrar el estado de usuario activo.\n    \"\"\"\n    active_state = self.user_service.get_user_state(self.user_service.ACTIVE_STATE_NAME)\n    if not active_state:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario activo.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n    user.state_id = active_state.id\n    self.user_repository.update_user(user)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.confirm_user","title":"<code>confirm_user(email, pin)</code>","text":"<p>Confirma el registro de un usuario mediante un PIN.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Obtiene el usuario por correo electr\u00f3nico. 2. Valida el estado del usuario. 3. Verifica la existencia de una confirmaci\u00f3n pendiente. 4. Comprueba si la confirmaci\u00f3n ha expirado. 5. Verifica el PIN proporcionado. 6. Activa el usuario si el PIN es correcto. 7. Elimina el registro de confirmaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de confirmaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def confirm_user(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el registro de un usuario mediante un PIN.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Obtiene el usuario por correo electr\u00f3nico.\n    2. Valida el estado del usuario.\n    3. Verifica la existencia de una confirmaci\u00f3n pendiente.\n    4. Comprueba si la confirmaci\u00f3n ha expirado.\n    5. Verifica el PIN proporcionado.\n    6. Activa el usuario si el PIN es correcto.\n    7. Elimina el registro de confirmaci\u00f3n.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de confirmaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    # Obtener el usuario por correo electr\u00f3nico\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    confirmation = self.user_service.get_last(user.confirmacion)\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay un registro de confirmaci\u00f3n para este usuario.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si la confirmaci\u00f3n est\u00e1 expirada\n    if self.user_service.is_expired(confirmation):\n        # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n        self.user_repository.delete_user(user)\n        raise DomainException(\n            message=\"La confirmaci\u00f3n ha expirado. Por favor, inicie el proceso de registro nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Hashear el PIN proporcionado\n    confirm_pin = self.user_service.verify_pin(confirmation, pin)\n\n    if not confirm_pin:\n        # Manejar intentos fallidos de confirmaci\u00f3n\n        intentos = self.user_service.increment_attempts(confirmation)\n        if intentos &gt;= 3:\n            # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n            self.user_repository.delete_user(user)\n            raise DomainException(\n                message=\"Demasiados intentos. Por favor, inicie el proceso de registro nuevamente.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n        raise DomainException(\n            message=\"PIN de confirmaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n\n    self.activate_user(user)\n\n    # Eliminar el registro de confirmaci\u00f3n\n    self.user_repository.delete_user_confirmation(confirmation)\n\n    return SuccessResponse(\n            message=\"Usuario confirmado exitosamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-confirmacion-de-usuario","title":"M\u00e9todos Principales de confirmaci\u00f3n de usuario","text":""},{"location":"user/use_cases/#confirm_user","title":"confirm_user","text":"<p>Confirma el registro de un usuario mediante un PIN.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Obtiene el usuario por correo electr\u00f3nico. 2. Valida el estado del usuario. 3. Verifica la existencia de una confirmaci\u00f3n pendiente. 4. Comprueba si la confirmaci\u00f3n ha expirado. 5. Verifica el PIN proporcionado. 6. Activa el usuario si el PIN es correcto. 7. Elimina el registro de confirmaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de confirmaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def confirm_user(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el registro de un usuario mediante un PIN.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Obtiene el usuario por correo electr\u00f3nico.\n    2. Valida el estado del usuario.\n    3. Verifica la existencia de una confirmaci\u00f3n pendiente.\n    4. Comprueba si la confirmaci\u00f3n ha expirado.\n    5. Verifica el PIN proporcionado.\n    6. Activa el usuario si el PIN es correcto.\n    7. Elimina el registro de confirmaci\u00f3n.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de confirmaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    # Obtener el usuario por correo electr\u00f3nico\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    confirmation = self.user_service.get_last(user.confirmacion)\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay un registro de confirmaci\u00f3n para este usuario.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si la confirmaci\u00f3n est\u00e1 expirada\n    if self.user_service.is_expired(confirmation):\n        # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n        self.user_repository.delete_user(user)\n        raise DomainException(\n            message=\"La confirmaci\u00f3n ha expirado. Por favor, inicie el proceso de registro nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Hashear el PIN proporcionado\n    confirm_pin = self.user_service.verify_pin(confirmation, pin)\n\n    if not confirm_pin:\n        # Manejar intentos fallidos de confirmaci\u00f3n\n        intentos = self.user_service.increment_attempts(confirmation)\n        if intentos &gt;= 3:\n            # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n            self.user_repository.delete_user(user)\n            raise DomainException(\n                message=\"Demasiados intentos. Por favor, inicie el proceso de registro nuevamente.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n        raise DomainException(\n            message=\"PIN de confirmaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n\n    self.activate_user(user)\n\n    # Eliminar el registro de confirmaci\u00f3n\n    self.user_repository.delete_user_confirmation(confirmation)\n\n    return SuccessResponse(\n            message=\"Usuario confirmado exitosamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-reenvio-de-confirmacion","title":"Caso de Uso: Reenv\u00edo de Confirmaci\u00f3n","text":"<p>Caso de uso para reenviar la confirmaci\u00f3n de registro a un usuario.</p> <p>Esta clase maneja la l\u00f3gica de negocio para reenviar PINs de confirmaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la generaci\u00f3n de nuevos PINs, y el env\u00edo de correos electr\u00f3nicos de confirmaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>class ResendConfirmationUseCase:\n    \"\"\"\n    Caso de uso para reenviar la confirmaci\u00f3n de registro a un usuario.\n\n    Esta clase maneja la l\u00f3gica de negocio para reenviar PINs de confirmaci\u00f3n,\n    incluyendo la validaci\u00f3n del estado del usuario, la generaci\u00f3n de nuevos PINs,\n    y el env\u00edo de correos electr\u00f3nicos de confirmaci\u00f3n.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ResendConfirmationUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def resend_confirmation(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Verifica si el usuario existe.\n        2. Valida el estado del usuario.\n        3. Obtiene la \u00faltima confirmaci\u00f3n del usuario.\n        4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera).\n        5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n.\n        6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si ocurre un error durante el proceso de reenv\u00edo.\n        \"\"\"\n        user = self.user_repository.get_user_with_confirmation(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        # Validar el estado del usuario\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.PENDING],\n            disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        # Obtener confirmaci\u00f3n del usuario\n        confirmation = self.user_service.get_last(user.confirmacion)\n\n        # Verificar si hay una confirmaci\u00f3n pendiente\n        if not confirmation:\n            raise DomainException(\n                message=\"No hay una confirmaci\u00f3n pendiente para reenviar el PIN.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Definimos el tiempo de espera en minutos\n        warning_time = WARNING_TIME\n\n        # Si es el primer reenv\u00edo (resends == 0), permitir sin restricci\u00f3n\n        if confirmation.resends &gt; 0:\n            # Si ya ha reenviado al menos una vez, verificar si han pasado 3 minutos\n            if self.user_service.is_recently_requested(confirmation, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n        # Generar nuevo PIN y su hash\n        pin, pin_hash = generate_pin()\n\n        expiration_datetime = self.user_service.expiration_time()\n\n        # Actualizar el registro de confirmaci\u00f3n de usuario con manejo de errores\n        confirmation.pin = pin_hash\n        confirmation.expiracion = expiration_datetime\n        confirmation.resends += 1\n        confirmation.intentos = 0\n        confirmation.created_at = datetime_utc_time()\n\n        if not self.user_repository.update_user_confirmation(confirmation):\n            # Log the error or handle it as needed\n            raise DomainException(\n                message=\"Error al actualizar la confirmaci\u00f3n del usuario\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        # Enviar el correo electr\u00f3nico con el nuevo PIN\n        background_tasks.add_task(self.resend_confirmation_email, email, pin)\n\n        return SuccessResponse(\n            message=\"PIN de confirmaci\u00f3n reenviado con \u00e9xito.\"\n        )\n\n    def resend_confirmation_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de confirmaci\u00f3n reenviado.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n            pin (str): Nuevo PIN de confirmaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n        \"\"\"\n        subject = \"Confirma tu registro en AgroInSight\"\n        text_content = f\"Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        return send_email(email, subject, text_content, html_content)\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para reenviar PINs de confirmaci\u00f3n a usuarios que est\u00e1n en proceso de registro.</p>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ResendConfirmationUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ResendConfirmationUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.resend_confirmation","title":"<code>resend_confirmation(email, background_tasks)</code>","text":"<p>Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario existe. 2. Valida el estado del usuario. 3. Obtiene la \u00faltima confirmaci\u00f3n del usuario. 4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera). 5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n. 6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de reenv\u00edo.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def resend_confirmation(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario existe.\n    2. Valida el estado del usuario.\n    3. Obtiene la \u00faltima confirmaci\u00f3n del usuario.\n    4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera).\n    5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n.\n    6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de reenv\u00edo.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Obtener confirmaci\u00f3n del usuario\n    confirmation = self.user_service.get_last(user.confirmacion)\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay una confirmaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Definimos el tiempo de espera en minutos\n    warning_time = WARNING_TIME\n\n    # Si es el primer reenv\u00edo (resends == 0), permitir sin restricci\u00f3n\n    if confirmation.resends &gt; 0:\n        # Si ya ha reenviado al menos una vez, verificar si han pasado 3 minutos\n        if self.user_service.is_recently_requested(confirmation, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    # Generar nuevo PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    # Actualizar el registro de confirmaci\u00f3n de usuario con manejo de errores\n    confirmation.pin = pin_hash\n    confirmation.expiracion = expiration_datetime\n    confirmation.resends += 1\n    confirmation.intentos = 0\n    confirmation.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_user_confirmation(confirmation):\n        # Log the error or handle it as needed\n        raise DomainException(\n            message=\"Error al actualizar la confirmaci\u00f3n del usuario\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar el correo electr\u00f3nico con el nuevo PIN\n    background_tasks.add_task(self.resend_confirmation_email, email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de confirmaci\u00f3n reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.resend_confirmation_email","title":"<code>resend_confirmation_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de confirmaci\u00f3n reenviado.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>Nuevo PIN de confirmaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def resend_confirmation_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de confirmaci\u00f3n reenviado.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): Nuevo PIN de confirmaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"Confirma tu registro en AgroInSight\"\n    text_content = f\"Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-reenvio-de-confirmacion","title":"M\u00e9todos Principales de reenv\u00edo de confirmaci\u00f3n","text":""},{"location":"user/use_cases/#resend_confirmation","title":"resend_confirmation","text":"<p>Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario existe. 2. Valida el estado del usuario. 3. Obtiene la \u00faltima confirmaci\u00f3n del usuario. 4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera). 5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n. 6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de reenv\u00edo.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def resend_confirmation(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario existe.\n    2. Valida el estado del usuario.\n    3. Obtiene la \u00faltima confirmaci\u00f3n del usuario.\n    4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera).\n    5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n.\n    6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de reenv\u00edo.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Obtener confirmaci\u00f3n del usuario\n    confirmation = self.user_service.get_last(user.confirmacion)\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay una confirmaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Definimos el tiempo de espera en minutos\n    warning_time = WARNING_TIME\n\n    # Si es el primer reenv\u00edo (resends == 0), permitir sin restricci\u00f3n\n    if confirmation.resends &gt; 0:\n        # Si ya ha reenviado al menos una vez, verificar si han pasado 3 minutos\n        if self.user_service.is_recently_requested(confirmation, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    # Generar nuevo PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    # Actualizar el registro de confirmaci\u00f3n de usuario con manejo de errores\n    confirmation.pin = pin_hash\n    confirmation.expiracion = expiration_datetime\n    confirmation.resends += 1\n    confirmation.intentos = 0\n    confirmation.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_user_confirmation(confirmation):\n        # Log the error or handle it as needed\n        raise DomainException(\n            message=\"Error al actualizar la confirmaci\u00f3n del usuario\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar el correo electr\u00f3nico con el nuevo PIN\n    background_tasks.add_task(self.resend_confirmation_email, email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de confirmaci\u00f3n reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#proceso-de-inicio-de-sesion","title":"Proceso de Inicio de Sesi\u00f3n","text":""},{"location":"user/use_cases/#caso-de-uso-inicio-de-sesion","title":"Caso de Uso: Inicio de Sesi\u00f3n","text":"<p>Caso de uso para el proceso de inicio de sesi\u00f3n.</p> <p>Esta clase maneja la l\u00f3gica de negocio para el inicio de sesi\u00f3n de usuarios, incluyendo la validaci\u00f3n de credenciales, el manejo de intentos fallidos, y la generaci\u00f3n de PIN para autenticaci\u00f3n de dos factores.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>class LoginUseCase:\n    \"\"\"\n    Caso de uso para el proceso de inicio de sesi\u00f3n.\n\n    Esta clase maneja la l\u00f3gica de negocio para el inicio de sesi\u00f3n de usuarios,\n    incluyendo la validaci\u00f3n de credenciales, el manejo de intentos fallidos,\n    y la generaci\u00f3n de PIN para autenticaci\u00f3n de dos factores.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de LoginUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def login_user(self, email: str, password: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Inicia el proceso de inicio de sesi\u00f3n para un usuario.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Verifica la existencia del usuario.\n        2. Valida el estado del usuario.\n        3. Verifica la contrase\u00f1a.\n        4. Maneja intentos fallidos de inicio de sesi\u00f3n.\n        5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            password (str): Contrase\u00f1a del usuario.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si ocurre un error durante el proceso de inicio de sesi\u00f3n.\n            UserHasBeenBlockedException: Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.\n        \"\"\"\n        user = self.user_repository.get_user_with_two_factor_verification(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        # Validar el estado del usuario\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        # Verificar si verification trajo una lista de varias verificaciones,\n        verification = self.user_service.get_last(user.verificacion_dos_pasos)\n\n        # Verificar si ya se ha enviado un PIN en los ltimos 3 minutos\n        warning_time = WARNING_TIME\n\n        if verification:\n            if self.user_service.is_recently_requested(verification, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n            # Eliminar verificaciones de dos pasos expiradas\n            self.user_repository.delete_two_factor_verification(verification)\n\n        if not verify_password(password, user.password):\n            self.handle_failed_login_attempt(user)\n\n        # Autenticaci\u00f3n exitosa\n        user.failed_attempts = 0\n        user.locked_until = None\n        self.user_repository.update_user(user)\n\n        # Generar el PIN y su hash\n        pin, pin_hash = generate_pin()\n\n        expiration_datetime = self.user_service.expiration_time()\n\n        self.user_repository.add_two_factor_verification(user_id=user.id, pin_hash=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time())\n\n        # Enviar el PIN al correo electr\u00f3nico del usuario\n        background_tasks.add_task(self.send_two_factor_verification_email, user.email, pin)\n\n        return SuccessResponse(\n            message=\"Verificaci\u00f3n en dos pasos iniciada. Por favor, revisa tu correo electr\u00f3nico para obtener el PIN.\"\n        )\n\n    def handle_failed_login_attempt(self, user: UserInDB) -&gt; None:\n        \"\"\"\n        Maneja un intento fallido de inicio de sesi\u00f3n.\n\n        Incrementa el contador de intentos fallidos y bloquea al usuario si se excede el l\u00edmite.\n\n        Args:\n            user (User): El usuario que ha fallado en el intento de inicio de sesi\u00f3n.\n\n        Raises:\n            UserHasBeenBlockedException: Si el usuario es bloqueado debido a m\u00faltiples intentos fallidos.\n            DomainException: Si la contrase\u00f1a es incorrecta pero no se ha alcanzado el l\u00edmite de intentos.\n        \"\"\"\n        max_failed_attempts = 3\n        block_time = 10\n\n        user.failed_attempts += 1\n        self.user_repository.update_user(user)\n\n        if user.failed_attempts &gt;= max_failed_attempts:\n            self.user_service.block_user(user, timedelta(minutes=block_time))\n            raise UserHasBeenBlockedException(block_time)\n\n        raise DomainException(\n            message=\"Contrase\u00f1a incorrecta.\",\n            status_code=status.HTTP_401_UNAUTHORIZED\n        )\n\n    def send_two_factor_verification_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n            pin (str): PIN de verificaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n        \"\"\"\n        subject = \"PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n        text_content = f\"Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n        return send_email(email, subject, text_content, html_content)\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para el inicio de sesi\u00f3n de usuarios, incluyendo la validaci\u00f3n de credenciales, el manejo de intentos fallidos, y la generaci\u00f3n de PIN para autenticaci\u00f3n de dos factores.</p>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de LoginUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de LoginUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.handle_failed_login_attempt","title":"<code>handle_failed_login_attempt(user)</code>","text":"<p>Maneja un intento fallido de inicio de sesi\u00f3n.</p> <p>Incrementa el contador de intentos fallidos y bloquea al usuario si se excede el l\u00edmite.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>El usuario que ha fallado en el intento de inicio de sesi\u00f3n.</p> required <p>Raises:</p> Type Description <code>UserHasBeenBlockedException</code> <p>Si el usuario es bloqueado debido a m\u00faltiples intentos fallidos.</p> <code>DomainException</code> <p>Si la contrase\u00f1a es incorrecta pero no se ha alcanzado el l\u00edmite de intentos.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def handle_failed_login_attempt(self, user: UserInDB) -&gt; None:\n    \"\"\"\n    Maneja un intento fallido de inicio de sesi\u00f3n.\n\n    Incrementa el contador de intentos fallidos y bloquea al usuario si se excede el l\u00edmite.\n\n    Args:\n        user (User): El usuario que ha fallado en el intento de inicio de sesi\u00f3n.\n\n    Raises:\n        UserHasBeenBlockedException: Si el usuario es bloqueado debido a m\u00faltiples intentos fallidos.\n        DomainException: Si la contrase\u00f1a es incorrecta pero no se ha alcanzado el l\u00edmite de intentos.\n    \"\"\"\n    max_failed_attempts = 3\n    block_time = 10\n\n    user.failed_attempts += 1\n    self.user_repository.update_user(user)\n\n    if user.failed_attempts &gt;= max_failed_attempts:\n        self.user_service.block_user(user, timedelta(minutes=block_time))\n        raise UserHasBeenBlockedException(block_time)\n\n    raise DomainException(\n        message=\"Contrase\u00f1a incorrecta.\",\n        status_code=status.HTTP_401_UNAUTHORIZED\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.login_user","title":"<code>login_user(email, password, background_tasks)</code>","text":"<p>Inicia el proceso de inicio de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica la existencia del usuario. 2. Valida el estado del usuario. 3. Verifica la contrase\u00f1a. 4. Maneja intentos fallidos de inicio de sesi\u00f3n. 5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de inicio de sesi\u00f3n.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def login_user(self, email: str, password: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de inicio de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica la existencia del usuario.\n    2. Valida el estado del usuario.\n    3. Verifica la contrase\u00f1a.\n    4. Maneja intentos fallidos de inicio de sesi\u00f3n.\n    5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de inicio de sesi\u00f3n.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si verification trajo una lista de varias verificaciones,\n    verification = self.user_service.get_last(user.verificacion_dos_pasos)\n\n    # Verificar si ya se ha enviado un PIN en los ltimos 3 minutos\n    warning_time = WARNING_TIME\n\n    if verification:\n        if self.user_service.is_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n        # Eliminar verificaciones de dos pasos expiradas\n        self.user_repository.delete_two_factor_verification(verification)\n\n    if not verify_password(password, user.password):\n        self.handle_failed_login_attempt(user)\n\n    # Autenticaci\u00f3n exitosa\n    user.failed_attempts = 0\n    user.locked_until = None\n    self.user_repository.update_user(user)\n\n    # Generar el PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    self.user_repository.add_two_factor_verification(user_id=user.id, pin_hash=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time())\n\n    # Enviar el PIN al correo electr\u00f3nico del usuario\n    background_tasks.add_task(self.send_two_factor_verification_email, user.email, pin)\n\n    return SuccessResponse(\n        message=\"Verificaci\u00f3n en dos pasos iniciada. Por favor, revisa tu correo electr\u00f3nico para obtener el PIN.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.send_two_factor_verification_email","title":"<code>send_two_factor_verification_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def send_two_factor_verification_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): PIN de verificaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n    text_content = f\"Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-inicio-de-sesion","title":"M\u00e9todos Principales de inicio de sesi\u00f3n","text":""},{"location":"user/use_cases/#login_user","title":"login_user","text":"<p>Inicia el proceso de inicio de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica la existencia del usuario. 2. Valida el estado del usuario. 3. Verifica la contrase\u00f1a. 4. Maneja intentos fallidos de inicio de sesi\u00f3n. 5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de inicio de sesi\u00f3n.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def login_user(self, email: str, password: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de inicio de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica la existencia del usuario.\n    2. Valida el estado del usuario.\n    3. Verifica la contrase\u00f1a.\n    4. Maneja intentos fallidos de inicio de sesi\u00f3n.\n    5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de inicio de sesi\u00f3n.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si verification trajo una lista de varias verificaciones,\n    verification = self.user_service.get_last(user.verificacion_dos_pasos)\n\n    # Verificar si ya se ha enviado un PIN en los ltimos 3 minutos\n    warning_time = WARNING_TIME\n\n    if verification:\n        if self.user_service.is_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n        # Eliminar verificaciones de dos pasos expiradas\n        self.user_repository.delete_two_factor_verification(verification)\n\n    if not verify_password(password, user.password):\n        self.handle_failed_login_attempt(user)\n\n    # Autenticaci\u00f3n exitosa\n    user.failed_attempts = 0\n    user.locked_until = None\n    self.user_repository.update_user(user)\n\n    # Generar el PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    self.user_repository.add_two_factor_verification(user_id=user.id, pin_hash=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time())\n\n    # Enviar el PIN al correo electr\u00f3nico del usuario\n    background_tasks.add_task(self.send_two_factor_verification_email, user.email, pin)\n\n    return SuccessResponse(\n        message=\"Verificaci\u00f3n en dos pasos iniciada. Por favor, revisa tu correo electr\u00f3nico para obtener el PIN.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-verificacion-de-autenticacion-de-dos-factores","title":"Caso de Uso: Verificaci\u00f3n de Autenticaci\u00f3n de Dos Factores","text":"<p>Caso de uso para verificar la autenticaci\u00f3n de dos factores.</p> <p>Esta clase maneja el proceso de verificaci\u00f3n del PIN de autenticaci\u00f3n de dos factores, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>class VerifyUseCase:\n    \"\"\"\n    Caso de uso para verificar la autenticaci\u00f3n de dos factores.\n\n    Esta clase maneja el proceso de verificaci\u00f3n del PIN de autenticaci\u00f3n de dos factores,\n    incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN,\n    y el manejo de intentos fallidos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de VerifyUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def verify_2fa(self, email: str, pin: str) -&gt; TokenResponse:\n        \"\"\"\n        Verifica el PIN de autenticaci\u00f3n de dos factores.\n\n        Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n        de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja\n        los intentos fallidos.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            pin (str): PIN de verificaci\u00f3n proporcionado por el usuario.\n\n        Returns:\n            TokenResponse: Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,\n                             el PIN es incorrecto, o hay otros errores.\n            UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n        \"\"\"\n        user = self.user_repository.get_user_with_two_factor_verification(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        verification = self.user_service.get_last(user.verificacion_dos_pasos)\n        if not verification:\n            raise DomainException(\n                message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if self.user_service.is_expired(verification):\n            self.user_repository.delete_two_factor_verification(verification)\n            raise DomainException(\n                message=\"La verificaci\u00f3n ha expirado. Por favor, inicie el proceso de doble factor de autenticaci\u00f3n nuevamente.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        verify_pin = self.user_service.verify_pin(verification, pin)\n\n        if not verify_pin:\n            attempts = self.user_service.increment_attempts(verification)\n            if attempts &gt;= 3:\n                block_time = 10\n                self.user_service.block_user(user, timedelta(minutes=block_time))\n                self.user_repository.delete_two_factor_verification(verification)\n                raise UserHasBeenBlockedException(block_time)\n            raise DomainException(\n                message=\"PIN de verificaci\u00f3n incorrecto.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        self.user_repository.delete_two_factor_verification(verification)\n\n        access_token = create_access_token(data={\"sub\": user.email})\n        return TokenResponse(\n            access_token=access_token,\n            token_type=\"bearer\"\n        )\n</code></pre> <p>Este caso de uso maneja el proceso de verificaci\u00f3n del PIN de autenticaci\u00f3n de dos factores, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de VerifyUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de VerifyUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.verify_2fa","title":"<code>verify_2fa(email, pin)</code>","text":"<p>Verifica el PIN de autenticaci\u00f3n de dos factores.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>TokenResponse</code> <code>TokenResponse</code> <p>Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def verify_2fa(self, email: str, pin: str) -&gt; TokenResponse:\n    \"\"\"\n    Verifica el PIN de autenticaci\u00f3n de dos factores.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de verificaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        TokenResponse: Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.user_service.get_last(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.user_service.is_expired(verification):\n        self.user_repository.delete_two_factor_verification(verification)\n        raise DomainException(\n            message=\"La verificaci\u00f3n ha expirado. Por favor, inicie el proceso de doble factor de autenticaci\u00f3n nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    verify_pin = self.user_service.verify_pin(verification, pin)\n\n    if not verify_pin:\n        attempts = self.user_service.increment_attempts(verification)\n        if attempts &gt;= 3:\n            block_time = 10\n            self.user_service.block_user(user, timedelta(minutes=block_time))\n            self.user_repository.delete_two_factor_verification(verification)\n            raise UserHasBeenBlockedException(block_time)\n        raise DomainException(\n            message=\"PIN de verificaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    self.user_repository.delete_two_factor_verification(verification)\n\n    access_token = create_access_token(data={\"sub\": user.email})\n    return TokenResponse(\n        access_token=access_token,\n        token_type=\"bearer\"\n    )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-verificacion-de-autenticacion-de-dos-factores","title":"M\u00e9todos Principales de verificaci\u00f3n de autenticaci\u00f3n de dos factores","text":""},{"location":"user/use_cases/#verify_2fa","title":"verify_2fa","text":"<p>Verifica el PIN de autenticaci\u00f3n de dos factores.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>TokenResponse</code> <code>TokenResponse</code> <p>Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def verify_2fa(self, email: str, pin: str) -&gt; TokenResponse:\n    \"\"\"\n    Verifica el PIN de autenticaci\u00f3n de dos factores.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de verificaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        TokenResponse: Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.user_service.get_last(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.user_service.is_expired(verification):\n        self.user_repository.delete_two_factor_verification(verification)\n        raise DomainException(\n            message=\"La verificaci\u00f3n ha expirado. Por favor, inicie el proceso de doble factor de autenticaci\u00f3n nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    verify_pin = self.user_service.verify_pin(verification, pin)\n\n    if not verify_pin:\n        attempts = self.user_service.increment_attempts(verification)\n        if attempts &gt;= 3:\n            block_time = 10\n            self.user_service.block_user(user, timedelta(minutes=block_time))\n            self.user_repository.delete_two_factor_verification(verification)\n            raise UserHasBeenBlockedException(block_time)\n        raise DomainException(\n            message=\"PIN de verificaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    self.user_repository.delete_two_factor_verification(verification)\n\n    access_token = create_access_token(data={\"sub\": user.email})\n    return TokenResponse(\n        access_token=access_token,\n        token_type=\"bearer\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-reenvio-de-pin-de-verificacion-en-dos-pasos","title":"Caso de Uso: Reenv\u00edo de PIN de Verificaci\u00f3n en Dos Pasos","text":"<p>Caso de uso para reenviar el PIN de verificaci\u00f3n en dos pasos.</p> <p>Esta clase maneja el proceso de reenv\u00edo del PIN de verificaci\u00f3n en dos pasos, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>class Resend2faUseCase:\n    \"\"\"\n    Caso de uso para reenviar el PIN de verificaci\u00f3n en dos pasos.\n\n    Esta clase maneja el proceso de reenv\u00edo del PIN de verificaci\u00f3n en dos pasos,\n    incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes\n    recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de Resend2faUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def resend_2fa(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.\n\n        Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n        un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una verificaci\u00f3n pendiente, se ha solicitado\n                             un reenv\u00edo recientemente, o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_two_factor_verification(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        verification = self.user_service.get_last(user.verificacion_dos_pasos)\n        if not verification:\n            raise DomainException(\n                message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        warning_time = WARNING_TIME\n\n        if verification.resends &gt; 0:\n            if self.user_service.is_recently_requested(verification, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n        pin, pin_hash = generate_pin()\n\n        expiration_datetime = self.user_service.expiration_time()\n\n        verification.pin = pin_hash\n        verification.expiracion = expiration_datetime\n        verification.resends += 1\n        verification.intentos = 0\n        verification.created_at = datetime_utc_time()\n\n        if not self.user_repository.update_two_factor_verification(verification):\n            raise DomainException(\n                message=\"No se pudo actualizar la verificaci\u00f3n de doble factor de autenticaci\u00f3n\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        background_tasks.add_task(self.send_two_factor_pin, user.email, pin)\n\n        return SuccessResponse(\n            message=\"PIN de verificaci\u00f3n en dos pasos reenviado con \u00e9xito.\"\n        )\n\n    def send_two_factor_pin(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos reenviado.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n            pin (str): PIN de verificaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n        \"\"\"\n        subject = \"Reenv\u00edo de PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n        text_content = f\"Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        return send_email(email, subject, text_content, html_content)\n</code></pre> <p>Este caso de uso maneja el proceso de reenv\u00edo del PIN de verificaci\u00f3n en dos pasos, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de Resend2faUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de Resend2faUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.resend_2fa","title":"<code>resend_2fa(email, background_tasks)</code>","text":"<p>Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def resend_2fa(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.user_service.get_last(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = WARNING_TIME\n\n    if verification.resends &gt; 0:\n        if self.user_service.is_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    verification.pin = pin_hash\n    verification.expiracion = expiration_datetime\n    verification.resends += 1\n    verification.intentos = 0\n    verification.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_two_factor_verification(verification):\n        raise DomainException(\n            message=\"No se pudo actualizar la verificaci\u00f3n de doble factor de autenticaci\u00f3n\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    background_tasks.add_task(self.send_two_factor_pin, user.email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de verificaci\u00f3n en dos pasos reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.send_two_factor_pin","title":"<code>send_two_factor_pin(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos reenviado.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del destinatario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 exitosamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def send_two_factor_pin(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos reenviado.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n        pin (str): PIN de verificaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n    \"\"\"\n    subject = \"Reenv\u00edo de PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n    text_content = f\"Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-reenvio-de-pin-de-verificacion-en-dos-pasos","title":"M\u00e9todos Principales de reenv\u00edo de PIN de verificaci\u00f3n en dos pasos","text":""},{"location":"user/use_cases/#resend_2fa","title":"resend_2fa","text":"<p>Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def resend_2fa(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.user_service.get_last(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = WARNING_TIME\n\n    if verification.resends &gt; 0:\n        if self.user_service.is_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    verification.pin = pin_hash\n    verification.expiracion = expiration_datetime\n    verification.resends += 1\n    verification.intentos = 0\n    verification.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_two_factor_verification(verification):\n        raise DomainException(\n            message=\"No se pudo actualizar la verificaci\u00f3n de doble factor de autenticaci\u00f3n\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    background_tasks.add_task(self.send_two_factor_pin, user.email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de verificaci\u00f3n en dos pasos reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#proceso-de-recuperacion-de-contrasena","title":"Proceso de Recuperaci\u00f3n de Contrase\u00f1a","text":""},{"location":"user/use_cases/#caso-de-uso-recuperacion-de-contrasena","title":"Caso de Uso: Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Caso de uso para el proceso de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Esta clase maneja el proceso de recuperaci\u00f3n de contrase\u00f1a, incluyendo la generaci\u00f3n y env\u00edo de PIN, validaci\u00f3n del estado del usuario y gesti\u00f3n de solicitudes recientes.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>class PasswordRecoveryUseCase:\n    \"\"\"\n    Caso de uso para el proceso de recuperaci\u00f3n de contrase\u00f1a.\n\n    Esta clase maneja el proceso de recuperaci\u00f3n de contrase\u00f1a, incluyendo la generaci\u00f3n\n    y env\u00edo de PIN, validaci\u00f3n del estado del usuario y gesti\u00f3n de solicitudes recientes.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de PasswordRecoveryUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def recovery_password(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n        Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n        un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si se ha solicitado un PIN recientemente o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        warning_time = WARNING_TIME\n        recovery = self.user_service.get_last(user.recuperacion_contrasena)\n        if recovery and self.user_service.is_recently_requested(recovery, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n        self.user_repository.delete_password_recovery(recovery)\n\n        pin, pin_hash = generate_pin()\n\n        expiration_datetime = self.user_service.expiration_time()\n\n        background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n        self.user_repository.add_password_recovery(user_id=user.id, pin=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time())\n\n        return SuccessResponse(\n            message=\"Se ha enviado un PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n        )\n\n    def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n            pin (str): PIN de recuperaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n        \"\"\"\n        subject = \"Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n        text_content = f\"Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n        return send_email(email, subject, text_content, html_content)\n</code></pre> <p>Este caso de uso maneja el proceso de recuperaci\u00f3n de contrase\u00f1a, incluyendo la generaci\u00f3n y env\u00edo de PIN, validaci\u00f3n del estado del usuario y gesti\u00f3n de solicitudes recientes.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de PasswordRecoveryUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de PasswordRecoveryUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.recovery_password","title":"<code>recovery_password(email, background_tasks)</code>","text":"<p>Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si se ha solicitado un PIN recientemente o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def recovery_password(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si se ha solicitado un PIN recientemente o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    warning_time = WARNING_TIME\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n    if recovery and self.user_service.is_recently_requested(recovery, warning_time):\n        raise DomainException(\n            message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS\n        )\n\n    self.user_repository.delete_password_recovery(recovery)\n\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    self.user_repository.add_password_recovery(user_id=user.id, pin=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time())\n\n    return SuccessResponse(\n        message=\"Se ha enviado un PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.send_password_recovery_email","title":"<code>send_password_recovery_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del destinatario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 exitosamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n        pin (str): PIN de recuperaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n    \"\"\"\n    subject = \"Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n    text_content = f\"Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-recuperacion-de-contrasena","title":"M\u00e9todos Principales de recuperaci\u00f3n de contrase\u00f1a","text":""},{"location":"user/use_cases/#recovery_password","title":"recovery_password","text":"<p>Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si se ha solicitado un PIN recientemente o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def recovery_password(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si se ha solicitado un PIN recientemente o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    warning_time = WARNING_TIME\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n    if recovery and self.user_service.is_recently_requested(recovery, warning_time):\n        raise DomainException(\n            message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS\n        )\n\n    self.user_repository.delete_password_recovery(recovery)\n\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    self.user_repository.add_password_recovery(user_id=user.id, pin=pin_hash, expiration_datetime=expiration_datetime, created_at=datetime_utc_time())\n\n    return SuccessResponse(\n        message=\"Se ha enviado un PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-confirmacion-de-pin-de-recuperacion","title":"Caso de Uso: Confirmaci\u00f3n de PIN de Recuperaci\u00f3n","text":"<p>Caso de uso para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Esta clase maneja el proceso de confirmaci\u00f3n del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>class ConfirmRecoveryPinUseCase:\n    \"\"\"\n    Caso de uso para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Esta clase maneja el proceso de confirmaci\u00f3n del PIN de recuperaci\u00f3n,\n    incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN,\n    y el manejo de intentos fallidos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ConfirmRecoveryPinUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def confirm_recovery(self, email: str, pin: str) -&gt; SuccessResponse:\n        \"\"\"\n        Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n        Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n        de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja\n        los intentos fallidos.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            pin (str): PIN de recuperaci\u00f3n proporcionado por el usuario.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que el PIN se confirm\u00f3 correctamente.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,\n                             el PIN es incorrecto, o hay otros errores.\n            UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        recovery = self.user_service.get_last(user.recuperacion_contrasena)\n        if not recovery:\n            raise DomainException(\n                message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if self.user_service.is_expired(recovery):\n            self.user_repository.delete_password_recovery(recovery)\n            raise DomainException(\n                message=\"La recuperaci\u00f3n de contrase\u00f1a ha expirado. Por favor, inicie el proceso de recuperaci\u00f3n de contrase\u00f1a nuevamente.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        recovery_pin = self.user_service.verify_pin(recovery, pin)\n\n        if not recovery_pin:\n            attempts = self.user_service.increment_attempts(recovery)\n\n            if attempts &gt;= 3:\n                block_time = 10\n                self.user_repository.delete_password_recovery(recovery)\n                self.user_service.block_user(user, timedelta(minutes=block_time))\n                raise UserHasBeenBlockedException(block_time)\n\n            raise DomainException(\n                message=\"PIN de recuperaci\u00f3n incorrecto.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        recovery.pin_confirmado = True\n        self.user_repository.update_password_recovery(recovery)\n\n        return SuccessResponse(\n                message=\"PIN de recuperaci\u00f3n confirmado correctamente.\"\n            )\n</code></pre> <p>Este caso de uso maneja el proceso de confirmaci\u00f3n del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ConfirmRecoveryPinUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ConfirmRecoveryPinUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.confirm_recovery","title":"<code>confirm_recovery(email, pin)</code>","text":"<p>Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el PIN se confirm\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def confirm_recovery(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de recuperaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el PIN se confirm\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.user_service.is_expired(recovery):\n        self.user_repository.delete_password_recovery(recovery)\n        raise DomainException(\n            message=\"La recuperaci\u00f3n de contrase\u00f1a ha expirado. Por favor, inicie el proceso de recuperaci\u00f3n de contrase\u00f1a nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    recovery_pin = self.user_service.verify_pin(recovery, pin)\n\n    if not recovery_pin:\n        attempts = self.user_service.increment_attempts(recovery)\n\n        if attempts &gt;= 3:\n            block_time = 10\n            self.user_repository.delete_password_recovery(recovery)\n            self.user_service.block_user(user, timedelta(minutes=block_time))\n            raise UserHasBeenBlockedException(block_time)\n\n        raise DomainException(\n            message=\"PIN de recuperaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    recovery.pin_confirmado = True\n    self.user_repository.update_password_recovery(recovery)\n\n    return SuccessResponse(\n            message=\"PIN de recuperaci\u00f3n confirmado correctamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-confirmacion-de-pin-de-recuperacion","title":"M\u00e9todos Principales de confirmaci\u00f3n de PIN de recuperaci\u00f3n","text":""},{"location":"user/use_cases/#confirm_recovery","title":"confirm_recovery","text":"<p>Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el PIN se confirm\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def confirm_recovery(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de recuperaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el PIN se confirm\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.user_service.is_expired(recovery):\n        self.user_repository.delete_password_recovery(recovery)\n        raise DomainException(\n            message=\"La recuperaci\u00f3n de contrase\u00f1a ha expirado. Por favor, inicie el proceso de recuperaci\u00f3n de contrase\u00f1a nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    recovery_pin = self.user_service.verify_pin(recovery, pin)\n\n    if not recovery_pin:\n        attempts = self.user_service.increment_attempts(recovery)\n\n        if attempts &gt;= 3:\n            block_time = 10\n            self.user_repository.delete_password_recovery(recovery)\n            self.user_service.block_user(user, timedelta(minutes=block_time))\n            raise UserHasBeenBlockedException(block_time)\n\n        raise DomainException(\n            message=\"PIN de recuperaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    recovery.pin_confirmado = True\n    self.user_repository.update_password_recovery(recovery)\n\n    return SuccessResponse(\n            message=\"PIN de recuperaci\u00f3n confirmado correctamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-reenvio-de-pin-de-recuperacion","title":"Caso de Uso: Reenv\u00edo de PIN de Recuperaci\u00f3n","text":"<p>Caso de uso para reenviar el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Esta clase maneja el proceso de reenv\u00edo del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>class ResendRecoveryUseCase:\n    \"\"\"\n    Caso de uso para reenviar el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Esta clase maneja el proceso de reenv\u00edo del PIN de recuperaci\u00f3n, incluyendo\n    la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes,\n    y la generaci\u00f3n y env\u00edo de un nuevo PIN.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ResendRecoveryUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def resend_recovery(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n        Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n        un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado\n                             un reenv\u00edo recientemente, o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        recovery = self.user_service.get_last(user.recuperacion_contrasena)\n\n        if not recovery:\n            raise DomainException(\n                message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        warning_time = WARNING_TIME\n\n        if recovery.resends &gt; 0:\n            if self.user_service.is_recently_requested(recovery, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n        pin, pin_hash = generate_pin()\n\n        expiration_datetime = self.user_service.expiration_time()\n\n        background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n        recovery.pin = pin_hash\n        recovery.expiracion = expiration_datetime\n        recovery.intentos = 0\n        recovery.resends += 1\n        self.user_repository.update_password_recovery(recovery)\n\n        return SuccessResponse(\n            message=\"Se ha reenviado el PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n        )\n\n    def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a reenviado.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n            pin (str): PIN de recuperaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n        \"\"\"\n        subject = \"Reenv\u00edo: Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n        text_content = f\"Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        return send_email(email, subject, text_content, html_content)\n</code></pre> <p>Este caso de uso maneja el proceso de reenv\u00edo del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ResendRecoveryUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ResendRecoveryUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.resend_recovery","title":"<code>resend_recovery(email, background_tasks)</code>","text":"<p>Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def resend_recovery(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = WARNING_TIME\n\n    if recovery.resends &gt; 0:\n        if self.user_service.is_recently_requested(recovery, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    recovery.pin = pin_hash\n    recovery.expiracion = expiration_datetime\n    recovery.intentos = 0\n    recovery.resends += 1\n    self.user_repository.update_password_recovery(recovery)\n\n    return SuccessResponse(\n        message=\"Se ha reenviado el PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.send_password_recovery_email","title":"<code>send_password_recovery_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a reenviado.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del destinatario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 exitosamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a reenviado.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n        pin (str): PIN de recuperaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n    \"\"\"\n    subject = \"Reenv\u00edo: Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n    text_content = f\"Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-reenvio-de-pin-de-recuperacion","title":"M\u00e9todos Principales de reenv\u00edo de PIN de recuperaci\u00f3n","text":""},{"location":"user/use_cases/#resend_recovery","title":"resend_recovery","text":"<p>Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def resend_recovery(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = WARNING_TIME\n\n    if recovery.resends &gt; 0:\n        if self.user_service.is_recently_requested(recovery, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    expiration_datetime = self.user_service.expiration_time()\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    recovery.pin = pin_hash\n    recovery.expiracion = expiration_datetime\n    recovery.intentos = 0\n    recovery.resends += 1\n    self.user_repository.update_password_recovery(recovery)\n\n    return SuccessResponse(\n        message=\"Se ha reenviado el PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-restablecimiento-de-contrasena","title":"Caso de Uso: Restablecimiento de Contrase\u00f1a","text":"<p>Caso de uso para restablecer la contrase\u00f1a de un usuario.</p> <p>Esta clase maneja el proceso de restablecimiento de contrase\u00f1a, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN de recuperaci\u00f3n, y la actualizaci\u00f3n de la contrase\u00f1a en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>class ResetPasswordUseCase:\n    \"\"\"\n    Caso de uso para restablecer la contrase\u00f1a de un usuario.\n\n    Esta clase maneja el proceso de restablecimiento de contrase\u00f1a, incluyendo\n    la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN de recuperaci\u00f3n,\n    y la actualizaci\u00f3n de la contrase\u00f1a en la base de datos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ResetPasswordUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n        self.user_service = UserService(db)\n\n    def reset_password(self, email: str, new_password: str) -&gt; SuccessResponse:\n        \"\"\"\n        Restablece la contrase\u00f1a de un usuario.\n\n        Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n        de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            new_password (str): Nueva contrase\u00f1a a establecer.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,\n                             la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        recovery = self.user_service.get_last(user.recuperacion_contrasena)\n\n        if not recovery:\n            raise DomainException(\n                message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if not recovery.pin_confirmado:\n            raise DomainException(\n                message=\"El PIN de recuperaci\u00f3n no ha sido confirmado.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        if verify_password(new_password, user.password):\n            raise DomainException(\n                message=\"Aseg\u00farate de que la nueva contrase\u00f1a sea diferente de la anterior\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        user.password = hash_password(new_password)\n        if not self.user_repository.update_user(user):\n            raise DomainException(\n                message=\"No se pudo actualizar la contrase\u00f1a del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        if not self.user_repository.delete_password_recovery(recovery):\n            raise DomainException(\n                message=\"No se pudo eliminar el registro de recuperaci\u00f3n de contrase\u00f1a.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessResponse(\n            message= \"Contrase\u00f1a restablecida correctamente.\"\n        )\n</code></pre> <p>Este caso de uso maneja el proceso de restablecimiento de contrase\u00f1a, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN de recuperaci\u00f3n, y la actualizaci\u00f3n de la contrase\u00f1a en la base de datos.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.reset_password_use_case.ResetPasswordUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ResetPasswordUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ResetPasswordUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n    self.user_service = UserService(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.reset_password_use_case.ResetPasswordUseCase.reset_password","title":"<code>reset_password(email, new_password)</code>","text":"<p>Restablece la contrase\u00f1a de un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>new_password</code> <code>str</code> <p>Nueva contrase\u00f1a a establecer.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,              la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>def reset_password(self, email: str, new_password: str) -&gt; SuccessResponse:\n    \"\"\"\n    Restablece la contrase\u00f1a de un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        new_password (str): Nueva contrase\u00f1a a establecer.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,\n                         la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if not recovery.pin_confirmado:\n        raise DomainException(\n            message=\"El PIN de recuperaci\u00f3n no ha sido confirmado.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    if verify_password(new_password, user.password):\n        raise DomainException(\n            message=\"Aseg\u00farate de que la nueva contrase\u00f1a sea diferente de la anterior\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    user.password = hash_password(new_password)\n    if not self.user_repository.update_user(user):\n        raise DomainException(\n            message=\"No se pudo actualizar la contrase\u00f1a del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    if not self.user_repository.delete_password_recovery(recovery):\n        raise DomainException(\n            message=\"No se pudo eliminar el registro de recuperaci\u00f3n de contrase\u00f1a.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(\n        message= \"Contrase\u00f1a restablecida correctamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-restablecimiento-de-contrasena","title":"M\u00e9todos Principales de restablecimiento de contrase\u00f1a","text":""},{"location":"user/use_cases/#reset_password","title":"reset_password","text":"<p>Restablece la contrase\u00f1a de un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>new_password</code> <code>str</code> <p>Nueva contrase\u00f1a a establecer.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,              la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>def reset_password(self, email: str, new_password: str) -&gt; SuccessResponse:\n    \"\"\"\n    Restablece la contrase\u00f1a de un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        new_password (str): Nueva contrase\u00f1a a establecer.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,\n                         la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.user_service.get_last(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if not recovery.pin_confirmado:\n        raise DomainException(\n            message=\"El PIN de recuperaci\u00f3n no ha sido confirmado.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    if verify_password(new_password, user.password):\n        raise DomainException(\n            message=\"Aseg\u00farate de que la nueva contrase\u00f1a sea diferente de la anterior\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    user.password = hash_password(new_password)\n    if not self.user_repository.update_user(user):\n        raise DomainException(\n            message=\"No se pudo actualizar la contrase\u00f1a del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    if not self.user_repository.delete_password_recovery(recovery):\n        raise DomainException(\n            message=\"No se pudo eliminar el registro de recuperaci\u00f3n de contrase\u00f1a.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(\n        message= \"Contrase\u00f1a restablecida correctamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#otros-casos-de-uso","title":"Otros Casos de Uso","text":""},{"location":"user/use_cases/#caso-de-uso-cierre-de-sesion","title":"Caso de Uso: Cierre de Sesi\u00f3n","text":"<p>Caso de uso para gestionar el cierre de sesi\u00f3n de un usuario.</p> <p>Esta clase maneja el proceso de cerrar sesi\u00f3n, incluyendo la inclusi\u00f3n del token en la lista negra.</p> <p>Attributes:</p> Name Type Description <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>class LogoutUseCase:\n    \"\"\"\n    Caso de uso para gestionar el cierre de sesi\u00f3n de un usuario.\n\n    Esta clase maneja el proceso de cerrar sesi\u00f3n, incluyendo la inclusi\u00f3n\n    del token en la lista negra.\n\n    Attributes:\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de LogoutUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.user_repository = UserRepository(db)\n\n    def logout(self, token: str, user_id: int) -&gt; SuccessResponse:\n        \"\"\"\n        Realiza el proceso de cierre de sesi\u00f3n para un usuario.\n\n        Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta\n        de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.\n\n        Args:\n            token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n            user_id (int): ID del usuario que est\u00e1 cerrando sesi\u00f3n.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.\n\n        Raises:\n            DomainException: Si no se pudo cerrar la sesi\u00f3n.\n        \"\"\"\n        success = self.blacklist_token(token, user_id)\n        if not success:\n            raise DomainException(\n                message=\"No se pudo cerrar la sesi\u00f3n. Intenta nuevamente.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        return SuccessResponse(\n                message=\"Sesi\u00f3n cerrada exitosamente.\"\n        )\n\n    def blacklist_token(self, token: str, user_id: int) -&gt; bool:\n        \"\"\"\n        Incluye un token en la lista negra.\n\n        Args:\n            token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n            user_id (int): ID del usuario asociado al token.\n\n        Returns:\n            bool: True si el token se incluy\u00f3 exitosamente en la lista negra, False en caso contrario.\n        \"\"\"\n        blacklisted = BlacklistedToken(token=token, usuario_id=user_id)\n        return self.user_repository.blacklist_token(blacklisted)\n</code></pre> <p>Este caso de uso maneja el proceso de cerrar sesi\u00f3n, incluyendo la inclusi\u00f3n del token en la lista negra.</p>"},{"location":"user/use_cases/#app.user.application.logout_use_case.LogoutUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de LogoutUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de LogoutUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.user_repository = UserRepository(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.logout_use_case.LogoutUseCase.blacklist_token","title":"<code>blacklist_token(token, user_id)</code>","text":"<p>Incluye un token en la lista negra.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token de autenticaci\u00f3n a incluir en la lista negra.</p> required <code>user_id</code> <code>int</code> <p>ID del usuario asociado al token.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el token se incluy\u00f3 exitosamente en la lista negra, False en caso contrario.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def blacklist_token(self, token: str, user_id: int) -&gt; bool:\n    \"\"\"\n    Incluye un token en la lista negra.\n\n    Args:\n        token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n        user_id (int): ID del usuario asociado al token.\n\n    Returns:\n        bool: True si el token se incluy\u00f3 exitosamente en la lista negra, False en caso contrario.\n    \"\"\"\n    blacklisted = BlacklistedToken(token=token, usuario_id=user_id)\n    return self.user_repository.blacklist_token(blacklisted)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.logout_use_case.LogoutUseCase.logout","title":"<code>logout(token, user_id)</code>","text":"<p>Realiza el proceso de cierre de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token de autenticaci\u00f3n a incluir en la lista negra.</p> required <code>user_id</code> <code>int</code> <p>ID del usuario que est\u00e1 cerrando sesi\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo cerrar la sesi\u00f3n.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def logout(self, token: str, user_id: int) -&gt; SuccessResponse:\n    \"\"\"\n    Realiza el proceso de cierre de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta\n    de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.\n\n    Args:\n        token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n        user_id (int): ID del usuario que est\u00e1 cerrando sesi\u00f3n.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.\n\n    Raises:\n        DomainException: Si no se pudo cerrar la sesi\u00f3n.\n    \"\"\"\n    success = self.blacklist_token(token, user_id)\n    if not success:\n        raise DomainException(\n            message=\"No se pudo cerrar la sesi\u00f3n. Intenta nuevamente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return SuccessResponse(\n            message=\"Sesi\u00f3n cerrada exitosamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-cierre-de-sesion","title":"M\u00e9todos Principales de cierre de sesi\u00f3n","text":""},{"location":"user/use_cases/#logout","title":"logout","text":"<p>Realiza el proceso de cierre de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token de autenticaci\u00f3n a incluir en la lista negra.</p> required <code>user_id</code> <code>int</code> <p>ID del usuario que est\u00e1 cerrando sesi\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo cerrar la sesi\u00f3n.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def logout(self, token: str, user_id: int) -&gt; SuccessResponse:\n    \"\"\"\n    Realiza el proceso de cierre de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta\n    de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.\n\n    Args:\n        token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n        user_id (int): ID del usuario que est\u00e1 cerrando sesi\u00f3n.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.\n\n    Raises:\n        DomainException: Si no se pudo cerrar la sesi\u00f3n.\n    \"\"\"\n    success = self.blacklist_token(token, user_id)\n    if not success:\n        raise DomainException(\n            message=\"No se pudo cerrar la sesi\u00f3n. Intenta nuevamente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return SuccessResponse(\n            message=\"Sesi\u00f3n cerrada exitosamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-obtener-usuario-actual","title":"Caso de Uso: Obtener Usuario Actual","text":"<p>Caso de uso para obtener la informaci\u00f3n del usuario actual.</p> <p>Esta clase maneja la l\u00f3gica para recuperar y validar la informaci\u00f3n del usuario actual.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>class GetCurrentUserUseCase:\n    \"\"\"\n    Caso de uso para obtener la informaci\u00f3n del usuario actual.\n\n    Esta clase maneja la l\u00f3gica para recuperar y validar la informaci\u00f3n del usuario actual.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de GetCurrentUserUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n\n    def get_current_user(self, current_user: UserInDB) -&gt; UserResponse:\n        \"\"\"\n        Obtiene la informaci\u00f3n del usuario actual.\n\n        Este m\u00e9todo verifica la existencia del usuario actual y su estado,\n        y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.\n\n        Args:\n            current_user (UserInDB): El usuario actual autenticado.\n\n        Returns:\n            UserResponse: La informaci\u00f3n del usuario mapeada a la respuesta.\n\n        Raises:\n            UserStateException: Si el estado del usuario no es reconocido.\n        \"\"\"\n\n        # Obtener el estado del usuario\n        estado = self.user_repository.get_state_by_id(current_user.state_id)\n        if not estado:\n            raise UserStateException(\n                message=\"Estado de usuario no reconocido.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n\n        current_user.estado = estado\n        return map_user_to_response(current_user)\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica para recuperar y validar la informaci\u00f3n del usuario actual.</p>"},{"location":"user/use_cases/#app.user.application.get_current_user_use_case.GetCurrentUserUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de GetCurrentUserUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de GetCurrentUserUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.get_current_user_use_case.GetCurrentUserUseCase.get_current_user","title":"<code>get_current_user(current_user)</code>","text":"<p>Obtiene la informaci\u00f3n del usuario actual.</p> <p>Este m\u00e9todo verifica la existencia del usuario actual y su estado, y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>El usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>UserResponse</code> <code>UserResponse</code> <p>La informaci\u00f3n del usuario mapeada a la respuesta.</p> <p>Raises:</p> Type Description <code>UserStateException</code> <p>Si el estado del usuario no es reconocido.</p> Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>def get_current_user(self, current_user: UserInDB) -&gt; UserResponse:\n    \"\"\"\n    Obtiene la informaci\u00f3n del usuario actual.\n\n    Este m\u00e9todo verifica la existencia del usuario actual y su estado,\n    y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.\n\n    Args:\n        current_user (UserInDB): El usuario actual autenticado.\n\n    Returns:\n        UserResponse: La informaci\u00f3n del usuario mapeada a la respuesta.\n\n    Raises:\n        UserStateException: Si el estado del usuario no es reconocido.\n    \"\"\"\n\n    # Obtener el estado del usuario\n    estado = self.user_repository.get_state_by_id(current_user.state_id)\n    if not estado:\n        raise UserStateException(\n            message=\"Estado de usuario no reconocido.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    current_user.estado = estado\n    return map_user_to_response(current_user)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-obtener-usuario-actual","title":"M\u00e9todos Principales de obtener usuario actual","text":""},{"location":"user/use_cases/#get_current_user","title":"get_current_user","text":"<p>Obtiene la informaci\u00f3n del usuario actual.</p> <p>Este m\u00e9todo verifica la existencia del usuario actual y su estado, y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>El usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>UserResponse</code> <code>UserResponse</code> <p>La informaci\u00f3n del usuario mapeada a la respuesta.</p> <p>Raises:</p> Type Description <code>UserStateException</code> <p>Si el estado del usuario no es reconocido.</p> Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>def get_current_user(self, current_user: UserInDB) -&gt; UserResponse:\n    \"\"\"\n    Obtiene la informaci\u00f3n del usuario actual.\n\n    Este m\u00e9todo verifica la existencia del usuario actual y su estado,\n    y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.\n\n    Args:\n        current_user (UserInDB): El usuario actual autenticado.\n\n    Returns:\n        UserResponse: La informaci\u00f3n del usuario mapeada a la respuesta.\n\n    Raises:\n        UserStateException: Si el estado del usuario no es reconocido.\n    \"\"\"\n\n    # Obtener el estado del usuario\n    estado = self.user_repository.get_state_by_id(current_user.state_id)\n    if not estado:\n        raise UserStateException(\n            message=\"Estado de usuario no reconocido.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    current_user.estado = estado\n    return map_user_to_response(current_user)\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-actualizar-informacion-de-usuario","title":"Caso de Uso: Actualizar Informaci\u00f3n de Usuario","text":"<p>Caso de uso para actualizar la informaci\u00f3n de un usuario.</p> <p>Esta clase maneja el proceso de actualizaci\u00f3n de la informaci\u00f3n del usuario, incluyendo la verificaci\u00f3n de correo electr\u00f3nico duplicado.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>class UpdateUserInfoUseCase:\n    \"\"\"\n    Caso de uso para actualizar la informaci\u00f3n de un usuario.\n\n    Esta clase maneja el proceso de actualizaci\u00f3n de la informaci\u00f3n del usuario,\n    incluyendo la verificaci\u00f3n de correo electr\u00f3nico duplicado.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de UpdateUserInfoUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n\n    def update_user_info(self, current_user: UserInDB, user_update: UserUpdate) -&gt; SuccessResponse:\n        \"\"\"\n        Actualiza la informaci\u00f3n del usuario.\n\n        Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso,\n        actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.\n\n        Args:\n            current_user (User): Usuario actual cuya informaci\u00f3n se va a actualizar.\n            user_update (UserUpdate): Datos actualizados del usuario.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que la actualizaci\u00f3n fue exitosa.\n\n        Raises:\n            UserAlreadyRegisteredException: Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.\n            DomainException: Si no se pudo actualizar la informaci\u00f3n del usuario.\n        \"\"\"\n        # Verificar si el email ya est\u00e1 en uso por otro usuario\n        if user_update.email != current_user.email:\n            if self.user_repository.get_user_by_email(user_update.email):\n                raise UserAlreadyRegisteredException()\n\n            current_user.email = user_update.email\n\n        current_user.nombre = user_update.nombre\n        current_user.apellido = user_update.apellido\n\n        if not self.user_repository.update_user(current_user):\n            raise DomainException(\n                message=\"No se pudo actualizar la informaci\u00f3n del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessResponse(message=\"Usuario actualizado exitosamente\")\n</code></pre> <p>Este caso de uso maneja el proceso de actualizaci\u00f3n de la informaci\u00f3n del usuario, incluyendo la verificaci\u00f3n de correo electr\u00f3nico duplicado.</p>"},{"location":"user/use_cases/#app.user.application.update_user_info_use_case.UpdateUserInfoUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de UpdateUserInfoUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de UpdateUserInfoUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.update_user_info_use_case.UpdateUserInfoUseCase.update_user_info","title":"<code>update_user_info(current_user, user_update)</code>","text":"<p>Actualiza la informaci\u00f3n del usuario.</p> <p>Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso, actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>User</code> <p>Usuario actual cuya informaci\u00f3n se va a actualizar.</p> required <code>user_update</code> <code>UserUpdate</code> <p>Datos actualizados del usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la actualizaci\u00f3n fue exitosa.</p> <p>Raises:</p> Type Description <code>UserAlreadyRegisteredException</code> <p>Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.</p> <code>DomainException</code> <p>Si no se pudo actualizar la informaci\u00f3n del usuario.</p> Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>def update_user_info(self, current_user: UserInDB, user_update: UserUpdate) -&gt; SuccessResponse:\n    \"\"\"\n    Actualiza la informaci\u00f3n del usuario.\n\n    Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso,\n    actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.\n\n    Args:\n        current_user (User): Usuario actual cuya informaci\u00f3n se va a actualizar.\n        user_update (UserUpdate): Datos actualizados del usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la actualizaci\u00f3n fue exitosa.\n\n    Raises:\n        UserAlreadyRegisteredException: Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.\n        DomainException: Si no se pudo actualizar la informaci\u00f3n del usuario.\n    \"\"\"\n    # Verificar si el email ya est\u00e1 en uso por otro usuario\n    if user_update.email != current_user.email:\n        if self.user_repository.get_user_by_email(user_update.email):\n            raise UserAlreadyRegisteredException()\n\n        current_user.email = user_update.email\n\n    current_user.nombre = user_update.nombre\n    current_user.apellido = user_update.apellido\n\n    if not self.user_repository.update_user(current_user):\n        raise DomainException(\n            message=\"No se pudo actualizar la informaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(message=\"Usuario actualizado exitosamente\")\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-actualizacion-de-informacion-de-usuario","title":"M\u00e9todos Principales de actualizaci\u00f3n de informaci\u00f3n de usuario","text":""},{"location":"user/use_cases/#update_user_info","title":"update_user_info","text":"<p>Actualiza la informaci\u00f3n del usuario.</p> <p>Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso, actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>User</code> <p>Usuario actual cuya informaci\u00f3n se va a actualizar.</p> required <code>user_update</code> <code>UserUpdate</code> <p>Datos actualizados del usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la actualizaci\u00f3n fue exitosa.</p> <p>Raises:</p> Type Description <code>UserAlreadyRegisteredException</code> <p>Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.</p> <code>DomainException</code> <p>Si no se pudo actualizar la informaci\u00f3n del usuario.</p> Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>def update_user_info(self, current_user: UserInDB, user_update: UserUpdate) -&gt; SuccessResponse:\n    \"\"\"\n    Actualiza la informaci\u00f3n del usuario.\n\n    Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso,\n    actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.\n\n    Args:\n        current_user (User): Usuario actual cuya informaci\u00f3n se va a actualizar.\n        user_update (UserUpdate): Datos actualizados del usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la actualizaci\u00f3n fue exitosa.\n\n    Raises:\n        UserAlreadyRegisteredException: Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.\n        DomainException: Si no se pudo actualizar la informaci\u00f3n del usuario.\n    \"\"\"\n    # Verificar si el email ya est\u00e1 en uso por otro usuario\n    if user_update.email != current_user.email:\n        if self.user_repository.get_user_by_email(user_update.email):\n            raise UserAlreadyRegisteredException()\n\n        current_user.email = user_update.email\n\n    current_user.nombre = user_update.nombre\n    current_user.apellido = user_update.apellido\n\n    if not self.user_repository.update_user(current_user):\n        raise DomainException(\n            message=\"No se pudo actualizar la informaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(message=\"Usuario actualizado exitosamente\")\n</code></pre>"}]}