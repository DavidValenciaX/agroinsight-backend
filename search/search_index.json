{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido a la Documentaci\u00f3n del desarrollor Backend del proyecto AgroInsight","text":"<p>AgroInsight es una aplicaci\u00f3n de gesti\u00f3n agr\u00edcola dise\u00f1ada para optimizar el cultivo de ma\u00edz en la regi\u00f3n del Huila, Colombia. Esta documentaci\u00f3n proporciona una gu\u00eda completa para los desarrolladores del sistema.</p>"},{"location":"#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>Gesti\u00f3n de Usuarios: Sistema de registro, autenticaci\u00f3n y gesti\u00f3n de roles.</li> <li>Administraci\u00f3n de Fincas y Lotes: Herramientas para manejar la informaci\u00f3n de fincas y lotes de cultivo.</li> <li>An\u00e1lisis de Suelos: Funcionalidad para procesar y analizar datos de suelos mediante inteligencia artificial.</li> <li>Detecci\u00f3n de Plagas: Sistema de detecci\u00f3n temprana del gusano cogollero utilizando visi\u00f3n por computadora.</li> <li>Integraci\u00f3n de Datos Meteorol\u00f3gicos: Obtenci\u00f3n y an\u00e1lisis de datos clim\u00e1ticos relevantes para el cultivo.</li> <li>Recomendaciones Personalizadas: Generaci\u00f3n de recomendaciones basadas en los datos recolectados y analizados.</li> <li>Generaci\u00f3n de Informes: Creaci\u00f3n de informes detallados sobre el estado y progreso de los cultivos.</li> <li>Funcionalidad offline: Admite acceso y sincronizaci\u00f3n de datos sin conexi\u00f3n.</li> </ul>"},{"location":"#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Backend: FastAPI 0.112.1, Python 3.12</li> <li>Frontend: React Native para aplicaciones m\u00f3viles y web</li> <li>Base de Datos: PostgrSQL 15.6</li> <li>ORM: SQLAlchemy 2.0.32</li> <li>Containerization: Docker</li> <li>IA y An\u00e1lisis de Datos: TensorFlow 2.16.1, OpenCV 4.10.0</li> <li>Despliegue: Railway para backend y base de datos</li> </ul>"},{"location":"#como-usar-esta-documentacion","title":"C\u00f3mo Usar esta Documentaci\u00f3n","text":"<ul> <li>Gu\u00edas: Para empezar r\u00e1pidamente con el proyecto, consulta nuestra secci\u00f3n de gu\u00edas.</li> <li>M\u00f3dulos: Explora la documentaci\u00f3n detallada de cada m\u00f3dulo del sistema.</li> <li>API: Revisa la documentaci\u00f3n de la API generada autom\u00e1ticamente con Swagger UI y ReDoc.</li> <li>Desarrollo: Si eres desarrollador, no olvides revisar nuestras gu\u00edas de contribuci\u00f3n y est\u00e1ndares de c\u00f3digo.</li> </ul> <p>\u00a1Bienvenido al proyecto AgroInsight, tu compa\u00f1ero en la agricultura de precisi\u00f3n!</p>"},{"location":"about/","title":"Acerca de AgroInsight","text":""},{"location":"about/#introduccion","title":"Introducci\u00f3n","text":"<p>AgroInsight es una plataforma innovadora dise\u00f1ada para revolucionar la agricultura moderna mediante el uso de tecnolog\u00edas avanzadas y an\u00e1lisis de datos. Nuestro objetivo es proporcionar a los agricultores y profesionales del sector agr\u00edcola las herramientas necesarias para optimizar sus operaciones, aumentar la productividad y promover pr\u00e1cticas agr\u00edcolas sostenibles.</p>"},{"location":"about/#nuestra-mision","title":"Nuestra Misi\u00f3n","text":"<p>En AgroInsight, nos dedicamos a:</p> <ol> <li>Empoderar a los agricultores con informaci\u00f3n precisa y oportuna.</li> <li>Fomentar la agricultura de precisi\u00f3n y sostenible.</li> <li>Reducir el impacto ambiental de las pr\u00e1cticas agr\u00edcolas.</li> <li>Mejorar la eficiencia y rentabilidad de las explotaciones agr\u00edcolas.</li> </ol>"},{"location":"about/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":"<ul> <li>An\u00e1lisis de Datos Avanzado: Utilizamos algoritmos de inteligencia artificial y aprendizaje autom\u00e1tico para procesar grandes cantidades de datos agr\u00edcolas.</li> <li>Monitoreo en Tiempo Real: Ofrecemos seguimiento en tiempo real de las condiciones del cultivo, clima y suelo.</li> <li>Recomendaciones Personalizadas: Proporcionamos consejos espec\u00edficos para cada cultivo y regi\u00f3n.</li> <li>Integraci\u00f3n IoT: Compatibilidad con una amplia gama de sensores y dispositivos IoT para la recopilaci\u00f3n de datos en el campo.</li> </ul>"},{"location":"about/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<p>AgroInsight se basa en una combinaci\u00f3n de tecnolog\u00edas de vanguardia, incluyendo:</p> <ul> <li>Inteligencia Artificial y Aprendizaje Autom\u00e1tico</li> <li>Internet de las Cosas (IoT)</li> <li>Procesamiento de Im\u00e1genes Satelitales</li> <li>An\u00e1lisis de Big Data</li> <li>Computaci\u00f3n en la Nube</li> </ul>"},{"location":"about/#contacto","title":"Contacto","text":"<p>Para m\u00e1s informaci\u00f3n sobre AgroInsight, no dude en ponerse en contacto con nosotros:</p> <ul> <li>Correo Electr\u00f3nico: info@agroinsight.com</li> <li>Tel\u00e9fono: +34 900 123 456</li> <li>Sitio Web: www.agroinsight.com</li> </ul>"},{"location":"about/#contribuir","title":"Contribuir","text":"<p>AgroInsight es un proyecto de c\u00f3digo abierto y damos la bienvenida a contribuciones de la comunidad. Si est\u00e1 interesado en contribuir, por favor visite nuestra p\u00e1gina de Contribuci\u00f3n para obtener m\u00e1s informaci\u00f3n sobre c\u00f3mo puede participar.</p> <p>\u00daltima actualizaci\u00f3n: [2024-07-20]</p>"},{"location":"complement-docs/overview/","title":"Visi\u00f3n General de AgroInsight","text":""},{"location":"complement-docs/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>AgroInsight es una plataforma innovadora dise\u00f1ada para revolucionar la agricultura mediante el uso de tecnolog\u00edas avanzadas y an\u00e1lisis de datos. Nuestro objetivo es proporcionar a los agricultores y profesionales del sector agr\u00edcola herramientas poderosas para optimizar sus operaciones, aumentar la productividad y promover pr\u00e1cticas agr\u00edcolas sostenibles.</p>"},{"location":"complement-docs/overview/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Monitoreo en tiempo real: Seguimiento continuo de las condiciones del cultivo y del suelo.</li> <li>An\u00e1lisis predictivo: Utilizaci\u00f3n de algoritmos de aprendizaje autom\u00e1tico para prever rendimientos y detectar problemas potenciales.</li> <li>Gesti\u00f3n de recursos: Optimizaci\u00f3n del uso de agua, fertilizantes y pesticidas.</li> <li>Integraci\u00f3n IoT: Conexi\u00f3n con dispositivos y sensores para recopilar datos precisos del campo.</li> <li>Informes personalizados: Generaci\u00f3n de informes detallados y visualizaciones para una toma de decisiones informada.</li> </ul>"},{"location":"complement-docs/overview/#tecnologias-utilizadas","title":"Tecnolog\u00edas utilizadas","text":"<p>AgroInsight est\u00e1 construido utilizando tecnolog\u00edas modernas y robustas, incluyendo:</p> <ul> <li>Backend: FastAPI (Python)</li> <li>Frontend: React.js</li> <li>Base de datos: PostgreSQL</li> <li>An\u00e1lisis de datos: Python (pandas, scikit-learn)</li> <li>IoT: Protocolos MQTT y CoAP</li> </ul>"},{"location":"complement-docs/overview/#como-empezar","title":"C\u00f3mo empezar","text":"<p>Para comenzar a utilizar AgroInsight, sigue estos pasos:</p> <ol> <li>Reg\u00edstrate en nuestra plataforma en www.agroinsight.com</li> <li>Configura tu perfil y a\u00f1ade los detalles de tu explotaci\u00f3n agr\u00edcola</li> <li>Conecta tus dispositivos IoT siguiendo nuestra gu\u00eda de configuraci\u00f3n</li> <li>Explora las diferentes funcionalidades y comienza a optimizar tu producci\u00f3n</li> </ol>"},{"location":"complement-docs/overview/#soporte-y-comunidad","title":"Soporte y comunidad","text":"<p>Ofrecemos soporte t\u00e9cnico a trav\u00e9s de nuestro portal de ayuda y foros de la comunidad. No dudes en contactarnos si tienes alguna pregunta o sugerencia.</p>"},{"location":"complement-docs/overview/#contribuciones","title":"Contribuciones","text":"<p>AgroInsight es un proyecto de c\u00f3digo abierto y damos la bienvenida a contribuciones de la comunidad. Si est\u00e1s interesado en contribuir, por favor consulta nuestra gu\u00eda de contribuci\u00f3n en el repositorio de GitHub.</p>"},{"location":"complement-docs/overview/#licencia","title":"Licencia","text":"<p>AgroInsight se distribuye bajo la licencia MIT. Para m\u00e1s detalles, consulta el archivo LICENSE en nuestro repositorio.</p>"},{"location":"cultural_practices/endpoints/","title":"endpoints","text":"<p>Contenido para docs\\cultural_practices\\endpoints.md</p>"},{"location":"cultural_practices/models/","title":"models","text":"<p>Contenido para docs\\cultural_practices\\models.md</p>"},{"location":"cultural_practices/overview/","title":"overview","text":"<p>Contenido para docs\\cultural_practices\\overview.md</p>"},{"location":"cultural_practices/use_cases/","title":"use_cases","text":"<p>Contenido para docs\\cultural_practices\\use_cases.md</p>"},{"location":"development/coding_standards/","title":"Est\u00e1ndares de Codificaci\u00f3n para AgroInsight","text":"<p>Este documento describe los est\u00e1ndares de codificaci\u00f3n y las mejores pr\u00e1cticas para el proyecto AgroInsight.  Adherirse a estos est\u00e1ndares garantiza la consistencia, legibilidad y mantenibilidad en toda la base de c\u00f3digo.</p>"},{"location":"development/coding_standards/#1-convenciones-de-nombres","title":"1. Convenciones de Nombres","text":""},{"location":"development/coding_standards/#11-variables-y-funciones","title":"1.1 Variables y Funciones","text":"<ul> <li>Usar <code>snake_case</code> para nombres de variables y funciones.</li> <li>Los nombres deben ser descriptivos e indicar el prop\u00f3sito o contenido.</li> </ul> <p>Ejemplos:</p> <pre><code>user_name = \"John Doe\"\ndef calculate_total_cost(items):\n    # Implementaci\u00f3n de la funci\u00f3n\n</code></pre>"},{"location":"development/coding_standards/#12-clases","title":"1.2 Clases","text":"<ul> <li>Usar <code>PascalCase</code> para nombres de clases.</li> <li>Los nombres de las clases deben ser sustantivos y representar el objeto o concepto.</li> </ul> <p>Ejemplo:</p> <pre><code>class UserProfile:\n    # Implementaci\u00f3n de la clase\n</code></pre>"},{"location":"development/coding_standards/#13-modulos-y-paquetes","title":"1.3 M\u00f3dulos y Paquetes","text":"<ul> <li>Usar <code>snake_case</code> para nombres de m\u00f3dulos y paquetes.</li> <li>Mantener los nombres de los m\u00f3dulos cortos y descriptivos.</li> </ul> <p>Ejemplo:</p> <pre><code>import user_authentication\nfrom data_processing import clean_data\n</code></pre>"},{"location":"development/coding_standards/#14-constantes","title":"1.4 Constantes","text":"<ul> <li>Usar <code>MAY\u00daSCULAS</code> con guiones bajos para las constantes.</li> </ul> <p>Ejemplo:</p> <pre><code>MAX_LOGIN_ATTEMPTS = 3\nDEFAULT_TIMEOUT = 30\n</code></pre>"},{"location":"development/coding_standards/#2-diseno-del-codigo","title":"2. Dise\u00f1o del C\u00f3digo","text":""},{"location":"development/coding_standards/#21-indentacion","title":"2.1 Indentaci\u00f3n","text":"<ul> <li>Usar 4 espacios para la indentaci\u00f3n.</li> <li>No usar tabulaciones.</li> </ul>"},{"location":"development/coding_standards/#22-longitud-maxima-de-linea","title":"2.2 Longitud M\u00e1xima de L\u00ednea","text":"<ul> <li>Limitar todas las l\u00edneas a un m\u00e1ximo de 79 caracteres.</li> <li>Para bloques de texto largos (docstrings o comentarios), limitar la longitud a 72 caracteres.</li> </ul>"},{"location":"development/coding_standards/#23-lineas-en-blanco","title":"2.3 L\u00edneas en Blanco","text":"<ul> <li>Rodear las funciones y clases de nivel superior con dos l\u00edneas en blanco.</li> <li>Usar una l\u00ednea en blanco para separar los m\u00e9todos dentro de una clase.</li> <li>Usar l\u00edneas en blanco con moderaci\u00f3n dentro de las funciones para indicar secciones l\u00f3gicas.</li> </ul>"},{"location":"development/coding_standards/#3-importaciones","title":"3. Importaciones","text":"<ul> <li>Las importaciones deben estar en l\u00edneas separadas.</li> <li>Agrupar las importaciones en el siguiente orden:</li> <li>Importaciones de la biblioteca est\u00e1ndar</li> <li>Importaciones de terceros relacionadas</li> <li>Importaciones espec\u00edficas de la aplicaci\u00f3n/biblioteca local</li> <li>Usar importaciones absolutas cuando sea posible.</li> </ul> <p>Ejemplo:</p> <pre><code>import os\nimport sys\n\nfrom fastapi import FastAPI\nfrom sqlalchemy import Column, Integer\n\nfrom app.models import User\nfrom app.utils import generate_token\n</code></pre>"},{"location":"development/coding_standards/#4-formato-de-cadenas","title":"4. Formato de Cadenas","text":"<ul> <li>Usar f-strings para el formato de cadenas cuando sea posible.</li> <li>Para versiones anteriores de Python, usar el m\u00e9todo <code>.format()</code>.</li> </ul> <p>Ejemplo:</p> <pre><code>name = \"Alice\"\nage = 30\nprint(f\"Name: {name}, Age: {age}\")\n</code></pre>"},{"location":"development/coding_standards/#5-comentarios-y-documentacion","title":"5. Comentarios y Documentaci\u00f3n","text":""},{"location":"development/coding_standards/#51-comentarios-en-linea","title":"5.1 Comentarios en L\u00ednea","text":"<ul> <li>Usar comentarios en l\u00ednea con moderaci\u00f3n.</li> <li>Escribir comentarios que expliquen el porqu\u00e9, no el qu\u00e9.</li> </ul>"},{"location":"development/coding_standards/#52-docstrings-de-funciones-y-metodos","title":"5.2 Docstrings de Funciones y M\u00e9todos","text":"<ul> <li>Usar docstrings de estilo Google para funciones y m\u00e9todos.</li> <li>Incluir una breve descripci\u00f3n, par\u00e1metros, valores de retorno y excepciones generadas.</li> </ul> <p>Ejemplo:</p> <pre><code>def calculate_area(length: float, width: float) -&gt; float:\n    \"\"\"\n    Calcula el \u00e1rea de un rect\u00e1ngulo.\n\n    Parameters:\n        length (float): La longitud del rect\u00e1ngulo.\n        width (float): El ancho del rect\u00e1ngulo.\n\n    Returns:\n        float: El \u00e1rea calculada.\n\n    Raises:\n        ValueError: Si la longitud o el ancho son negativos.\n    \"\"\"\n    if length &lt; 0 or width &lt; 0:\n        raise ValueError(\"La longitud y el ancho deben ser no negativos.\")\n    return length * width\n</code></pre>"},{"location":"development/coding_standards/#53-docstrings-de-clases","title":"5.3 Docstrings de Clases","text":"<ul> <li>Incluir un docstring para cada clase que describa su prop\u00f3sito y comportamiento.</li> </ul> <p>Ejemplo:</p> <pre><code>class UserManager:\n    \"\"\"\n    Gestiona las operaciones relacionadas con el usuario, como la creaci\u00f3n, la autenticaci\u00f3n y las actualizaciones de perfil.\n\n    Esta clase interact\u00faa con el modelo de Usuario y proporciona una interfaz para la gesti\u00f3n de usuarios\n    en toda la aplicaci\u00f3n.\n    \"\"\"\n\n    def __init__(self, db_session):\n        \"\"\"\n        Inicializa el UserManager.\n\n        Parameters:\n            db_session: La sesi\u00f3n de la base de datos a utilizar para las operaciones.\n        \"\"\"\n        self.db_session = db_session\n</code></pre>"},{"location":"development/coding_standards/#6-indicacion-de-tipos-type-hinting","title":"6.  Indicaci\u00f3n de Tipos (Type Hinting)","text":"<ul> <li>Usar indicaciones de tipos para los argumentos de las funciones y los valores de retorno.</li> <li>Importar tipos del m\u00f3dulo <code>typing</code> cuando sea necesario.</li> </ul> <p>Ejemplo:</p> <pre><code>from typing import List, Dict\n\ndef process_user_data(users: List[Dict[str, Any]]) -&gt; List[User]:\n    # Implementaci\u00f3n de la funci\u00f3n\n</code></pre>"},{"location":"development/coding_standards/#7-manejo-de-errores","title":"7. Manejo de Errores","text":"<ul> <li>Usar tipos de excepci\u00f3n espec\u00edficos al generar o capturar excepciones.</li> <li>Proporcionar mensajes de error informativos.</li> </ul> <p>Ejemplo:</p> <pre><code>def divide(a: float, b: float) -&gt; float:\n    if b == 0:\n        raise ValueError(\"No se puede dividir por cero.\")\n    return a / b\n</code></pre>"},{"location":"development/coding_standards/#8-pruebas","title":"8. Pruebas","text":"<ul> <li>Escribir pruebas unitarias para todas las funciones y m\u00e9todos.</li> <li>Usar nombres descriptivos para las funciones de prueba, comenzando con <code>test_</code>.</li> <li>Apuntar a al menos un 80% de cobertura de c\u00f3digo.</li> </ul> <p>Ejemplo:</p> <pre><code>def test_calculate_area_positive_values():\n    assert calculate_area(5, 10) == 50\n\ndef test_calculate_area_raises_value_error():\n    with pytest.raises(ValueError):\n        calculate_area(-1, 5)\n</code></pre>"},{"location":"development/coding_standards/#9-control-de-versiones","title":"9. Control de Versiones","text":"<ul> <li>Escribir mensajes de confirmaci\u00f3n claros y concisos.</li> <li>Usar el tiempo presente en los mensajes de confirmaci\u00f3n (por ejemplo, \"Agregar funci\u00f3n\" no \"Funci\u00f3n agregada\").</li> <li>Hacer referencia a los n\u00fameros de problema en los mensajes de confirmaci\u00f3n cuando corresponda.</li> <li>Utilizar Semantic Versioning (SemVer) para el control de versiones del producto.</li> </ul>"},{"location":"development/coding_standards/#91-semantic-versioning-semver","title":"9.1 Semantic Versioning (SemVer)","text":"<p>El proyecto AgroInsight sigue las reglas de Semantic Versioning para el control de versiones. El formato de versi\u00f3n de SemVer consta de tres partes:</p> <ul> <li>MAJOR: Se incrementa cuando se realizan cambios incompatibles con versiones anteriores de la API.</li> <li>MINOR: Se incrementa cuando se a\u00f1aden funcionalidades de manera compatible con versiones anteriores.</li> <li>PATCH: Se incrementa cuando se realizan correcciones de errores compatibles con versiones anteriores.</li> </ul> <p>Ejemplo: 1.2.3 (MAJOR.MINOR.PATCH)</p>"},{"location":"development/coding_standards/#92-relacion-entre-commits-y-versiones","title":"9.2 Relaci\u00f3n entre Commits y Versiones","text":"<ul> <li>Commits de tipo feat generalmente incrementan la versi\u00f3n MINOR.</li> <li>Commits de tipo fix generalmente incrementan la versi\u00f3n PATCH.</li> <li>Commits con \"BREAKING CHANGE\" en las notas al pie incrementan la versi\u00f3n MAJOR.</li> </ul>"},{"location":"development/coding_standards/#93-convencion-de-commits","title":"9.3 Convenci\u00f3n de Commits","text":"<p>Se adopta la convenci\u00f3n de formato de commits de Conventional Commits para estandarizar el registro de cambios y facilitar la comprensi\u00f3n del historial de desarrollo. Los mensajes de commit deben seguir esta estructura:</p> <pre><code>&lt;tipo&gt;[\u00e1mbito opcional]: &lt;descripci\u00f3n&gt;\n\n[cuerpo opcional]\n\n[nota(s) al pie opcional(es)]\n</code></pre> <p>Donde <code>&lt;tipo&gt;</code> puede ser:</p> <ul> <li>feat: cuando se a\u00f1ade una nueva funcionalidad.</li> <li>fix: cuando se arregla un error.</li> <li>docs: cuando se realizan cambios en la documentaci\u00f3n.</li> <li>refactor: cuando se realiza una refactorizaci\u00f3n del c\u00f3digo sin cambiar su funcionalidad.</li> <li>test: cuando se a\u00f1aden o modifican pruebas.</li> <li>chore: cuando se realizan cambios de mantenimiento o tareas no relacionadas con el c\u00f3digo en s\u00ed.</li> </ul> <p>Esta estructura de versionado y convenci\u00f3n de commits ayuda a mantener un historial de cambios claro y a gestionar las actualizaciones del software de manera m\u00e1s efectiva.</p>"},{"location":"development/coding_standards/#10-organizacion-del-codigo","title":"10. Organizaci\u00f3n del C\u00f3digo","text":"<ul> <li>Seguir la estructura modular del proyecto:</li> <li><code>app/</code>: Paquete principal de la aplicaci\u00f3n<ul> <li><code>[nombre_del_m\u00f3dulo]/</code>: M\u00f3dulo espec\u00edfico (por ejemplo, <code>user</code>, <code>farm</code>, <code>plot</code>)</li> <li><code>application/</code>: Casos de uso y l\u00f3gica de negocio</li> <li><code>domain/</code>: Modelos de dominio y reglas de negocio</li> <li><code>infrastructure/</code>: Modelos de base de datos, repositorios y rutas API</li> </ul> </li> </ul>"},{"location":"development/coding_standards/#11-directrices-especificas-de-fastapi","title":"11. Directrices Espec\u00edficas de FastAPI","text":"<ul> <li>Usar modelos Pydantic para esquemas de solicitud y respuesta.</li> <li>Implementar la inyecci\u00f3n de dependencias para sesiones de base de datos y otros recursos compartidos.</li> <li>Usar funciones as\u00edncronas para operaciones de base de datos y llamadas a API externas.</li> </ul> <p>Ejemplo:</p> <pre><code>from fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\nfrom app.infrastructure.database import get_db\nfrom app.user.domain.schemas import UserCreate, UserResponse\n\nrouter = APIRouter()\n\n@router.post(\"/users/\", response_model=UserResponse)\nasync def create_user(user: UserCreate, db: Session = Depends(get_db)):\n    # Implementaci\u00f3n\n</code></pre>"},{"location":"development/coding_standards/#12-operaciones-de-base-de-datos","title":"12. Operaciones de Base de Datos","text":"<ul> <li>Usar SQLAlchemy ORM para las operaciones de base de datos.</li> <li>Definir los modelos de base de datos en <code>infrastructure/orm_models.py</code>.</li> <li>Implementar el patr\u00f3n de repositorio para las interacciones con la base de datos.</li> </ul> <p>Ejemplo:</p> <pre><code>from sqlalchemy.orm import Session\nfrom app.user.infrastructure.orm_models import User\n\nclass UserRepository:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def create_user(self, user_data: dict) -&gt; User:\n        user = User(**user_data)\n        self.db.add(user)\n        self.db.commit()\n        self.db.refresh(user)\n        return user\n</code></pre>"},{"location":"development/coding_standards/#13-inyeccion-de-dependencias","title":"13. Inyecci\u00f3n de Dependencias","text":"<ul> <li>Usar el sistema de inyecci\u00f3n de dependencias de FastAPI para recursos compartidos.</li> <li>Crear dependencias reutilizables para operaciones comunes.</li> </ul> <p>Ejemplo:</p> <pre><code>from fastapi import Depends\nfrom app.infrastructure.security import get_current_user\nfrom app.user.domain.schemas import UserInDB\n\nasync def get_current_active_user(\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; UserInDB:\n    if not current_user.is_active:\n        raise HTTPException(status_code=400, detail=\"Usuario inactivo\")\n    return current_user\n</code></pre>"},{"location":"development/coding_standards/#14-gestion-de-la-configuracion","title":"14. Gesti\u00f3n de la Configuraci\u00f3n","text":"<ul> <li>Usar variables de entorno para la configuraci\u00f3n.</li> <li>Cargar la configuraci\u00f3n usando BaseSettings de Pydantic.</li> </ul> <p>Ejemplo:</p> <pre><code>from pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    database_url: str\n    secret_key: str\n    api_prefix: str = \"/api/v1\"\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()\n</code></pre>"},{"location":"development/coding_standards/#15-registro-logging","title":"15. Registro (Logging)","text":"<ul> <li>Usar el m\u00f3dulo de registro integrado de Python.</li> <li>Configurar los niveles de registro adecuadamente para diferentes entornos.</li> </ul> <p>Ejemplo:</p> <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ndef some_function():\n    logger.info(\"Procesamiento iniciado\")\n    try:\n        # Alguna operaci\u00f3n\n        logger.debug(\"Detalles de la operaci\u00f3n\")\n    except Exception as e:\n        logger.error(f\"Ocurri\u00f3 un error: {str(e)}\")\n</code></pre> <p>Siguiendo estos est\u00e1ndares de codificaci\u00f3n, aseguramos una base de c\u00f3digo consistente y mantenible para el proyecto AgroInsight.  Se deben utilizar revisiones de c\u00f3digo regulares y herramientas de linting automatizadas para aplicar estos est\u00e1ndares en todo el equipo de desarrollo.</p>"},{"location":"development/contributing/","title":"Contribuyendo a AgroInsight","text":"<p>\u00a1Gracias por tu inter\u00e9s en contribuir a AgroInsight! Este documento proporciona una gu\u00eda para aquellos que desean contribuir al proyecto.</p>"},{"location":"development/contributing/#configuracion-del-entorno-de-desarrollo","title":"Configuraci\u00f3n del entorno de desarrollo","text":"<ol> <li>Clona el repositorio:</li> </ol> <pre><code>git clone https://github.com/AgroInsight/agroinsight.git\ncd agroinsight\n</code></pre> <ol> <li>Instala las dependencias:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Configura el entorno virtual (recomendado):</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # En Windows: venv\\Scripts\\activate\n</code></pre>"},{"location":"development/contributing/#flujo-de-trabajo-de-contribucion","title":"Flujo de trabajo de contribuci\u00f3n","text":"<ol> <li>Crea una nueva rama para tu contribuci\u00f3n:</li> </ol> <pre><code>git checkout -b feature/nombre-de-tu-caracteristica\n</code></pre> <ol> <li> <p>Realiza tus cambios y aseg\u00farate de seguir las gu\u00edas de estilo del proyecto.</p> </li> <li> <p>Ejecuta las pruebas localmente:</p> </li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Haz commit de tus cambios:</li> </ol> <pre><code>git add .\ngit commit -m \"Descripci\u00f3n concisa de tus cambios\"\n</code></pre> <ol> <li>Sube tus cambios a tu fork:</li> </ol> <pre><code>git push origin feature/nombre-de-tu-caracteristica\n</code></pre> <ol> <li>Crea un Pull Request en GitHub.</li> </ol>"},{"location":"development/contributing/#guias-de-estilo","title":"Gu\u00edas de estilo","text":"<ul> <li>Sigue PEP 8 para el c\u00f3digo Python.</li> <li>Utiliza nombres descriptivos para variables y funciones.</li> <li>Comenta tu c\u00f3digo cuando sea necesario, especialmente para l\u00f3gica compleja.</li> <li>Escribe pruebas unitarias para nuevas funcionalidades.</li> </ul>"},{"location":"development/contributing/#reportando-problemas","title":"Reportando problemas","text":"<p>Si encuentras un bug o tienes una sugerencia de mejora:</p> <ol> <li>Verifica que el problema no haya sido reportado anteriormente.</li> <li>Abre un nuevo issue en GitHub, proporcionando la mayor cantidad de detalles posible.</li> </ol>"},{"location":"development/contributing/#proceso-de-revision-de-codigo","title":"Proceso de revisi\u00f3n de c\u00f3digo","text":"<ul> <li>Todos los Pull Requests ser\u00e1n revisados por al menos un miembro del equipo principal.</li> <li>Se pueden solicitar cambios o aclaraciones antes de la aprobaci\u00f3n.</li> <li>Una vez aprobado, un mantenedor fusionar\u00e1 tu PR.</li> </ul>"},{"location":"development/contributing/#documentacion","title":"Documentaci\u00f3n","text":"<ul> <li>Actualiza la documentaci\u00f3n relevante cuando realices cambios.</li> <li>Utiliza MkDocs para la documentaci\u00f3n del proyecto.</li> <li>Aseg\u00farate de que tus cambios est\u00e9n reflejados en la documentaci\u00f3n.</li> </ul>"},{"location":"development/contributing/#licencia","title":"Licencia","text":"<p>Al contribuir a AgroInsight, aceptas que tus contribuciones se licenciar\u00e1n bajo la misma licencia que el proyecto.</p> <p>\u00a1Gracias por contribuir a AgroInsight y ayudar a mejorar la agricultura con tecnolog\u00eda!</p>"},{"location":"farm/endpoints/","title":"endpoints","text":"<p>Contenido para docs\\farm\\endpoints.md</p>"},{"location":"farm/models/","title":"models","text":"<p>Contenido para docs\\farm\\models.md</p>"},{"location":"farm/overview/","title":"overview","text":"<p>Contenido para docs\\farm\\overview.md</p>"},{"location":"farm/use_cases/","title":"use_cases","text":"<p>Contenido para docs\\farm\\use_cases.md</p>"},{"location":"guides/faq/","title":"Preguntas Frecuentes (FAQ)","text":""},{"location":"guides/faq/#que-es-agroinsight","title":"\u00bfQu\u00e9 es AgroInsight?","text":"<p>AgroInsight es una aplicaci\u00f3n de gesti\u00f3n agr\u00edcola dise\u00f1ada para optimizar el cultivo de ma\u00edz en la regi\u00f3n del Huila, Colombia. Utiliza tecnolog\u00edas modernas como FastAPI, React Native, y TensorFlow para ofrecer funcionalidades avanzadas como an\u00e1lisis de suelos, detecci\u00f3n de plagas, y recomendaciones personalizadas.</p>"},{"location":"guides/faq/#como-puedo-empezar-a-contribuir-al-proyecto","title":"\u00bfC\u00f3mo puedo empezar a contribuir al proyecto?","text":"<p>Para comenzar a contribuir, sigue estos pasos:</p> <ol> <li>Clona el repositorio desde GitHub.</li> <li>Configura tu entorno de desarrollo siguiendo la Gu\u00eda de Instalaci\u00f3n.</li> <li>Revisa la Gu\u00eda de Contribuci\u00f3n para entender las normas y el flujo de trabajo del proyecto.</li> </ol>"},{"location":"guides/faq/#cuales-son-los-requisitos-del-sistema-para-ejecutar-agroinsight","title":"\u00bfCu\u00e1les son los requisitos del sistema para ejecutar AgroInsight?","text":"<p>Los requisitos principales incluyen:</p> <ul> <li>Python 3.12 o superior</li> <li>Docker</li> <li>PostgreSQL 16.2</li> <li>Poetry para la gesti\u00f3n de dependencias</li> </ul> <p>Para m\u00e1s detalles, consulta la secci\u00f3n de Requisitos del Sistema.</p>"},{"location":"guides/faq/#como-se-maneja-la-autenticacion-en-agroinsight","title":"\u00bfC\u00f3mo se maneja la autenticaci\u00f3n en AgroInsight?","text":"<p>AgroInsight utiliza autenticaci\u00f3n de dos factores (2FA) para mejorar la seguridad. Los usuarios deben verificar su identidad mediante un PIN enviado a su correo electr\u00f3nico. Para m\u00e1s detalles, revisa el endpoint <code>/login/verify</code> en la documentaci\u00f3n de la API.</p>"},{"location":"guides/faq/#que-debo-hacer-si-encuentro-un-error-durante-la-instalacion","title":"\u00bfQu\u00e9 debo hacer si encuentro un error durante la instalaci\u00f3n?","text":"<p>Si encuentras problemas durante la instalaci\u00f3n, verifica lo siguiente:</p> <ul> <li>Aseg\u00farate de que todas las dependencias est\u00e1n instaladas correctamente.</li> <li>Revisa que las variables de entorno en el archivo <code>.env</code> est\u00e9n configuradas correctamente.</li> <li>Consulta la secci\u00f3n de Soluci\u00f3n de Problemas Comunes para m\u00e1s ayuda.</li> </ul>"},{"location":"guides/faq/#como-se-gestionan-los-roles-de-usuario-en-el-sistema","title":"\u00bfC\u00f3mo se gestionan los roles de usuario en el sistema?","text":"<p>Los roles de usuario se gestionan a trav\u00e9s de la base de datos y se asignan durante la creaci\u00f3n del usuario. Los roles determinan los permisos y accesos dentro del sistema. Para m\u00e1s informaci\u00f3n, revisa el m\u00f3dulo de usuarios en la documentaci\u00f3n del c\u00f3digo.</p>"},{"location":"guides/faq/#donde-puedo-encontrar-la-documentacion-de-la-api","title":"\u00bfD\u00f3nde puedo encontrar la documentaci\u00f3n de la API?","text":"<p>La documentaci\u00f3n de la API se genera autom\u00e1ticamente y est\u00e1 disponible en:</p> <ul> <li>Swagger UI: <code>http://localhost:8000/docs</code></li> <li>ReDoc: <code>http://localhost:8000/redoc</code></li> </ul>"},{"location":"guides/faq/#como-se-despliega-agroinsight","title":"\u00bfC\u00f3mo se despliega AgroInsight?","text":"<p>El despliegue se realiza autom\u00e1ticamente en la plataforma Railway al fusionar cambios en la rama <code>main</code>. Aseg\u00farate de que todas las pruebas pasen antes de fusionar tus cambios. Para m\u00e1s detalles, consulta la secci\u00f3n de Despliegue.</p>"},{"location":"guides/faq/#como-puedo-reportar-un-problema-o-sugerir-una-mejora","title":"\u00bfC\u00f3mo puedo reportar un problema o sugerir una mejora?","text":"<p>Puedes reportar problemas o sugerir mejoras creando un issue en el repositorio de GitHub. Aseg\u00farate de proporcionar una descripci\u00f3n detallada y, si es posible, pasos para reproducir el problema.</p>"},{"location":"guides/faq/#donde-puedo-encontrar-mas-informacion-sobre-las-practicas-de-codificacion","title":"\u00bfD\u00f3nde puedo encontrar m\u00e1s informaci\u00f3n sobre las pr\u00e1cticas de codificaci\u00f3n?","text":"<p>Revisa la Gu\u00eda de Est\u00e1ndares de Codificaci\u00f3n para conocer las convenciones y pr\u00e1cticas recomendadas en el proyecto.</p>"},{"location":"guides/getting_started/","title":"Gu\u00eda de Inicio R\u00e1pido para Desarrolladores Backend de AgroInsight","text":""},{"location":"guides/getting_started/#introduccion","title":"Introducci\u00f3n","text":"<p>Bienvenido al equipo de desarrollo backend de AgroInsight. Esta gu\u00eda te proporcionar\u00e1 la informaci\u00f3n necesaria para comenzar a contribuir al proyecto. AgroInsight es una aplicaci\u00f3n de gesti\u00f3n agr\u00edcola dise\u00f1ada para optimizar el cultivo de ma\u00edz en la regi\u00f3n del Huila, Colombia, utilizando tecnolog\u00edas modernas y pr\u00e1cticas de desarrollo \u00e1gil.</p>"},{"location":"guides/getting_started/#estructura-del-proyecto","title":"Estructura del Proyecto","text":"<p>El proyecto sigue una arquitectura limpia y est\u00e1 organizado en m\u00f3dulos, cada uno con sus propias capas. La estructura general es la siguiente:</p> <pre><code>app/\n\u251c\u2500\u2500 [nombre_del_modulo]/\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2514\u2500\u2500 infrastructure/\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u251c\u2500\u2500 common/\n\u2502   \u251c\u2500\u2500 database/\n\u2502   \u251c\u2500\u2500 security/\n\u2502   \u2514\u2500\u2500 services/\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"guides/getting_started/#estructura-de-un-modulo","title":"Estructura de un M\u00f3dulo","text":"<p>Cuando se desarrolla un nuevo m\u00f3dulo, se debe crear una carpeta con el nombre del m\u00f3dulo dentro de <code>app/</code> y dentro de ella las siguientes subcarpetas y archivos:</p> <ul> <li><code>application/</code>: Contiene los casos de uso (archivos <code>*_use_case.py</code>).</li> <li><code>domain/</code>: Define las entidades y reglas de negocio.</li> <li><code>schemas.py</code>: Define los esquemas Pydantic del m\u00f3dulo.</li> <li><code>infrastructure/</code>:</li> <li><code>api.py</code>: Define los endpoints del m\u00f3dulo.</li> <li><code>sql_repository.py</code>: Contiene las transacciones de la base de datos.</li> <li><code>orm_models.py</code>: Define los modelos ORM del m\u00f3dulo.</li> </ul>"},{"location":"guides/getting_started/#infraestructura-comun","title":"Infraestructura Com\u00fan","text":"<p>La carpeta <code>app/infrastructure</code> contiene archivos comunes a todo el proyecto, incluyendo:</p> <ul> <li>Conexi\u00f3n a la base de datos</li> <li>Middleware JWT</li> <li>Servicios para env\u00edo de emails</li> <li>Servicios para generaci\u00f3n de PINs de seguridad</li> <li>Servicios de encriptaci\u00f3n de contrase\u00f1as</li> <li>Servicios de generaci\u00f3n de tokens de acceso</li> <li>Validadores</li> <li>Response mappers</li> <li>Importaciones de variables de entorno</li> <li>Errores personalizados</li> <li>Manejadores de errores</li> <li>C\u00f3digo com\u00fan utilizado en todos los m\u00f3dulos</li> </ul>"},{"location":"guides/getting_started/#principios-de-desarrollo","title":"Principios de Desarrollo","text":""},{"location":"guides/getting_started/#clean-code-y-arquitectura-limpia","title":"Clean Code y Arquitectura Limpia","text":"<p>El proyecto AgroInsight sigue los principios de Clean Code y Arquitectura Limpia. Esto implica:</p> <ol> <li>Separaci\u00f3n clara de responsabilidades entre capas.</li> <li>Dependencias apuntando hacia el dominio.</li> <li>Entidades de negocio independientes de frameworks y detalles de implementaci\u00f3n.</li> <li>Casos de uso que encapsulan la l\u00f3gica de la aplicaci\u00f3n.</li> </ol>"},{"location":"guides/getting_started/#convenciones-de-codigo","title":"Convenciones de C\u00f3digo","text":"<ul> <li>Seguimos la gu\u00eda de estilo PEP 8 para Python.</li> <li>Utilizamos Type Hints para anotaciones de tipo.</li> <li>Documentamos las funciones y clases utilizando docstrings en formato Google.</li> <li>Utilizamos Black para el formateo autom\u00e1tico del c\u00f3digo.</li> <li>Empleamos Flake8 para el linting del c\u00f3digo.</li> </ul>"},{"location":"guides/getting_started/#practicas-de-codificacion","title":"Pr\u00e1cticas de Codificaci\u00f3n","text":"<ol> <li> <p>Early Return: Preferimos el estilo de \"early return\" para mejorar la legibilidad y reducir la anidaci\u00f3n.</p> </li> <li> <p>DRY (Don't Repeat Yourself): Si notas que est\u00e1s repitiendo el mismo c\u00f3digo en m\u00faltiples lugares, refactoriza ese c\u00f3digo en una funci\u00f3n o m\u00e9todo reutilizable.</p> </li> <li> <p>Estructura del Proyecto: Al desarrollar o refactorizar una funcionalidad de un m\u00f3dulo existente, sigue la estructura ya definida para mantener la consistencia.</p> </li> <li> <p>Nombres Descriptivos: Usa nombres claros y significativos para variables, funciones y clases.</p> </li> <li> <p>Funciones Peque\u00f1as: Las funciones deben ser cortas y hacer una sola cosa.</p> </li> <li> <p>Comentarios \u00datiles: Los comentarios deben explicar el \"por qu\u00e9\", no el \"qu\u00e9\". El c\u00f3digo debe ser autoexplicativo.</p> </li> <li> <p>Manejo de Errores: Implementa un manejo de errores personalizado para la l\u00f3gica de negocio, la validaci\u00f3n de datos de entrada y los errores inesperados. Los mensajes deben ser claros y consistente.</p> </li> </ol>"},{"location":"guides/getting_started/#flujo-de-trabajo-de-desarrollo","title":"Flujo de Trabajo de Desarrollo","text":"<ol> <li>Crea una nueva rama para tu feature o bugfix:</li> </ol> <pre><code>git checkout -b feature/nombre-de-la-caracteristica\n</code></pre> <ol> <li> <p>Desarrolla tu c\u00f3digo siguiendo las convenciones y principios establecidos.</p> </li> <li> <p>Ejecuta las pruebas unitarias y aseg\u00farate de que pasen:</p> </li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Formatea tu c\u00f3digo:</li> </ol> <pre><code>black .\n</code></pre> <ol> <li>Ejecuta el linter:</li> </ol> <pre><code>flake8\n</code></pre> <ol> <li>Realiza un commit de tus cambios:</li> </ol> <pre><code>git add .\ngit commit -m \"Descripci\u00f3n concisa de los cambios\"\n</code></pre> <ol> <li>Sube tus cambios a GitHub:</li> </ol> <pre><code>git push origin feature/nombre-de-la-caracteristica\n</code></pre> <ol> <li>Crea un Pull Request en GitHub para revisi\u00f3n.</li> </ol>"},{"location":"guides/getting_started/#trabajando-con-la-base-de-datos","title":"Trabajando con la Base de Datos","text":"<p>AgroInsight utiliza Postgresql 16.2 como sistema de gesti\u00f3n de base de datos. La estructura de la base de datos se administra a trav\u00e9s de PgAdmin utilizando lenguaje SQL. La estructura est\u00e1 documentada en https://dbdocs.io/davidvalencia0526/AgroInsight.</p>"},{"location":"guides/getting_started/#integracion-con-servicios-externos","title":"Integraci\u00f3n con Servicios Externos","text":"<p>AgroInsight integra varios servicios externos. Aseg\u00farate de tener las credenciales necesarias en tu archivo <code>.env</code>:</p> <ul> <li>API de OpenWeatherMap para datos meteorol\u00f3gicos</li> <li>Servicio de correo electr\u00f3nico (SMTP) para notificaciones</li> <li>Servicios de almacenamiento en la nube para im\u00e1genes y archivos</li> </ul>"},{"location":"guides/getting_started/#pruebas","title":"Pruebas","text":"<p>Ejecutamos pruebas unitarias, de integraci\u00f3n y end-to-end. Para ejecutar todas las pruebas:</p> <pre><code>pytest\n</code></pre> <p>Para ejecutar pruebas espec\u00edficas:</p> <pre><code>pytest tests/unit\npytest tests/integration\npytest tests/e2e\n</code></pre>"},{"location":"guides/getting_started/#documentacion","title":"Documentaci\u00f3n","text":"<p>La documentaci\u00f3n del API se genera autom\u00e1ticamente y est\u00e1 disponible en:</p> <ul> <li>Swagger UI: <code>http://localhost:8000/docs</code></li> <li>ReDoc: <code>http://localhost:8000/redoc</code></li> </ul> <p>Para generar la documentaci\u00f3n del proyecto:</p> <pre><code>mkdocs serve\n</code></pre> <p>Esto iniciar\u00e1 un servidor local con la documentaci\u00f3n en <code>http://localhost:8000</code>.</p>"},{"location":"guides/getting_started/#despliegue","title":"Despliegue","text":"<p>El despliegue se realiza autom\u00e1ticamente a trav\u00e9s de Railway cuando se fusiona c\u00f3digo en la rama <code>main</code>. Aseg\u00farate de que todas las pruebas pasen antes de fusionar tus cambios.</p>"},{"location":"guides/getting_started/#ejemplo-de-creacion-de-un-nuevo-modulo","title":"Ejemplo de Creaci\u00f3n de un Nuevo M\u00f3dulo","text":"<p>Para ilustrar c\u00f3mo crear un nuevo m\u00f3dulo en AgroInsight, vamos a desarrollar un m\u00f3dulo de \"An\u00e1lisis de Suelo\". Este m\u00f3dulo permitir\u00e1 a los usuarios registrar y consultar an\u00e1lisis de suelo para sus lotes.</p>"},{"location":"guides/getting_started/#1-estructura-del-modulo","title":"1. Estructura del M\u00f3dulo","text":"<p>Primero, creamos la estructura de carpetas para el nuevo m\u00f3dulo:</p> <pre><code>app/\n\u2514\u2500\u2500 soil_analysis/\n    \u251c\u2500\u2500 application/\n    \u2502   \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 domain/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 schemas.py\n    \u2514\u2500\u2500 infrastructure/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py\n        \u251c\u2500\u2500 orm_models.py\n        \u2514\u2500\u2500 sql_repository.py\n</code></pre>"},{"location":"guides/getting_started/#2-definicion-de-esquemas-domainschemaspy","title":"2. Definici\u00f3n de Esquemas (domain/schemas.py)","text":"<pre><code>from pydantic import BaseModel, Field\nfrom datetime import date\nfrom typing import Optional\n\nclass SoilAnalysisBase(BaseModel):\n    lote_id: int\n    fecha_analisis: date\n    ph: float = Field(..., ge=0, le=14)\n    materia_organica: float = Field(..., ge=0, le=100)\n    nitrogeno: float = Field(..., ge=0)\n    fosforo: float = Field(..., ge=0)\n    potasio: float = Field(..., ge=0)\n    observaciones: Optional[str] = None\n\nclass SoilAnalysisCreate(SoilAnalysisBase):\n    pass\n\nclass SoilAnalysisResponse(SoilAnalysisBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"guides/getting_started/#3-definicion-de-modelos-orm-infrastructureorm_modelspy","title":"3. Definici\u00f3n de Modelos ORM (infrastructure/orm_models.py)","text":"<pre><code>from sqlalchemy import Column, Integer, Float, Date, ForeignKey, Text\nfrom app.infrastructure.database.database import Base\n\nclass SoilAnalysis(Base):\n    __tablename__ = \"analisis_suelo\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    lote_id = Column(Integer, ForeignKey(\"lote.id\"), nullable=False)\n    fecha_analisis = Column(Date, nullable=False)\n    ph = Column(Float, nullable=False)\n    materia_organica = Column(Float, nullable=False)\n    nitrogeno = Column(Float, nullable=False)\n    fosforo = Column(Float, nullable=False)\n    potasio = Column(Float, nullable=False)\n    observaciones = Column(Text)\n</code></pre>"},{"location":"guides/getting_started/#4-implementacion-del-repositorio-infrastructuresql_repositorypy","title":"4. Implementaci\u00f3n del Repositorio (infrastructure/sql_repository.py)","text":"<pre><code>from sqlalchemy.orm import Session\nfrom app.soil_analysis.infrastructure.orm_models import SoilAnalysis\nfrom app.soil_analysis.domain.schemas import SoilAnalysisCreate\n\nclass SoilAnalysisRepository:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def create_soil_analysis(self, soil_analysis: SoilAnalysisCreate) -&gt; SoilAnalysis:\n        db_soil_analysis = SoilAnalysis(**soil_analysis.model_dump())\n        self.db.add(db_soil_analysis)\n        self.db.commit()\n        self.db.refresh(db_soil_analysis)\n        return db_soil_analysis\n\n    def get_soil_analysis(self, soil_analysis_id: int) -&gt; SoilAnalysis:\n        return self.db.query(SoilAnalysis).filter(SoilAnalysis.id == soil_analysis_id).first()\n\n    def get_soil_analyses_by_lote(self, lote_id: int):\n        return self.db.query(SoilAnalysis).filter(SoilAnalysis.lote_id == lote_id).all()\n</code></pre>"},{"location":"guides/getting_started/#5-implementacion-del-caso-de-uso-applicationcreate_soil_analysis_use_casepy","title":"5. Implementaci\u00f3n del Caso de Uso (application/create_soil_analysis_use_case.py)","text":"<pre><code>from sqlalchemy.orm import Session\nfrom app.soil_analysis.infrastructure.sql_repository import SoilAnalysisRepository\nfrom app.soil_analysis.domain.schemas import SoilAnalysisCreate, SoilAnalysisResponse\nfrom app.infrastructure.common.common_exceptions import DomainException\nfrom app.user.domain.schemas import UserInDB\nfrom fastapi import status\n\nclass CreateSoilAnalysisUseCase:\n    def __init__(self, db: Session):\n        self.db = db\n        self.soil_analysis_repository = SoilAnalysisRepository(db)\n\n    def execute(self, soil_analysis_data: SoilAnalysisCreate, current_user: UserInDB) -&gt; SoilAnalysisResponse:\n        if not self.user_can_create_soil_analysis(current_user):\n            raise DomainException(\n                message=\"No tienes permisos para crear un an\u00e1lisis de suelo.\",\n                status_code=status.HTTP_403_FORBIDDEN\n            )\n\n        # Aqu\u00ed podr\u00edas agregar m\u00e1s validaciones, como verificar si el lote existe y pertenece al usuario\n\n        soil_analysis = self.soil_analysis_repository.create_soil_analysis(soil_analysis_data)\n        return SoilAnalysisResponse.model_validate(soil_analysis)\n\n    def user_can_create_soil_analysis(self, user: UserInDB) -&gt; bool:\n        allowed_roles = [\"Administrador de Finca\", \"Agr\u00f3nomo\"]\n        return any(role.nombre in allowed_roles for role in user.roles)\n</code></pre>"},{"location":"guides/getting_started/#6-definicion-de-la-api-infrastructureapipy","title":"6. Definici\u00f3n de la API (infrastructure/api.py)","text":"<pre><code>from fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom app.infrastructure.database.database import getDb\nfrom app.soil_analysis.domain.schemas import SoilAnalysisCreate, SoilAnalysisResponse\nfrom app.soil_analysis.application.create_soil_analysis_use_case import CreateSoilAnalysisUseCase\nfrom app.infrastructure.security.security_utils import get_current_user\nfrom app.user.domain.schemas import UserInDB\n\nrouter = APIRouter(prefix=\"/soil-analysis\", tags=[\"Soil Analysis\"])\n\n@router.post(\"/\", response_model=SoilAnalysisResponse)\ndef create_soil_analysis(\n    soil_analysis: SoilAnalysisCreate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n):\n    use_case = CreateSoilAnalysisUseCase(db)\n    try:\n        return use_case.execute(soil_analysis, current_user)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, \n            detail=f\"Error interneo al crear el an\u00e1lisis de suelo: {str(e)}\"\n            )\n</code></pre>"},{"location":"guides/getting_started/#7-integracion-con-el-sistema-principal-mainpy","title":"7. Integraci\u00f3n con el Sistema Principal (main.py)","text":"<p>Finalmente, incluimos el router del nuevo m\u00f3dulo en el archivo principal de la aplicaci\u00f3n:</p> <pre><code>from fastapi import FastAPI\nfrom app.soil_analysis.infrastructure.api import router as soil_analysis_router\n\napp = FastAPI()\n\n# ... otros imports y configuraciones ...\n\napp.include_router(soil_analysis_router)\n</code></pre>"},{"location":"guides/getting_started/#uso-de-servicios-comunes","title":"Uso de Servicios Comunes","text":"<p>En este ejemplo, hemos utilizado varios servicios y componentes comunes del proyecto:</p> <ol> <li>Base de datos: Utilizamos la sesi\u00f3n de base de datos proporcionada por <code>getDb()</code>.</li> <li>Autenticaci\u00f3n: Usamos <code>get_current_user()</code> para obtener el usuario autenticado.</li> <li>Manejo de excepciones: Empleamos <code>DomainException</code> para errores de dominio personalizados.</li> <li>Modelos ORM: Extendemos <code>Base</code> de SQLAlchemy para nuestro modelo ORM.</li> <li>Validaci\u00f3n de datos: Utilizamos Pydantic para la validaci\u00f3n de datos de entrada y salida.</li> </ol>"},{"location":"guides/getting_started/#recursos-adicionales","title":"Recursos Adicionales","text":"<ul> <li>Documentaci\u00f3n oficial de FastAPI</li> <li>Documentaci\u00f3n de SQLAlchemy</li> <li>Gu\u00eda de Railway para despliegue</li> <li>Documentaci\u00f3n de TensorFlow</li> </ul>"},{"location":"guides/getting_started/#soporte","title":"Soporte","text":"<p>Si encuentras alg\u00fan problema o tienes preguntas, no dudes en contactar al equipo de desarrollo a trav\u00e9s del canal #backend-support en Slack.</p> <p>\u00a1Bienvenido al equipo y feliz codificaci\u00f3n!</p>"},{"location":"guides/installation/","title":"Gu\u00eda de Instalaci\u00f3n de AgroInsight","text":"<p>Esta gu\u00eda proporciona instrucciones detalladas para configurar el entorno de desarrollo del proyecto AgroInsight. Sigue cada paso cuidadosamente para asegurar una instalaci\u00f3n correcta y completa.</p>"},{"location":"guides/installation/#prerrequisitos","title":"Prerrequisitos","text":"<p>Antes de comenzar, aseg\u00farate de tener instalado lo siguiente:</p> <ol> <li>Python 3.12 o superior: Descarga e instala desde python.org.</li> <li>VS Code: Descarga e instala desde code.visualstudio.com.</li> <li>PostgreSQL 16.2: Descarga e instala desde postgresql.org.</li> <li>PgAdmin: Descarga e instala desde pgadmin.org.</li> <li>pip: Generalmente se instala con Python. Verifica con <code>pip --version</code>.</li> <li>Poetry: Instala ejecutando <code>pip install poetry</code>.</li> <li>Git: Descarga e instala desde git-scm.com.</li> <li>Cuenta de GitHub: Crea una cuenta en github.com.</li> <li>Docker Desktop: Descarga e instala desde docker.com.</li> </ol>"},{"location":"guides/installation/#pasos-de-instalacion-del-proyecto","title":"Pasos de Instalaci\u00f3n del proyecto","text":""},{"location":"guides/installation/#1-clonar-los-repositorios","title":"1. Clonar los Repositorios","text":"<pre><code>git clone https://github.com/DavidValenciaX/agroinsight-backend.git\ncd agroinsight-backend\n</code></pre>"},{"location":"guides/installation/#2-configurar-el-entorno-virtual-para-el-backend","title":"2. Configurar el Entorno Virtual para el Backend","text":"<pre><code>poetry config virtualenvs.in-project true\npoetry install\n</code></pre>"},{"location":"guides/installation/#3-instalar-dependencias-del-backend","title":"3. Instalar Dependencias del Backend","text":"<pre><code>poetry install\n</code></pre>"},{"location":"guides/installation/#4-configurar-variables-de-entorno","title":"4. Configurar Variables de Entorno","text":"<p>Crea un archivo <code>.env</code> en la ra\u00edz del proyecto backend y a\u00f1ade las siguientes variables:</p> <pre><code>DATABASE_URL=\"postgresql://user:password@host:port/database\"\nSECRET_KEY=tu_clave_secreta\nGMAIL_USER=tu_correo@gmail.com\nGMAIL_APP_PASSWORD=tu_contrase\u00f1a_de_aplicacion\n</code></pre> <p>Solicita los valores reales a un miembro del equipo.</p>"},{"location":"guides/installation/#5-correr-el-servidor-backend","title":"5. Correr el servidor Backend","text":"<pre><code>poetry run uvicorn app.main:app --reload\n</code></pre>"},{"location":"guides/installation/#verificacion-de-la-instalacion","title":"Verificaci\u00f3n de la Instalaci\u00f3n","text":"<ol> <li>Backend: Visita <code>http://localhost:8000/docs</code> para ver la documentaci\u00f3n Swagger de la API.</li> </ol>"},{"location":"guides/installation/#solucion-de-problemas-comunes","title":"Soluci\u00f3n de Problemas Comunes","text":"<ul> <li>Problemas con dependencias de Python: Aseg\u00farate de usar Python 3.12 y que el entorno virtual est\u00e9 activado.</li> <li>Errores de base de datos: Verifica que el contenedor Docker de Postgresql est\u00e9 corriendo y las credenciales en <code>.env</code> sean correctas.</li> <li>Problemas con TensorFlow o OpenCV: Aseg\u00farate de que tu sistema cumple con los requisitos de hardware para IA.</li> </ul>"},{"location":"guides/installation/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Revisa la Gu\u00eda de Inicio R\u00e1pido para comenzar a desarrollar.</li> <li>Familiar\u00edzate con la estructura del proyecto y los est\u00e1ndares de c\u00f3digo.</li> <li>Configura tu entorno de desarrollo siguiendo las mejores pr\u00e1cticas del equipo.</li> </ul> <p>Para cualquier problema adicional, consulta la secci\u00f3n de FAQ o contacta al equipo de desarrollo a trav\u00e9s de Slack.</p>"},{"location":"plot/endpoints/","title":"endpoints","text":"<p>Contenido para docs\\plot\\endpoints.md</p>"},{"location":"plot/models/","title":"models","text":"<p>Contenido para docs\\plot\\models.md</p>"},{"location":"plot/overview/","title":"overview","text":"<p>Contenido para docs\\plot\\overview.md</p>"},{"location":"plot/use_cases/","title":"use_cases","text":"<p>Contenido para docs\\plot\\use_cases.md</p>"},{"location":"user/endpoints/","title":"Endpoints de Usuario","text":"<p>Este documento describe los endpoints disponibles para la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/endpoints/#autenticacion-y-autorizacion","title":"Autenticaci\u00f3n y Autorizaci\u00f3n","text":""},{"location":"user/endpoints/#registro-de-usuario","title":"Registro de Usuario","text":"<p>Registra un nuevo usuario en el sistema.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>UserCreate</code> <p>Datos del usuario a registrar.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto con mensaje de \u00e9xito.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el registro.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/register\", response_model=SuccessResponse, status_code=status.HTTP_201_CREATED)\ndef register_user(\n    user: UserCreate,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb),\n) -&gt; SuccessResponse:\n    \"\"\"\n    Registra un nuevo usuario en el sistema.\n\n    Args:\n        user (UserCreate): Datos del usuario a registrar.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto con mensaje de \u00e9xito.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el registro.\n    \"\"\"\n    creation_use_case = UserRegisterUseCase(db)\n    # Llamamos al caso de uso sin manejar excepciones aqu\u00ed\n    try:\n        return creation_use_case.register_user(user, background_tasks)\n    except (DomainException, UserStateException) as e:\n        # Permite que los manejadores de excepciones globales de FastAPI manejen las excepciones\n        raise e\n    except Exception as e:\n        # Para cualquier otra excepci\u00f3n no esperada, lanza un error HTTP 500 gen\u00e9rico\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno en el registro de usuario: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#confirmacion-de-registro","title":"Confirmaci\u00f3n de Registro","text":"<p>Confirma el registro de un usuario utilizando un PIN.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>ConfirmationRequest</code> <p>Datos de confirmaci\u00f3n del usuario.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el registro fue confirmado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la confirmaci\u00f3n del registro.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/confirm\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef confirm_user_registration(\n    confirmation: ConfirmationRequest,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el registro de un usuario utilizando un PIN.\n\n    Args:\n        confirmation (ConfirmationRequest): Datos de confirmaci\u00f3n del usuario.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el registro fue confirmado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la confirmaci\u00f3n del registro.\n    \"\"\"\n    confirmation_use_case = ConfirmationUseCase(db)\n    try:\n        return confirmation_use_case.confirm_user(confirmation.email, confirmation.pin)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al confirmar el registro de usuario: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#reenvio-de-pin-de-confirmacion","title":"Reenv\u00edo de PIN de Confirmaci\u00f3n","text":"<p>Reenv\u00eda el PIN de confirmaci\u00f3n al correo electr\u00f3nico del usuario.</p> <p>Parameters:</p> Name Type Description Default <code>resend_request</code> <code>ResendPinConfirmRequest</code> <p>Solicitud de reenv\u00edo de PIN.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN fue reenviado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el reenv\u00edo del PIN.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/resend-confirm-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef resend_confirmation_pin_endpoint(\n    resend_request: ResendPinConfirmRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de confirmaci\u00f3n al correo electr\u00f3nico del usuario.\n\n    Args:\n        resend_request (ResendPinConfirmRequest): Solicitud de reenv\u00edo de PIN.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN fue reenviado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el reenv\u00edo del PIN.\n    \"\"\"\n    resend_confirmation_use_case = ResendConfirmationUseCase(db)\n    try:\n        return resend_confirmation_use_case.resend_confirmation(resend_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al reenviar el PIN de confirmaci\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#inicio-de-sesion","title":"Inicio de Sesi\u00f3n","text":"<p>Inicia el proceso de doble factor de autenticaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>login_request</code> <code>LoginRequest</code> <p>Datos de inicio de sesi\u00f3n del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto con el token de acceso.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el inicio de sesi\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/login\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef login_for_access_token(login_request: LoginRequest, background_tasks: BackgroundTasks, db: Session = Depends(getDb)) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de doble factor de autenticaci\u00f3n.\n\n    Args:\n        login_request (LoginRequest): Datos de inicio de sesi\u00f3n del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto con el token de acceso.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el inicio de sesi\u00f3n.\n    \"\"\"\n    login_use_case = LoginUseCase(db)\n    try:\n        return login_use_case.login_user(login_request.email, login_request.password, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al procesar el inicio de sesi\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#verificacion-de-autenticacion-de-dos-factores","title":"Verificaci\u00f3n de Autenticaci\u00f3n de Dos Factores","text":"<p>Verifica el inicio de sesi\u00f3n utilizando el PIN de doble factor de autenticaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>auth_request</code> <code>TwoFactorAuthRequest</code> <p>Datos de autenticaci\u00f3n de dos factores.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>TokenResponse</code> <code>TokenResponse</code> <p>Objeto con el token de acceso.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la verificaci\u00f3n del inicio de sesi\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/login/verify\", response_model=TokenResponse, status_code=status.HTTP_200_OK)\ndef verify_login(auth_request: TwoFactorAuthRequest, db: Session = Depends(getDb)) -&gt; TokenResponse:\n    \"\"\"\n    Verifica el inicio de sesi\u00f3n utilizando el PIN de doble factor de autenticaci\u00f3n.\n\n    Args:\n        auth_request (TwoFactorAuthRequest): Datos de autenticaci\u00f3n de dos factores.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        TokenResponse: Objeto con el token de acceso.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la verificaci\u00f3n del inicio de sesi\u00f3n.\n    \"\"\"\n    verify_use_case = VerifyUseCase(db)\n    try:\n        return verify_use_case.verify_2fa(auth_request.email, auth_request.pin)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al verificar el inicio de sesi\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#reenvio-de-pin-de-autenticacion-de-dos-factores","title":"Reenv\u00edo de PIN de Autenticaci\u00f3n de Dos Factores","text":"<p>Reenv\u00eda el PIN de doble factor de autenticaci\u00f3n al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>resend_request</code> <code>Resend2FARequest</code> <p>Solicitud de reenv\u00edo de PIN de 2FA.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN de 2FA fue reenviado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el reenv\u00edo del PIN de 2FA.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/resend-2fa-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef resend_2fa_pin_endpoint(\n    resend_request: Resend2FARequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de doble factor de autenticaci\u00f3n al usuario.\n\n    Args:\n        resend_request (Resend2FARequest): Solicitud de reenv\u00edo de PIN de 2FA.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN de 2FA fue reenviado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el reenv\u00edo del PIN de 2FA.\n    \"\"\"\n    resend_2fa_use_case = Resend2faUseCase(db)\n    try:\n        return resend_2fa_use_case.resend_2fa(resend_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al reenviar el PIN de doble factor de autenticaci\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#cierre-de-sesion","title":"Cierre de Sesi\u00f3n","text":"<p>Cierra la sesi\u00f3n del usuario actual.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>credentials</code> <code>HTTPAuthorizationCredentials</code> <p>Credenciales de autorizaci\u00f3n HTTP.</p> <code>Security(security_scheme)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que la sesi\u00f3n fue cerrada exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el cierre de sesi\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/logout\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef logout(\n    current_user: UserInDB = Depends(get_current_user),\n    db: Session = Depends(getDb),\n    credentials: HTTPAuthorizationCredentials = Security(security_scheme)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Cierra la sesi\u00f3n del usuario actual.\n\n    Args:\n        current_user (UserInDB): Usuario actual autenticado.\n        db (Session): Sesi\u00f3n de base de datos.\n        credentials (HTTPAuthorizationCredentials): Credenciales de autorizaci\u00f3n HTTP.\n\n    Returns:\n        SuccessResponse: Objeto indicando que la sesi\u00f3n fue cerrada exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el cierre de sesi\u00f3n.\n    \"\"\"\n    token = credentials.credentials\n    logout_use_case = LogoutUseCase(db)\n    try:\n        return logout_use_case.logout(token, current_user.id)\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"No se pudo cerrar la sesi\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#gestion-de-contrasenas","title":"Gesti\u00f3n de Contrase\u00f1as","text":""},{"location":"user/endpoints/#recuperacion-de-contrasena","title":"Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.</p> <p>Parameters:</p> Name Type Description Default <code>recovery_request</code> <code>PasswordRecoveryRequest</code> <p>Solicitud de recuperaci\u00f3n de contrase\u00f1a.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el proceso de recuperaci\u00f3n fue iniciado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el inicio del proceso de recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/password-recovery\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef initiate_password_recovery(\n    recovery_request: PasswordRecoveryRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n    Args:\n        recovery_request (PasswordRecoveryRequest): Solicitud de recuperaci\u00f3n de contrase\u00f1a.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el proceso de recuperaci\u00f3n fue iniciado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el inicio del proceso de recuperaci\u00f3n.\n    \"\"\"\n    password_recovery_use_case = PasswordRecoveryUseCase(db)\n    try:\n        return password_recovery_use_case.recovery_password(recovery_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al iniciar el proceso de recuperaci\u00f3n de contrase\u00f1a: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#confirmacion-de-pin-de-recuperacion","title":"Confirmaci\u00f3n de PIN de Recuperaci\u00f3n","text":"<p>Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Parameters:</p> Name Type Description Default <code>pin_confirmation</code> <code>PinConfirmationRequest</code> <p>Datos de confirmaci\u00f3n del PIN de recuperaci\u00f3n.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN de recuperaci\u00f3n fue confirmado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la confirmaci\u00f3n del PIN de recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/confirm-recovery-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef confirm_recovery_pin(\n    pin_confirmation: PinConfirmationRequest,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Args:\n        pin_confirmation (PinConfirmationRequest): Datos de confirmaci\u00f3n del PIN de recuperaci\u00f3n.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN de recuperaci\u00f3n fue confirmado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la confirmaci\u00f3n del PIN de recuperaci\u00f3n.\n    \"\"\"\n    password_recovery_use_case = ConfirmRecoveryPinUseCase(db)\n    try:\n        return password_recovery_use_case.confirm_recovery(pin_confirmation.email, pin_confirmation.pin)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error al confirmar el PIN de recuperaci\u00f3n: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#reenvio-de-pin-de-recuperacion","title":"Reenv\u00edo de PIN de Recuperaci\u00f3n","text":"<p>Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>recovery_request</code> <code>PasswordRecoveryRequest</code> <p>Solicitud de reenv\u00edo de PIN de recuperaci\u00f3n.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que el PIN de recuperaci\u00f3n fue reenviado exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el reenv\u00edo del PIN de recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/resend-recovery-pin\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef resend_recovery_pin(\n    recovery_request: PasswordRecoveryRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a al usuario.\n\n    Args:\n        recovery_request (PasswordRecoveryRequest): Solicitud de reenv\u00edo de PIN de recuperaci\u00f3n.\n        background_tasks (BackgroundTasks): Tareas en segundo plano.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que el PIN de recuperaci\u00f3n fue reenviado exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el reenv\u00edo del PIN de recuperaci\u00f3n.\n    \"\"\"\n    password_recovery_use_case = ResendRecoveryUseCase(db)\n    try:\n        return password_recovery_use_case.resend_recovery(recovery_request.email, background_tasks)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno en el reenvio del PIN de recuperaci\u00f3n de contrase\u00f1a: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#restablecimiento-de-contrasena","title":"Restablecimiento de Contrase\u00f1a","text":"<p>Restablece la contrase\u00f1a de un usuario.</p> <p>Parameters:</p> Name Type Description Default <code>reset_request</code> <code>PasswordResetRequest</code> <p>Solicitud de restablecimiento de contrase\u00f1a.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que la contrase\u00f1a fue restablecida exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante el restablecimiento de la contrase\u00f1a.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.post(\"/reset-password\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef reset_password(\n    reset_request: PasswordResetRequest,\n    db: Session = Depends(getDb)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Restablece la contrase\u00f1a de un usuario.\n\n    Args:\n        reset_request (PasswordResetRequest): Solicitud de restablecimiento de contrase\u00f1a.\n        db (Session): Sesi\u00f3n de base de datos.\n\n    Returns:\n        SuccessResponse: Objeto indicando que la contrase\u00f1a fue restablecida exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante el restablecimiento de la contrase\u00f1a.\n    \"\"\"\n    password_recovery_use_case = ResetPasswordUseCase(db)\n    try:\n        return password_recovery_use_case.reset_password(reset_request.email, reset_request.new_password)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Error interno al reestablecer la contrase\u00f1a: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/endpoints/#gestion-de-perfil-de-usuario","title":"Gesti\u00f3n de Perfil de Usuario","text":""},{"location":"user/endpoints/#obtener-usuario-actual","title":"Obtener Usuario Actual","text":"Source code in <code>app\\infrastructure\\security\\jwt_middleware.py</code> <pre><code>def get_current_user(\n    credentials: Optional[HTTPAuthorizationCredentials] = Security(security_scheme),\n    db: Session = Depends(getDb)\n):\n    if credentials is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Se requiere un token de autenticaci\u00f3n\")\n\n    token = credentials.credentials\n    user_repository = UserRepository(db)\n\n    # Verificar si el token est\u00e1 en la lista negra\n    if user_repository.is_token_blacklisted(token):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Token inv\u00e1lido o ya ha sido cerrada la sesi\u00f3n.\")\n\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n\n        # Obtener el email del payload\n        email: str = payload.get(\"sub\")\n        if email is None:\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"No se pudo validar el email\")\n\n        # Obtener el tiempo de expiraci\u00f3n del payload\n        exp = payload.get(\"exp\")\n        if exp is None:\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"El token no tiene expiraci\u00f3n.\")\n\n        # Convertir el tiempo de expiraci\u00f3n a un objeto datetime\n        expiration_time = datetime.fromtimestamp(exp, tz=timezone.utc)\n\n        # Comparar el tiempo de expiraci\u00f3n con el tiempo actual\n        current_time = datetime_utc_time()\n\n        if expiration_time &lt; current_time:\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"El token ha expirado.\")\n    except JWTError as e:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=f\"No se pudieron validar las credenciales. {e}\")\n\n    user = user_repository.get_user_by_email(email)\n    if user is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"La cuenta con este email no est\u00e1 registrada\")\n    return user\n</code></pre>"},{"location":"user/endpoints/#actualizar-informacion-de-usuario","title":"Actualizar Informaci\u00f3n de Usuario","text":"<p>Actualiza la informaci\u00f3n del usuario actual.</p> <p>Parameters:</p> Name Type Description Default <code>user_update</code> <code>UserUpdate</code> <p>Datos de actualizaci\u00f3n del usuario.</p> required <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos.</p> <code>Depends(getDb)</code> <code>current_user</code> <code>UserInDB</code> <p>Usuario actual autenticado.</p> <code>Depends(get_current_user)</code> <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Objeto indicando que la informaci\u00f3n fue actualizada exitosamente.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Si ocurre un error durante la actualizaci\u00f3n de la informaci\u00f3n del usuario.</p> Source code in <code>app\\user\\infrastructure\\api.py</code> <pre><code>@user_router.put(\"/me/update\", response_model=SuccessResponse, status_code=status.HTTP_200_OK)\ndef update_user_info(\n    user_update: UserUpdate,\n    db: Session = Depends(getDb),\n    current_user: UserInDB = Depends(get_current_user)\n) -&gt; SuccessResponse:\n    \"\"\"\n    Actualiza la informaci\u00f3n del usuario actual.\n\n    Args:\n        user_update (UserUpdate): Datos de actualizaci\u00f3n del usuario.\n        db (Session): Sesi\u00f3n de base de datos.\n        current_user (UserInDB): Usuario actual autenticado.\n\n    Returns:\n        SuccessResponse: Objeto indicando que la informaci\u00f3n fue actualizada exitosamente.\n\n    Raises:\n        HTTPException: Si ocurre un error durante la actualizaci\u00f3n de la informaci\u00f3n del usuario.\n    \"\"\"\n    update_user_info_use_case = UpdateUserInfoUseCase(db)\n    try:\n        return update_user_info_use_case.update_user_info(current_user, user_update)\n    except (DomainException, UserStateException) as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"No se pudo actualizar la informaci\u00f3n del usuario: {str(e)}\"\n        ) from e\n</code></pre>"},{"location":"user/models/","title":"Modelos de Usuario","text":"<p>Este documento describe los modelos ORM utilizados para la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/models/#modelos-de-base-de-datos","title":"Modelos de Base de Datos","text":""},{"location":"user/models/#usuario","title":"Usuario","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'usuario' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>email</code> <code>str</code> <p>Correo electr\u00f3nico \u00fanico del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> <code>failed_attempts</code> <code>int</code> <p>N\u00famero de intentos fallidos de inicio de sesi\u00f3n.</p> <code>locked_until</code> <code>datetime</code> <p>Fecha y hora hasta la cual el usuario est\u00e1 bloqueado.</p> <code>state_id</code> <code>int</code> <p>Identificador del estado del usuario.</p> <code>estado</code> <code>UserState</code> <p>Estado actual del usuario.</p> <code>confirmacion</code> <code>UserConfirmation</code> <p>Informaci\u00f3n de confirmaci\u00f3n del usuario.</p> <code>verificacion_dos_pasos</code> <code>TwoStepVerification</code> <p>Informaci\u00f3n de verificaci\u00f3n de dos pasos.</p> <code>recuperacion_contrasena</code> <code>PasswordRecovery</code> <p>Informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a.</p> <code>blacklisted_tokens</code> <code>List[BlacklistedToken]</code> <p>Lista de tokens en lista negra.</p> <code>asignaciones</code> <code>List[Assignment]</code> <p>Lista de asignaciones del usuario.</p> <code>roles_fincas</code> <code>List[UserFarmRole]</code> <p>Lista de roles del usuario en diferentes fincas.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class User(Base):\n    \"\"\"\n    Representa la tabla 'usuario' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        email (str): Correo electr\u00f3nico \u00fanico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n        failed_attempts (int): N\u00famero de intentos fallidos de inicio de sesi\u00f3n.\n        locked_until (datetime): Fecha y hora hasta la cual el usuario est\u00e1 bloqueado.\n        state_id (int): Identificador del estado del usuario.\n        estado (UserState): Estado actual del usuario.\n        confirmacion (UserConfirmation): Informaci\u00f3n de confirmaci\u00f3n del usuario.\n        verificacion_dos_pasos (TwoStepVerification): Informaci\u00f3n de verificaci\u00f3n de dos pasos.\n        recuperacion_contrasena (PasswordRecovery): Informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a.\n        blacklisted_tokens (List[BlacklistedToken]): Lista de tokens en lista negra.\n        asignaciones (List[Assignment]): Lista de asignaciones del usuario.\n        roles_fincas (List[UserFarmRole]): Lista de roles del usuario en diferentes fincas.\n    \"\"\"\n    __tablename__ = \"usuario\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), nullable=False, index=True)\n    apellido = Column(String(50), nullable=False, index=True)\n    email = Column(String(100), unique=True, nullable=False, index=True)\n    password = Column(String(255), nullable=False)\n    failed_attempts = Column(Integer, default=0, nullable=False)\n    locked_until = Column(TIMESTAMP(timezone=True), nullable=True)  # Actualizado a TIMESTAMP\n    state_id = Column(Integer, ForeignKey('estado_usuario.id'), nullable=False)\n\n    estado = relationship(\"UserState\")\n    confirmacion = relationship(\"UserConfirmation\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    verificacion_dos_pasos = relationship(\"TwoStepVerification\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    recuperacion_contrasena = relationship(\"PasswordRecovery\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    blacklisted_tokens = relationship(\"BlacklistedToken\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    asignaciones = relationship(\"Assignment\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n    roles_fincas = relationship(\"UserFarmRole\", back_populates=\"usuario\", cascade=CASCADE_DELETE_ORPHAN)\n</code></pre>"},{"location":"user/models/#rol","title":"Rol","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'rol' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del rol.</p> <code>nombre</code> <code>str</code> <p>Nombre \u00fanico del rol.</p> <code>descripcion</code> <code>str</code> <p>Descripci\u00f3n del rol.</p> <code>usuario_fincas</code> <code>List[UserFarmRole]</code> <p>Lista de relaciones usuario-finca-rol asociadas a este rol.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class Role(Base):\n    \"\"\"\n    Representa la tabla 'rol' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del rol.\n        nombre (str): Nombre \u00fanico del rol.\n        descripcion (str): Descripci\u00f3n del rol.\n        usuario_fincas (List[UserFarmRole]): Lista de relaciones usuario-finca-rol asociadas a este rol.\n    \"\"\"\n    __tablename__ = \"rol\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), unique=True, nullable=False, index=True)\n    descripcion = Column(Text)\n\n    usuario_fincas = relationship(\"UserFarmRole\", back_populates=\"rol\")\n</code></pre>"},{"location":"user/models/#estado-de-usuario","title":"Estado de Usuario","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'estado_usuario' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del estado.</p> <code>nombre</code> <code>str</code> <p>Nombre \u00fanico del estado.</p> <code>descripcion</code> <code>str</code> <p>Descripci\u00f3n del estado.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class UserState(Base):\n    \"\"\"\n    Representa la tabla 'estado_usuario' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del estado.\n        nombre (str): Nombre \u00fanico del estado.\n        descripcion (str): Descripci\u00f3n del estado.\n    \"\"\"\n    __tablename__ = \"estado_usuario\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    nombre = Column(String(50), unique=True, nullable=False, index=True)\n    descripcion = Column(Text)\n</code></pre>"},{"location":"user/models/#confirmacion-de-usuario","title":"Confirmaci\u00f3n de Usuario","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'confirmacion_usuario' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la confirmaci\u00f3n.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>pin</code> <code>str</code> <p>PIN \u00fanico de confirmaci\u00f3n.</p> <code>expiracion</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n del PIN.</p> <code>intentos</code> <code>int</code> <p>N\u00famero de intentos de confirmaci\u00f3n.</p> <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n del registro.</p> <code>resends</code> <code>int</code> <p>N\u00famero de reenv\u00edos del PIN.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado a la confirmaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class UserConfirmation(Base):\n    \"\"\"\n    Representa la tabla 'confirmacion_usuario' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la confirmaci\u00f3n.\n        usuario_id (int): Identificador del usuario asociado.\n        pin (str): PIN \u00fanico de confirmaci\u00f3n.\n        expiracion (datetime): Fecha y hora de expiraci\u00f3n del PIN.\n        intentos (int): N\u00famero de intentos de confirmaci\u00f3n.\n        created_at (datetime): Fecha y hora de creaci\u00f3n del registro.\n        resends (int): N\u00famero de reenv\u00edos del PIN.\n        usuario (User): Usuario asociado a la confirmaci\u00f3n.\n    \"\"\"\n    __tablename__ = \"confirmacion_usuario\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID, ondelete=\"CASCADE\"), nullable=False)\n    pin = Column(String(64), nullable=False, unique=True, index=True)\n    expiracion = Column(TIMESTAMP(timezone=True), nullable=False)\n    intentos = Column(Integer, default=0)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    resends = Column(Integer, default=0)\n\n    usuario = relationship(\"User\", back_populates=\"confirmacion\")\n</code></pre>"},{"location":"user/models/#verificacion-de-dos-pasos","title":"Verificaci\u00f3n de Dos Pasos","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'verificacion_dos_pasos' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la verificaci\u00f3n.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>pin</code> <code>str</code> <p>PIN \u00fanico de verificaci\u00f3n.</p> <code>expiracion</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n del PIN.</p> <code>intentos</code> <code>int</code> <p>N\u00famero de intentos de verificaci\u00f3n.</p> <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n del registro.</p> <code>resends</code> <code>int</code> <p>N\u00famero de reenv\u00edos del PIN.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado a la verificaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class TwoStepVerification(Base):\n    \"\"\"\n    Representa la tabla 'verificacion_dos_pasos' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la verificaci\u00f3n.\n        usuario_id (int): Identificador del usuario asociado.\n        pin (str): PIN \u00fanico de verificaci\u00f3n.\n        expiracion (datetime): Fecha y hora de expiraci\u00f3n del PIN.\n        intentos (int): N\u00famero de intentos de verificaci\u00f3n.\n        created_at (datetime): Fecha y hora de creaci\u00f3n del registro.\n        resends (int): N\u00famero de reenv\u00edos del PIN.\n        usuario (User): Usuario asociado a la verificaci\u00f3n.\n    \"\"\"\n    __tablename__ = \"verificacion_dos_pasos\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID, ondelete=\"CASCADE\"), nullable=False)\n    pin = Column(String(64), nullable=False, unique=True, index=True)\n    expiracion = Column(TIMESTAMP(timezone=True), nullable=False)\n    intentos = Column(Integer, default=0)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    resends = Column(Integer, default=0)\n\n    usuario = relationship(\"User\", back_populates=\"verificacion_dos_pasos\")\n</code></pre>"},{"location":"user/models/#recuperacion-de-contrasena","title":"Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'recuperacion_contrasena' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico de la recuperaci\u00f3n.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>pin</code> <code>str</code> <p>PIN \u00fanico de recuperaci\u00f3n.</p> <code>expiracion</code> <code>datetime</code> <p>Fecha y hora de expiraci\u00f3n del PIN.</p> <code>intentos</code> <code>int</code> <p>N\u00famero de intentos de recuperaci\u00f3n.</p> <code>pin_confirmado</code> <code>bool</code> <p>Indica si el PIN ha sido confirmado.</p> <code>created_at</code> <code>datetime</code> <p>Fecha y hora de creaci\u00f3n del registro.</p> <code>resends</code> <code>int</code> <p>N\u00famero de reenv\u00edos del PIN.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado a la recuperaci\u00f3n.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class PasswordRecovery(Base):\n    \"\"\"\n    Representa la tabla 'recuperacion_contrasena' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico de la recuperaci\u00f3n.\n        usuario_id (int): Identificador del usuario asociado.\n        pin (str): PIN \u00fanico de recuperaci\u00f3n.\n        expiracion (datetime): Fecha y hora de expiraci\u00f3n del PIN.\n        intentos (int): N\u00famero de intentos de recuperaci\u00f3n.\n        pin_confirmado (bool): Indica si el PIN ha sido confirmado.\n        created_at (datetime): Fecha y hora de creaci\u00f3n del registro.\n        resends (int): N\u00famero de reenv\u00edos del PIN.\n        usuario (User): Usuario asociado a la recuperaci\u00f3n.\n    \"\"\"\n    __tablename__ = \"recuperacion_contrasena\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID, ondelete=\"CASCADE\"), nullable=False)\n    pin = Column(String(64), nullable=False, unique=True, index=True)\n    expiracion = Column(TIMESTAMP(timezone=True), nullable=False)\n    intentos = Column(Integer, default=0)\n    pin_confirmado = Column(Boolean, default=False, nullable=False)\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    resends = Column(Integer, default=0)\n\n    usuario = relationship(\"User\", back_populates=\"recuperacion_contrasena\")\n</code></pre>"},{"location":"user/models/#token-en-lista-negra","title":"Token en Lista Negra","text":"<p>               Bases: <code>Base</code></p> <p>Representa la tabla 'blacklisted_tokens' en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del token en lista negra.</p> <code>token</code> <code>str</code> <p>Token \u00fanico en lista negra.</p> <code>blacklisted_at</code> <code>datetime</code> <p>Fecha y hora en que el token fue a\u00f1adido a la lista negra.</p> <code>usuario_id</code> <code>int</code> <p>Identificador del usuario asociado.</p> <code>usuario</code> <code>User</code> <p>Usuario asociado al token en lista negra.</p> Source code in <code>app\\user\\infrastructure\\orm_models.py</code> <pre><code>class BlacklistedToken(Base):\n    \"\"\"\n    Representa la tabla 'blacklisted_tokens' en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del token en lista negra.\n        token (str): Token \u00fanico en lista negra.\n        blacklisted_at (datetime): Fecha y hora en que el token fue a\u00f1adido a la lista negra.\n        usuario_id (int): Identificador del usuario asociado.\n        usuario (User): Usuario asociado al token en lista negra.\n    \"\"\"\n    __tablename__ = \"blacklisted_tokens\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    token = Column(String(500), unique=True, nullable=False, index=True)\n    blacklisted_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=func.timezone('UTC', func.current_timestamp()))\n    usuario_id = Column(Integer, ForeignKey(USUARIO_ID), nullable=False)\n\n    usuario = relationship(\"User\", back_populates=\"blacklisted_tokens\")\n</code></pre>"},{"location":"user/overview/","title":"Visi\u00f3n General del M\u00f3dulo de Usuario","text":""},{"location":"user/overview/#introduccion","title":"Introducci\u00f3n","text":"<p>Bienvenido al m\u00f3dulo de usuario de AgroInsight. Esta secci\u00f3n proporciona una visi\u00f3n general de las funcionalidades y caracter\u00edsticas disponibles para los usuarios de nuestra plataforma agr\u00edcola inteligente.</p>"},{"location":"user/overview/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"user/overview/#1-gestion-de-perfil","title":"1. Gesti\u00f3n de Perfil","text":"<ul> <li>Creaci\u00f3n y edici\u00f3n de perfiles de usuario</li> <li>Configuraci\u00f3n de preferencias personales</li> <li>Gesti\u00f3n de informaci\u00f3n de contacto y notificaciones</li> </ul>"},{"location":"user/overview/#2-panel-de-control","title":"2. Panel de Control","text":"<ul> <li>Visualizaci\u00f3n de datos agr\u00edcolas en tiempo real</li> <li>Resumen de actividades recientes</li> <li>Acceso r\u00e1pido a herramientas y funciones clave</li> </ul>"},{"location":"user/overview/#3-gestion-de-parcelas","title":"3. Gesti\u00f3n de Parcelas","text":"<ul> <li>Registro y seguimiento de parcelas agr\u00edcolas</li> <li>Visualizaci\u00f3n de mapas interactivos</li> <li>Monitoreo de condiciones del suelo y cultivos</li> </ul>"},{"location":"user/overview/#4-planificacion-de-cultivos","title":"4. Planificaci\u00f3n de Cultivos","text":"<ul> <li>Calendario de siembra y cosecha</li> <li>Recomendaciones personalizadas basadas en datos</li> <li>Seguimiento del progreso de los cultivos</li> </ul>"},{"location":"user/overview/#5-analisis-y-reportes","title":"5. An\u00e1lisis y Reportes","text":"<ul> <li>Generaci\u00f3n de informes detallados</li> <li>An\u00e1lisis de rendimiento de cultivos</li> <li>Comparativas hist\u00f3ricas y proyecciones</li> </ul>"},{"location":"user/overview/#primeros-pasos","title":"Primeros Pasos","text":"<p>Para comenzar a utilizar el m\u00f3dulo de usuario de AgroInsight, siga estos pasos:</p> <ol> <li>Reg\u00edstrese o inicie sesi\u00f3n en su cuenta</li> <li>Complete su perfil de usuario</li> <li>Agregue su primera parcela</li> <li>Explore las diferentes funcionalidades del panel de control</li> </ol>"},{"location":"user/overview/#soporte-y-ayuda","title":"Soporte y Ayuda","text":"<p>Si necesita asistencia adicional, puede:</p> <ul> <li>Consultar nuestra secci\u00f3n de Preguntas Frecuentes</li> <li>Contactar a nuestro equipo de soporte</li> <li>Participar en nuestra comunidad de usuarios</li> </ul>"},{"location":"user/overview/#proximas-actualizaciones","title":"Pr\u00f3ximas Actualizaciones","text":"<p>Estamos constantemente mejorando AgroInsight. Mant\u00e9ngase atento a las pr\u00f3ximas actualizaciones que incluir\u00e1n:</p> <ul> <li>Integraci\u00f3n con dispositivos IoT para monitoreo en tiempo real</li> <li>M\u00f3dulo de gesti\u00f3n de recursos h\u00eddricos</li> <li>Herramientas avanzadas de predicci\u00f3n de cosechas</li> </ul> <p>\u00a1Gracias por elegir AgroInsight para optimizar sus operaciones agr\u00edcolas!</p>"},{"location":"user/repository/","title":"Documentaci\u00f3n del Repositorio de Usuarios","text":""},{"location":"user/repository/#vision-general","title":"Visi\u00f3n General","text":"<p>El m\u00f3dulo <code>UserRepository</code> proporciona una interfaz para interactuar con la base de datos en relaci\u00f3n con los usuarios y entidades relacionadas. Esta clase encapsula todas las operaciones de base de datos relacionadas con usuarios, incluyendo creaci\u00f3n, lectura, actualizaci\u00f3n y eliminaci\u00f3n (CRUD), as\u00ed como operaciones espec\u00edficas para la gesti\u00f3n de usuarios como confirmaciones, verificaci\u00f3n de dos pasos y recuperaci\u00f3n de contrase\u00f1as.</p>"},{"location":"user/repository/#clase-userrepository","title":"Clase: UserRepository","text":""},{"location":"user/repository/#constructor","title":"Constructor","text":"<p>Inicializa el repositorio de usuarios.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos SQLAlchemy.</p> required Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa el repositorio de usuarios.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos SQLAlchemy.\n    \"\"\"\n    self.db = db\n</code></pre>"},{"location":"user/repository/#metodos-de-usuario","title":"M\u00e9todos de Usuario","text":""},{"location":"user/repository/#obtener-usuario-por-email","title":"Obtener Usuario por Email","text":"<p>Obtiene un usuario por su direcci\u00f3n de correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_by_email(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario por su direcci\u00f3n de correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-usuario-por-id","title":"Obtener Usuario por ID","text":"<p>Obtiene un usuario por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>ID del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_by_id(self, user_id: int) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario por su ID.\n\n    Args:\n        user_id (int): ID del usuario.\n\n    Returns:\n        Optional[User]: El usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).get(user_id)\n</code></pre>"},{"location":"user/repository/#obtener-usuario-con-confirmacion","title":"Obtener Usuario con Confirmaci\u00f3n","text":"<p>Obtiene un usuario con su informaci\u00f3n de confirmaci\u00f3n por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario con informaci\u00f3n de confirmaci\u00f3n si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_with_confirmation(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario con su informaci\u00f3n de confirmaci\u00f3n por correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario con informaci\u00f3n de confirmaci\u00f3n si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.confirmacion)).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-usuario-con-verificacion-de-dos-pasos","title":"Obtener Usuario con Verificaci\u00f3n de Dos Pasos","text":"<p>Obtiene un usuario con su informaci\u00f3n de verificaci\u00f3n de dos pasos por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario con informaci\u00f3n de verificaci\u00f3n de dos pasos si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_with_two_factor_verification(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario con su informaci\u00f3n de verificaci\u00f3n de dos pasos por correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario con informaci\u00f3n de verificaci\u00f3n de dos pasos si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.verificacion_dos_pasos)).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-usuario-con-recuperacion-de-contrasena","title":"Obtener Usuario con Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Obtiene un usuario con su informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario con informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_user_with_password_recovery(self, email: str) -&gt; Optional[User]:\n    \"\"\"\n    Obtiene un usuario con su informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a por correo electr\u00f3nico.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n\n    Returns:\n        Optional[User]: El usuario con informaci\u00f3n de recuperaci\u00f3n de contrase\u00f1a si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.recuperacion_contrasena)).filter(User.email == email).first()\n</code></pre>"},{"location":"user/repository/#obtener-todos-los-usuarios","title":"Obtener Todos los Usuarios","text":"<p>Obtiene todos los usuarios con su informaci\u00f3n de estado.</p> <p>Returns:</p> Type Description <code>List[User]</code> <p>List[User]: Lista de todos los usuarios con su estado.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_all_users(self) -&gt; List[User]:\n    \"\"\"\n    Obtiene todos los usuarios con su informaci\u00f3n de estado.\n\n    Returns:\n        List[User]: Lista de todos los usuarios con su estado.\n    \"\"\"\n    return self.db.query(User).options(joinedload(User.estado)).all()\n</code></pre>"},{"location":"user/repository/#agregar-usuario","title":"Agregar Usuario","text":"<p>Agrega un nuevo usuario a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario a agregar.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario agregado si tiene \u00e9xito, None en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_user(self, user: User) -&gt; Optional[User]:\n    \"\"\"\n    Agrega un nuevo usuario a la base de datos.\n\n    Args:\n        user (User): Objeto de usuario a agregar.\n\n    Returns:\n        Optional[User]: El usuario agregado si tiene \u00e9xito, None en caso de error.\n    \"\"\"\n    try:\n        self.db.add(user)\n        self.db.commit()\n        self.db.refresh(user)\n        return user\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al crear el usuario: {e}\")\n        return None\n</code></pre>"},{"location":"user/repository/#actualizar-usuario","title":"Actualizar Usuario","text":"<p>Actualiza un usuario existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario con los datos actualizados.</p> required <p>Returns:</p> Type Description <code>Optional[User]</code> <p>Optional[User]: El usuario actualizado si tiene \u00e9xito, None en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_user(self, user: User) -&gt; Optional[User]:\n    \"\"\"\n    Actualiza un usuario existente en la base de datos.\n\n    Args:\n        user (User): Objeto de usuario con los datos actualizados.\n\n    Returns:\n        Optional[User]: El usuario actualizado si tiene \u00e9xito, None en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(user)\n        return user\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar el usuario: {e}\")\n        return None\n</code></pre>"},{"location":"user/repository/#eliminar-usuario","title":"Eliminar Usuario","text":"<p>Elimina un usuario de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_user(self, user: User) -&gt; bool:\n    \"\"\"\n    Elimina un usuario de la base de datos.\n\n    Args:\n        user (User): Objeto de usuario a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(user)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar el usuario: {str(e)}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-confirmacion-de-usuario","title":"M\u00e9todos de Confirmaci\u00f3n de Usuario","text":""},{"location":"user/repository/#agregar-confirmacion-de-usuario","title":"Agregar Confirmaci\u00f3n de Usuario","text":"<p>Agrega una confirmaci\u00f3n de usuario a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n de usuario a agregar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_user_confirmation(self, confirmation: UserConfirmation) -&gt; bool:\n    \"\"\"\n    Agrega una confirmaci\u00f3n de usuario a la base de datos.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n de usuario a agregar.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.add(confirmation)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al agregar la confirmaci\u00f3n del usuario: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#actualizar-confirmacion-de-usuario","title":"Actualizar Confirmaci\u00f3n de Usuario","text":"<p>Actualiza una confirmaci\u00f3n de usuario existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n de usuario con los datos actualizados.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se actualiz\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_user_confirmation(self, confirmation: UserConfirmation) -&gt; bool:\n    \"\"\"\n    Actualiza una confirmaci\u00f3n de usuario existente en la base de datos.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n de usuario con los datos actualizados.\n\n    Returns:\n        bool: True si se actualiz\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(confirmation)\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar la confirmaci\u00f3n del usuario: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#eliminar-confirmacion-de-usuario","title":"Eliminar Confirmaci\u00f3n de Usuario","text":"<p>Elimina una confirmaci\u00f3n de usuario de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n de usuario a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_user_confirmation(self, confirmation: UserConfirmation) -&gt; bool:\n    \"\"\"\n    Elimina una confirmaci\u00f3n de usuario de la base de datos.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n de usuario a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(confirmation)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar la confirmaci\u00f3n del usuario: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-verificacion-de-dos-pasos","title":"M\u00e9todos de Verificaci\u00f3n de Dos Pasos","text":""},{"location":"user/repository/#agregar-verificacion-de-dos-pasos","title":"Agregar Verificaci\u00f3n de Dos Pasos","text":"<p>Agrega una verificaci\u00f3n de dos pasos a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos pasos a agregar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_two_factor_verification(self, verification: TwoStepVerification) -&gt; bool:\n    \"\"\"\n    Agrega una verificaci\u00f3n de dos pasos a la base de datos.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos a agregar.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.add(verification)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al agregar la verificaci\u00f3n de dos pasos: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#actualizar-verificacion-de-dos-pasos","title":"Actualizar Verificaci\u00f3n de Dos Pasos","text":"<p>Actualiza una verificaci\u00f3n de dos pasos existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos pasos con los datos actualizados.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se actualiz\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_two_factor_verification(self, verification: TwoStepVerification) -&gt; bool:\n    \"\"\"\n    Actualiza una verificaci\u00f3n de dos pasos existente en la base de datos.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos con los datos actualizados.\n\n    Returns:\n        bool: True si se actualiz\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(verification)\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar la verificacion en dos pasos: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#eliminar-verificacion-de-dos-pasos","title":"Eliminar Verificaci\u00f3n de Dos Pasos","text":"<p>Elimina una verificaci\u00f3n de dos pasos de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos pasos a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_two_factor_verification(self, verification: TwoStepVerification) -&gt; bool:\n    \"\"\"\n    Elimina una verificaci\u00f3n de dos pasos de la base de datos.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(verification)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar la verificaci\u00f3n de dos pasos: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-recuperacion-de-contrasena","title":"M\u00e9todos de Recuperaci\u00f3n de Contrase\u00f1a","text":""},{"location":"user/repository/#agregar-recuperacion-de-contrasena","title":"Agregar Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Agrega una recuperaci\u00f3n de contrase\u00f1a a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a a agregar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def add_password_recovery(self, recovery: PasswordRecovery) -&gt; bool:\n    \"\"\"\n    Agrega una recuperaci\u00f3n de contrase\u00f1a a la base de datos.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a a agregar.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.add(recovery)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al agregar la recuperaci\u00f3n de contrase\u00f1a: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#actualizar-recuperacion-de-contrasena","title":"Actualizar Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Actualiza una recuperaci\u00f3n de contrase\u00f1a existente en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a con los datos actualizados.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se actualiz\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def update_password_recovery(self, recovery: PasswordRecovery) -&gt; bool:\n    \"\"\"\n    Actualiza una recuperaci\u00f3n de contrase\u00f1a existente en la base de datos.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a con los datos actualizados.\n\n    Returns:\n        bool: True si se actualiz\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.commit()\n        self.db.refresh(recovery)\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al actualizar la recuperaci\u00f3n de contrase\u00f1a: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#eliminar-recuperacion-de-contrasena","title":"Eliminar Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Elimina una recuperaci\u00f3n de contrase\u00f1a de la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a a eliminar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se elimin\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def delete_password_recovery(self, recovery: PasswordRecovery) -&gt; bool:\n    \"\"\"\n    Elimina una recuperaci\u00f3n de contrase\u00f1a de la base de datos.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a a eliminar.\n\n    Returns:\n        bool: True si se elimin\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.delete(recovery)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al eliminar la recuperaci\u00f3n: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#metodos-de-gestion-de-tokens","title":"M\u00e9todos de Gesti\u00f3n de Tokens","text":""},{"location":"user/repository/#agregar-token-a-lista-negra","title":"Agregar Token a Lista Negra","text":"<p>Agrega un token a la lista negra en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>blacklisted</code> <code>BlacklistedToken</code> <p>Objeto de token en lista negra a agregar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si se agreg\u00f3 con \u00e9xito, False en caso de error.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def blacklist_token(self, blacklisted: BlacklistedToken) -&gt; bool:\n    \"\"\"\n    Agrega un token a la lista negra en la base de datos.\n\n    Args:\n        blacklisted (BlacklistedToken): Objeto de token en lista negra a agregar.\n\n    Returns:\n        bool: True si se agreg\u00f3 con \u00e9xito, False en caso de error.\n    \"\"\"\n    try:\n        self.db.add(blacklisted)\n        self.db.commit()\n        return True\n    except Exception as e:\n        self.db.rollback()\n        print(f\"Error al blacklistear el token: {e}\")\n        return False\n</code></pre>"},{"location":"user/repository/#verificar-si-un-token-esta-en-lista-negra","title":"Verificar si un Token est\u00e1 en Lista Negra","text":"<p>Verifica si un token est\u00e1 en la lista negra.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token a verificar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el token est\u00e1 en la lista negra, False en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def is_token_blacklisted(self, token: str) -&gt; bool:\n    \"\"\"\n    Verifica si un token est\u00e1 en la lista negra.\n\n    Args:\n        token (str): Token a verificar.\n\n    Returns:\n        bool: True si el token est\u00e1 en la lista negra, False en caso contrario.\n    \"\"\"\n    return self.db.query(BlacklistedToken).filter(BlacklistedToken.token == token).first() is not None\n</code></pre>"},{"location":"user/repository/#metodos-de-estado-de-usuario","title":"M\u00e9todos de Estado de Usuario","text":""},{"location":"user/repository/#obtener-estado-por-id","title":"Obtener Estado por ID","text":"<p>Obtiene un estado de usuario por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>state_id</code> <code>int</code> <p>ID del estado de usuario.</p> required <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_state_by_id(self, state_id: int) -&gt; Optional[UserState]:\n    \"\"\"\n    Obtiene un estado de usuario por su ID.\n\n    Args:\n        state_id (int): ID del estado de usuario.\n\n    Returns:\n        Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(UserState).filter(UserState.id == state_id).first()\n</code></pre>"},{"location":"user/repository/#obtener-estado-por-nombre","title":"Obtener Estado por Nombre","text":"<p>Obtiene un estado de usuario por su nombre.</p> <p>Parameters:</p> Name Type Description Default <code>state_name</code> <code>str</code> <p>Nombre del estado de usuario.</p> required <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_state_by_name(self, state_name: str) -&gt; Optional[UserState]:\n    \"\"\"\n    Obtiene un estado de usuario por su nombre.\n\n    Args:\n        state_name (str): Nombre del estado de usuario.\n\n    Returns:\n        Optional[UserState]: El estado de usuario si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(UserState).filter(UserState.nombre == state_name).first()\n</code></pre>"},{"location":"user/repository/#metodos-de-rol","title":"M\u00e9todos de Rol","text":""},{"location":"user/repository/#obtener-rol-por-id","title":"Obtener Rol por ID","text":"<p>Obtiene un rol por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>int</code> <p>ID del rol.</p> required <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>Optional[Role]: El rol si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_role_by_id(self, role_id: int) -&gt; Optional[Role]:\n    \"\"\"\n    Obtiene un rol por su ID.\n\n    Args:\n        role_id (int): ID del rol.\n\n    Returns:\n        Optional[Role]: El rol si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(Role).filter(Role.id == role_id).first()\n</code></pre>"},{"location":"user/repository/#obtener-rol-por-nombre","title":"Obtener Rol por Nombre","text":"<p>Obtiene un rol por su nombre.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Nombre del rol.</p> required <p>Returns:</p> Type Description <code>Optional[Role]</code> <p>Optional[Role]: El rol si se encuentra, None en caso contrario.</p> Source code in <code>app\\user\\infrastructure\\sql_repository.py</code> <pre><code>def get_role_by_name(self, role_name: str) -&gt; Optional[Role]:\n    \"\"\"\n    Obtiene un rol por su nombre.\n\n    Args:\n        role_name (str): Nombre del rol.\n\n    Returns:\n        Optional[Role]: El rol si se encuentra, None en caso contrario.\n    \"\"\"\n    return self.db.query(Role).filter(Role.nombre == role_name).first()\n</code></pre>"},{"location":"user/repository/#constantes","title":"Constantes","text":"<p>El m\u00f3dulo define las siguientes constantes:</p> <ul> <li><code>ADMIN_ROLE_NAME</code>: Nombre del rol de administrador de finca.</li> <li><code>WORKER_ROLE_NAME</code>: Nombre del rol de trabajador agr\u00edcola.</li> <li><code>ACTIVE_STATE_NAME</code>: Nombre del estado activo de usuario.</li> <li><code>LOCKED_STATE_NAME</code>: Nombre del estado bloqueado de usuario.</li> <li><code>PENDING_STATE_NAME</code>: Nombre del estado pendiente de usuario.</li> <li><code>INACTIVE_STATE_NAME</code>: Nombre del estado inactivo de usuario.</li> </ul>"},{"location":"user/repository/#manejo-de-errores","title":"Manejo de Errores","text":"<p>Todos los m\u00e9todos que interact\u00faan con la base de datos est\u00e1n envueltos en bloques try-except para manejar posibles errores. En caso de error, se realiza un rollback de la transacci\u00f3n y se imprime un mensaje de error. Los m\u00e9todos que devuelven un valor booleano retornan <code>False</code> en caso de error, mientras que los m\u00e9todos que devuelven un objeto retornan <code>None</code>.</p>"},{"location":"user/repository/#mejores-practicas","title":"Mejores Pr\u00e1cticas","text":"<ol> <li>Uso de Sesiones: Siempre use la sesi\u00f3n de base de datos proporcionada al constructor para realizar operaciones de base de datos.</li> <li>Manejo de Transacciones: Use <code>self.db.commit()</code> para confirmar cambios y <code>self.db.rollback()</code> en caso de error.</li> <li>Logging: Considere reemplazar los <code>print</code> statements con un sistema de logging apropiado para un mejor seguimiento de errores en producci\u00f3n.</li> <li>Tipado: El uso de type hints mejora la legibilidad y permite un mejor an\u00e1lisis est\u00e1tico del c\u00f3digo.</li> <li>Documentaci\u00f3n: Mantenga los docstrings actualizados y detallados para facilitar el uso y mantenimiento del c\u00f3digo.</li> </ol>"},{"location":"user/schemas/","title":"Modelos de Usuario","text":"<p>Este documento describe los modelos Pydantic utilizados para la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/schemas/#esquemas-de-solicitud-y-respuesta","title":"Esquemas de Solicitud y Respuesta","text":""},{"location":"user/schemas/#crear-usuario","title":"Crear Usuario","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para crear un nuevo usuario.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserCreate(BaseModel):\n    \"\"\"\n    Esquema para crear un nuevo usuario.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        password (str): Contrase\u00f1a del usuario.\n    \"\"\"\n    email: str\n    nombre: str\n    apellido: str\n    password: str\n\n    _validate_email = field_validator('email')(validate_email)\n    _validate_password = field_validator('password')(validate_password)\n\n    @field_validator('nombre')\n    def validate_nombre(cls, v: str) -&gt; str:\n        \"\"\"\n        Valida que el nombre tenga al menos 2 caracteres.\n\n        Args:\n            v (str): El nombre a validar.\n\n        Returns:\n            str: El nombre validado.\n\n        Raises:\n            PydanticCustomError: Si el nombre tiene menos de 2 caracteres.\n        \"\"\"\n        if len(v) &lt; 2:\n            raise PydanticCustomError('nombre_validation','El nombre debe tener al menos 2 caracteres.')\n        return v\n\n    @field_validator('apellido')\n    def validate_apellido(cls, v: str) -&gt; str:\n        \"\"\"\n        Valida que el apellido tenga al menos 2 caracteres.\n\n        Args:\n            v (str): El apellido a validar.\n\n        Returns:\n            str: El apellido validado.\n\n        Raises:\n            PydanticCustomError: Si el apellido tiene menos de 2 caracteres.\n        \"\"\"\n        if len(v) &lt; 2:\n            raise PydanticCustomError('apellido_validation','El apellido debe tener al menos 2 caracteres.')\n        return v\n</code></pre>"},{"location":"user/schemas/#app.user.domain.schemas.UserCreate.validate_apellido","title":"<code>validate_apellido(v)</code>","text":"<p>Valida que el apellido tenga al menos 2 caracteres.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>El apellido a validar.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>El apellido validado.</p> <p>Raises:</p> Type Description <code>PydanticCustomError</code> <p>Si el apellido tiene menos de 2 caracteres.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>@field_validator('apellido')\ndef validate_apellido(cls, v: str) -&gt; str:\n    \"\"\"\n    Valida que el apellido tenga al menos 2 caracteres.\n\n    Args:\n        v (str): El apellido a validar.\n\n    Returns:\n        str: El apellido validado.\n\n    Raises:\n        PydanticCustomError: Si el apellido tiene menos de 2 caracteres.\n    \"\"\"\n    if len(v) &lt; 2:\n        raise PydanticCustomError('apellido_validation','El apellido debe tener al menos 2 caracteres.')\n    return v\n</code></pre>"},{"location":"user/schemas/#app.user.domain.schemas.UserCreate.validate_nombre","title":"<code>validate_nombre(v)</code>","text":"<p>Valida que el nombre tenga al menos 2 caracteres.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>El nombre a validar.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>El nombre validado.</p> <p>Raises:</p> Type Description <code>PydanticCustomError</code> <p>Si el nombre tiene menos de 2 caracteres.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>@field_validator('nombre')\ndef validate_nombre(cls, v: str) -&gt; str:\n    \"\"\"\n    Valida que el nombre tenga al menos 2 caracteres.\n\n    Args:\n        v (str): El nombre a validar.\n\n    Returns:\n        str: El nombre validado.\n\n    Raises:\n        PydanticCustomError: Si el nombre tiene menos de 2 caracteres.\n    \"\"\"\n    if len(v) &lt; 2:\n        raise PydanticCustomError('nombre_validation','El nombre debe tener al menos 2 caracteres.')\n    return v\n</code></pre>"},{"location":"user/schemas/#reenvio-de-pin-de-confirmacion","title":"Reenv\u00edo de PIN de Confirmaci\u00f3n","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para solicitar el reenv\u00edo del PIN de confirmaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class ResendPinConfirmRequest(BaseModel):\n    \"\"\"\n    Esquema para solicitar el reenv\u00edo del PIN de confirmaci\u00f3n.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n    \"\"\"\n    email: str\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#confirmacion-de-registro","title":"Confirmaci\u00f3n de Registro","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para confirmar el registro de un usuario mediante PIN.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n enviado al correo.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class ConfirmationRequest(BaseModel):\n    \"\"\"\n    Esquema para confirmar el registro de un usuario mediante PIN.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n enviado al correo.\n    \"\"\"\n    email: str\n    pin: str\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#inicio-de-sesion","title":"Inicio de Sesi\u00f3n","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para solicitar un inicio de sesi\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class LoginRequest(BaseModel):\n    \"\"\"\n    Esquema para solicitar un inicio de sesi\u00f3n.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n    \"\"\"\n    email: str\n    password: str\n\n    _validate_email = field_validator('email')(validate_email)\n    _validate_password = field_validator('password')(validate_password)\n</code></pre>"},{"location":"user/schemas/#reenvio-de-pin-de-autenticacion-de-dos-factores","title":"Reenv\u00edo de PIN de Autenticaci\u00f3n de Dos Factores","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para solicitar el reenv\u00edo del PIN de autenticaci\u00f3n de dos factores.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class Resend2FARequest(BaseModel):\n    \"\"\"\n    Esquema para solicitar el reenv\u00edo del PIN de autenticaci\u00f3n de dos factores.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n    \"\"\"\n    email: str\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#verificacion-de-inicio-de-sesion-con-dos-factores","title":"Verificaci\u00f3n de Inicio de Sesi\u00f3n con Dos Factores","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para verificar el inicio de sesi\u00f3n con autenticaci\u00f3n de dos factores.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>pin</code> <code>str</code> <p>PIN de autenticaci\u00f3n de dos factores.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class TwoFactorAuthRequest(BaseModel):\n    \"\"\"\n    Esquema para verificar el inicio de sesi\u00f3n con autenticaci\u00f3n de dos factores.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de autenticaci\u00f3n de dos factores.\n    \"\"\"\n    email: str\n    pin: str\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#respuesta-de-token","title":"Respuesta de Token","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para la respuesta que contiene el token de acceso.</p> <p>Attributes:</p> Name Type Description <code>access_token</code> <code>str</code> <p>Token de acceso JWT.</p> <code>token_type</code> <code>str</code> <p>Tipo de token, generalmente \"bearer\".</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class TokenResponse(BaseModel):\n    \"\"\"\n    Esquema para la respuesta que contiene el token de acceso.\n\n    Attributes:\n        access_token (str): Token de acceso JWT.\n        token_type (str): Tipo de token, generalmente \"bearer\".\n    \"\"\"\n    access_token: str\n    token_type: str\n</code></pre>"},{"location":"user/schemas/#respuesta-de-usuario","title":"Respuesta de Usuario","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para la respuesta que contiene informaci\u00f3n del usuario.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>email</code> <code>str</code> <p>Correo electr\u00f3nico \u00fanico del usuario.</p> <code>estado</code> <code>str</code> <p>Estado actual del usuario.</p> <code>roles_fincas</code> <code>List[RoleFarm]</code> <p>Lista de roles y fincas del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserResponse(BaseModel):\n    \"\"\"\n    Esquema para la respuesta que contiene informaci\u00f3n del usuario.\n\n    Attributes:\n        id (int): Identificador \u00fanico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        email (str): Correo electr\u00f3nico \u00fanico del usuario.\n        estado (str): Estado actual del usuario.\n        roles_fincas (List[RoleFarm]): Lista de roles y fincas del usuario.\n    \"\"\"\n    id: int\n    nombre: str\n    apellido: str\n    email: str\n    estado: str\n    roles_fincas: List[RoleFarm]  # Updated to include farm names\n\n    class Config:\n        from_attributes = True\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#actualizar-informacion-de-usuario","title":"Actualizar Informaci\u00f3n de Usuario","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para actualizar la informaci\u00f3n del usuario actual.</p> <p>Attributes:</p> Name Type Description <code>nombre</code> <code>str</code> <p>Nuevo nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Nuevo apellido del usuario.</p> <code>email</code> <code>str</code> <p>Nuevo correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserUpdate(BaseModel):\n    \"\"\"\n    Esquema para actualizar la informaci\u00f3n del usuario actual.\n\n    Attributes:\n        nombre (str): Nuevo nombre del usuario.\n        apellido (str): Nuevo apellido del usuario.\n        email (str): Nuevo correo electr\u00f3nico del usuario.\n    \"\"\"\n    nombre: str\n    apellido: str\n    email: str\n\n    class Config:\n        from_attributes = True\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#recuperacion-de-contrasena","title":"Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para iniciar el proceso de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class PasswordRecoveryRequest(BaseModel):\n    \"\"\"\n    Esquema para iniciar el proceso de recuperaci\u00f3n de contrase\u00f1a.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n    \"\"\"\n    email: str\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#confirmacion-de-pin-de-recuperacion","title":"Confirmaci\u00f3n de PIN de Recuperaci\u00f3n","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n enviado al correo.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class PinConfirmationRequest(BaseModel):\n    \"\"\"\n    Esquema para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de recuperaci\u00f3n enviado al correo.\n    \"\"\"\n    email: str\n    pin: str\n\n    _validate_email = field_validator('email')(validate_email)\n</code></pre>"},{"location":"user/schemas/#restablecer-contrasena","title":"Restablecer Contrase\u00f1a","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema para restablecer la contrase\u00f1a del usuario.</p> <p>Attributes:</p> Name Type Description <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> <code>new_password</code> <code>str</code> <p>Nueva contrase\u00f1a del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class PasswordResetRequest(BaseModel):\n    \"\"\"\n    Esquema para restablecer la contrase\u00f1a del usuario.\n\n    Attributes:\n        email (str): Correo electr\u00f3nico del usuario.\n        new_password (str): Nueva contrase\u00f1a del usuario.\n    \"\"\"\n    email: str\n    new_password: str\n\n    _validate_email = field_validator('email')(validate_email)\n    _validate_password = field_validator('new_password')(validate_password)\n</code></pre>"},{"location":"user/schemas/#usuario-en-la-base-de-datos","title":"Usuario en la Base de Datos","text":"<p>               Bases: <code>BaseModel</code></p> <p>Esquema que representa al usuario almacenado en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Identificador \u00fanico del usuario.</p> <code>nombre</code> <code>str</code> <p>Nombre del usuario.</p> <code>apellido</code> <code>str</code> <p>Apellido del usuario.</p> <code>email</code> <code>str</code> <p>Correo electr\u00f3nico \u00fanico del usuario.</p> <code>password</code> <code>str</code> <p>Contrase\u00f1a encriptada del usuario.</p> <code>failed_attempts</code> <code>int</code> <p>N\u00famero de intentos fallidos de inicio de sesi\u00f3n.</p> <code>locked_until</code> <code>datetime</code> <p>Fecha y hora hasta la que el usuario est\u00e1 bloqueado.</p> <code>state_id</code> <code>int</code> <p>Identificador del estado del usuario.</p> <code>roles_fincas</code> <code>List[RoleFarm]</code> <p>Lista de roles y fincas del usuario.</p> Source code in <code>app\\user\\domain\\schemas.py</code> <pre><code>class UserInDB(BaseModel):\n    \"\"\"\n    Esquema que representa al usuario almacenado en la base de datos.\n\n    Attributes:\n        id (int): Identificador \u00fanico del usuario.\n        nombre (str): Nombre del usuario.\n        apellido (str): Apellido del usuario.\n        email (str): Correo electr\u00f3nico \u00fanico del usuario.\n        password (str): Contrase\u00f1a encriptada del usuario.\n        failed_attempts (int): N\u00famero de intentos fallidos de inicio de sesi\u00f3n.\n        locked_until (datetime): Fecha y hora hasta la que el usuario est\u00e1 bloqueado.\n        state_id (int): Identificador del estado del usuario.\n        roles_fincas (List[RoleFarm]): Lista de roles y fincas del usuario.\n    \"\"\"\n    id: int\n    nombre: str\n    apellido: str\n    email: str\n    password: str\n    failed_attempts: int\n    locked_until: datetime\n    state_id: int\n    roles_fincas: List[RoleFarm]\n\n    class Config:\n        from_attributes = True\n\n    _validate_email = field_validator('email')(validate_email)\n    _validate_password = field_validator('password')(validate_password)\n</code></pre>"},{"location":"user/use_cases/","title":"Casos de Uso de Usuario","text":"<p>Este documento describe los casos de uso relacionados con la gesti\u00f3n de usuarios en el sistema AgroInsight.</p>"},{"location":"user/use_cases/#proceso-de-creacion-de-usuario","title":"Proceso de Creaci\u00f3n de Usuario","text":""},{"location":"user/use_cases/#caso-de-uso-creacion-de-usuario","title":"Caso de Uso: Creaci\u00f3n de Usuario","text":"<p>Caso de uso para la creaci\u00f3n de un nuevo usuario en el sistema.</p> <p>Esta clase maneja la l\u00f3gica de negocio para el registro de nuevos usuarios, incluyendo la validaci\u00f3n de datos, la creaci\u00f3n del usuario en la base de datos, y el env\u00edo de correos de confirmaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>class UserRegisterUseCase:\n    \"\"\"\n    Caso de uso para la creaci\u00f3n de un nuevo usuario en el sistema.\n\n    Esta clase maneja la l\u00f3gica de negocio para el registro de nuevos usuarios,\n    incluyendo la validaci\u00f3n de datos, la creaci\u00f3n del usuario en la base de datos,\n    y el env\u00edo de correos de confirmaci\u00f3n.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de UserRegisterUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def register_user(self, user_data: UserCreate, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Crea un nuevo usuario en el sistema.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Verifica si el usuario ya existe.\n        2. Verifica si la confirmaci\u00f3n del usuario ha expirado.\n        3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada.\n        4. Crea un nuevo usuario con estado pendiente.\n        5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.\n\n        Args:\n            user_data (UserCreate): Datos del usuario a crear.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n        Raises:\n            DomainException: Si ocurre un error durante el proceso de creaci\u00f3n.\n            UserStateException: Si el estado del usuario no es v\u00e1lido.\n        \"\"\"\n        user = self.user_repository.get_user_with_confirmation(user_data.email)\n\n        if user:\n            confirmations = self.get_last_confirmation(user.confirmacion)\n            expired_confirmation = confirmations if confirmations and self.is_confirmation_expired(confirmations) else None\n            if expired_confirmation:\n                self.user_repository.delete_user(user)\n            else:\n                state_validation_result = self.state_validator.validate_user_state(\n                    user,\n                    disallowed_states=[UserState.ACTIVE, UserState.PENDING, UserState.INACTIVE, UserState.LOCKED]\n                )\n                if state_validation_result:\n                    return state_validation_result\n\n        # Obtener estado \"pendiente\" del usuario (cach\u00e9 o consulta \u00fanica)\n        pending_state_id = self.get_pending_user_state().id\n        if not pending_state_id:\n            raise UserStateException(\n                message=\"No se pudo encontrar el estado de usuario pendiente.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n\n        # Hash del password\n        hashed_password = hash_password(user_data.password)\n\n        # Crear nuevo usuario\n        new_user = User(\n            nombre=user_data.nombre,\n            apellido=user_data.apellido,\n            email=user_data.email,\n            password=hashed_password,\n            state_id=pending_state_id\n        )\n        created_user = self.user_repository.add_user(new_user)\n\n        # Generar PIN y su hash\n        pin, pin_hash = generate_pin()\n\n        expiration_time = 10  # minutos\n        expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n        confirmation = UserConfirmation(\n            usuario_id=created_user.id,\n            pin=pin_hash,\n            expiracion=expiration_datetime,\n            resends=0,\n            created_at=datetime_utc_time()\n        )\n\n        if not self.user_repository.add_user_confirmation(confirmation):\n            raise DomainException(\n                message=\"Error al agregar la confirmaci\u00f3n del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        # Enviar correo de confirmaci\u00f3n de manera as\u00edncrona\n        background_tasks.add_task(self.send_confirmation_email, created_user.email, pin)\n\n        return SuccessResponse(\n                message=\"Usuario creado. Por favor, revisa tu email para confirmar el registro.\"\n            )\n\n    def send_confirmation_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n            pin (str): PIN de confirmaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n        \"\"\"\n        subject = \"Confirma tu registro en AgroInSight\"\n        text_content = f\"Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        return send_email_sendpulse(email, subject, text_content, html_content)\n\n    def is_confirmation_expired(self, confirmation: UserConfirmation) -&gt; bool:\n        \"\"\"\n        Verifica si la confirmaci\u00f3n del usuario ha expirado.\n\n        Args:\n            confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n\n        Returns:\n            bool: True si la confirmaci\u00f3n ha expirado, False en caso contrario.\n        \"\"\"\n        return confirmation.expiracion &lt; datetime_utc_time()\n\n    def get_last_confirmation(self, confirmation: UserConfirmation) -&gt; Optional[UserConfirmation]:\n        \"\"\"\n        Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.\n\n        Args:\n            confirmation (UserConfirmation): Lista de confirmaciones del usuario.\n\n        Returns:\n            Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.\n        \"\"\"\n        if isinstance(confirmation, list) and confirmation:\n            # Ordenar las confirmaciones por fecha de creaci\u00f3n de forma ascendente\n            confirmation.sort(key=lambda c: c.created_at)\n            # Tomar el \u00faltimo registro\n            latest_confirmation = confirmation[-1]\n            # Eliminar todas las confirmaciones anteriores a la \u00faltima\n            for old_confirmation in confirmation[:-1]:\n                self.user_repository.delete_user_confirmation(old_confirmation)\n            # Actualizar la variable confirmation para solo trabajar con la \u00faltima\n            return latest_confirmation\n        # Si no hay confirmaciones, retornar None\n        return None\n\n    def get_pending_user_state(self) -&gt; Optional[UserStateModel]:\n        \"\"\"\n        Obtiene el estado 'pendiente' del usuario.\n\n        Returns:\n            Optional[UserStateModel]: El estado 'pendiente' del usuario.\n\n        Raises:\n            UserStateException: Si no se puede encontrar el estado 'pendiente'.\n        \"\"\"\n        pending_state = self.user_repository.get_state_by_name(PENDING_STATE_NAME)\n        if not pending_state:\n            raise UserStateException(\n                message=\"No se pudo encontrar el estado de usuario pendiente.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n        return pending_state\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para el registro de nuevos usuarios, incluyendo la validaci\u00f3n de datos, la creaci\u00f3n del usuario en la base de datos, y el env\u00edo de correos de confirmaci\u00f3n.</p>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de UserRegisterUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de UserRegisterUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.get_last_confirmation","title":"<code>get_last_confirmation(confirmation)</code>","text":"<p>Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Lista de confirmaciones del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[UserConfirmation]</code> <p>Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def get_last_confirmation(self, confirmation: UserConfirmation) -&gt; Optional[UserConfirmation]:\n    \"\"\"\n    Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.\n\n    Args:\n        confirmation (UserConfirmation): Lista de confirmaciones del usuario.\n\n    Returns:\n        Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.\n    \"\"\"\n    if isinstance(confirmation, list) and confirmation:\n        # Ordenar las confirmaciones por fecha de creaci\u00f3n de forma ascendente\n        confirmation.sort(key=lambda c: c.created_at)\n        # Tomar el \u00faltimo registro\n        latest_confirmation = confirmation[-1]\n        # Eliminar todas las confirmaciones anteriores a la \u00faltima\n        for old_confirmation in confirmation[:-1]:\n            self.user_repository.delete_user_confirmation(old_confirmation)\n        # Actualizar la variable confirmation para solo trabajar con la \u00faltima\n        return latest_confirmation\n    # Si no hay confirmaciones, retornar None\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.get_pending_user_state","title":"<code>get_pending_user_state()</code>","text":"<p>Obtiene el estado 'pendiente' del usuario.</p> <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserStateModel]: El estado 'pendiente' del usuario.</p> <p>Raises:</p> Type Description <code>UserStateException</code> <p>Si no se puede encontrar el estado 'pendiente'.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def get_pending_user_state(self) -&gt; Optional[UserStateModel]:\n    \"\"\"\n    Obtiene el estado 'pendiente' del usuario.\n\n    Returns:\n        Optional[UserStateModel]: El estado 'pendiente' del usuario.\n\n    Raises:\n        UserStateException: Si no se puede encontrar el estado 'pendiente'.\n    \"\"\"\n    pending_state = self.user_repository.get_state_by_name(PENDING_STATE_NAME)\n    if not pending_state:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario pendiente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n    return pending_state\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.is_confirmation_expired","title":"<code>is_confirmation_expired(confirmation)</code>","text":"<p>Verifica si la confirmaci\u00f3n del usuario ha expirado.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n del usuario.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la confirmaci\u00f3n ha expirado, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def is_confirmation_expired(self, confirmation: UserConfirmation) -&gt; bool:\n    \"\"\"\n    Verifica si la confirmaci\u00f3n del usuario ha expirado.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n\n    Returns:\n        bool: True si la confirmaci\u00f3n ha expirado, False en caso contrario.\n    \"\"\"\n    return confirmation.expiracion &lt; datetime_utc_time()\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.register_user","title":"<code>register_user(user_data, background_tasks)</code>","text":"<p>Crea un nuevo usuario en el sistema.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario ya existe. 2. Verifica si la confirmaci\u00f3n del usuario ha expirado. 3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada. 4. Crea un nuevo usuario con estado pendiente. 5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>UserCreate</code> <p>Datos del usuario a crear.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre un error durante el proceso de creaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def register_user(self, user_data: UserCreate, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Crea un nuevo usuario en el sistema.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario ya existe.\n    2. Verifica si la confirmaci\u00f3n del usuario ha expirado.\n    3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada.\n    4. Crea un nuevo usuario con estado pendiente.\n    5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.\n\n    Args:\n        user_data (UserCreate): Datos del usuario a crear.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        DomainException: Si ocurre un error durante el proceso de creaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(user_data.email)\n\n    if user:\n        confirmations = self.get_last_confirmation(user.confirmacion)\n        expired_confirmation = confirmations if confirmations and self.is_confirmation_expired(confirmations) else None\n        if expired_confirmation:\n            self.user_repository.delete_user(user)\n        else:\n            state_validation_result = self.state_validator.validate_user_state(\n                user,\n                disallowed_states=[UserState.ACTIVE, UserState.PENDING, UserState.INACTIVE, UserState.LOCKED]\n            )\n            if state_validation_result:\n                return state_validation_result\n\n    # Obtener estado \"pendiente\" del usuario (cach\u00e9 o consulta \u00fanica)\n    pending_state_id = self.get_pending_user_state().id\n    if not pending_state_id:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario pendiente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    # Hash del password\n    hashed_password = hash_password(user_data.password)\n\n    # Crear nuevo usuario\n    new_user = User(\n        nombre=user_data.nombre,\n        apellido=user_data.apellido,\n        email=user_data.email,\n        password=hashed_password,\n        state_id=pending_state_id\n    )\n    created_user = self.user_repository.add_user(new_user)\n\n    # Generar PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    confirmation = UserConfirmation(\n        usuario_id=created_user.id,\n        pin=pin_hash,\n        expiracion=expiration_datetime,\n        resends=0,\n        created_at=datetime_utc_time()\n    )\n\n    if not self.user_repository.add_user_confirmation(confirmation):\n        raise DomainException(\n            message=\"Error al agregar la confirmaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar correo de confirmaci\u00f3n de manera as\u00edncrona\n    background_tasks.add_task(self.send_confirmation_email, created_user.email, pin)\n\n    return SuccessResponse(\n            message=\"Usuario creado. Por favor, revisa tu email para confirmar el registro.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.user_register_use_case.UserRegisterUseCase.send_confirmation_email","title":"<code>send_confirmation_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def send_confirmation_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"Confirma tu registro en AgroInSight\"\n    text_content = f\"Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return send_email_sendpulse(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-creacion-de-usuario","title":"M\u00e9todos Principales de creaci\u00f3n de usuario","text":""},{"location":"user/use_cases/#register_user","title":"register_user","text":"<p>Crea un nuevo usuario en el sistema.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario ya existe. 2. Verifica si la confirmaci\u00f3n del usuario ha expirado. 3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada. 4. Crea un nuevo usuario con estado pendiente. 5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>user_data</code> <code>UserCreate</code> <p>Datos del usuario a crear.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre un error durante el proceso de creaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def register_user(self, user_data: UserCreate, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Crea un nuevo usuario en el sistema.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario ya existe.\n    2. Verifica si la confirmaci\u00f3n del usuario ha expirado.\n    3. Valida el estado del usuario si no tiene confirmaci\u00f3n expirada.\n    4. Crea un nuevo usuario con estado pendiente.\n    5. Crea y env\u00eda una confirmaci\u00f3n por correo electr\u00f3nico.\n\n    Args:\n        user_data (UserCreate): Datos del usuario a crear.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        DomainException: Si ocurre un error durante el proceso de creaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(user_data.email)\n\n    if user:\n        confirmations = self.get_last_confirmation(user.confirmacion)\n        expired_confirmation = confirmations if confirmations and self.is_confirmation_expired(confirmations) else None\n        if expired_confirmation:\n            self.user_repository.delete_user(user)\n        else:\n            state_validation_result = self.state_validator.validate_user_state(\n                user,\n                disallowed_states=[UserState.ACTIVE, UserState.PENDING, UserState.INACTIVE, UserState.LOCKED]\n            )\n            if state_validation_result:\n                return state_validation_result\n\n    # Obtener estado \"pendiente\" del usuario (cach\u00e9 o consulta \u00fanica)\n    pending_state_id = self.get_pending_user_state().id\n    if not pending_state_id:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario pendiente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    # Hash del password\n    hashed_password = hash_password(user_data.password)\n\n    # Crear nuevo usuario\n    new_user = User(\n        nombre=user_data.nombre,\n        apellido=user_data.apellido,\n        email=user_data.email,\n        password=hashed_password,\n        state_id=pending_state_id\n    )\n    created_user = self.user_repository.add_user(new_user)\n\n    # Generar PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    confirmation = UserConfirmation(\n        usuario_id=created_user.id,\n        pin=pin_hash,\n        expiracion=expiration_datetime,\n        resends=0,\n        created_at=datetime_utc_time()\n    )\n\n    if not self.user_repository.add_user_confirmation(confirmation):\n        raise DomainException(\n            message=\"Error al agregar la confirmaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar correo de confirmaci\u00f3n de manera as\u00edncrona\n    background_tasks.add_task(self.send_confirmation_email, created_user.email, pin)\n\n    return SuccessResponse(\n            message=\"Usuario creado. Por favor, revisa tu email para confirmar el registro.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#send_confirmation_email","title":"send_confirmation_email","text":"<p>Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\user_register_use_case.py</code> <pre><code>def send_confirmation_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico de confirmaci\u00f3n al usuario.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"Confirma tu registro en AgroInSight\"\n    text_content = f\"Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return send_email_sendpulse(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-confirmacion-de-usuario","title":"Caso de Uso: Confirmaci\u00f3n de Usuario","text":"<p>Caso de uso para la confirmaci\u00f3n del registro de un usuario en el sistema.</p> <p>Esta clase maneja la l\u00f3gica de negocio para confirmar el registro de usuarios, incluyendo la validaci\u00f3n del PIN, la activaci\u00f3n del usuario y la gesti\u00f3n de intentos fallidos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>class ConfirmationUseCase:\n    \"\"\"\n    Caso de uso para la confirmaci\u00f3n del registro de un usuario en el sistema.\n\n    Esta clase maneja la l\u00f3gica de negocio para confirmar el registro de usuarios,\n    incluyendo la validaci\u00f3n del PIN, la activaci\u00f3n del usuario y la gesti\u00f3n de intentos fallidos.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ConfirmationUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def confirm_user(self, email: str, pin: str) -&gt; SuccessResponse:\n        \"\"\"\n        Confirma el registro de un usuario mediante un PIN.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Obtiene el usuario por correo electr\u00f3nico.\n        2. Valida el estado del usuario.\n        3. Verifica la existencia de una confirmaci\u00f3n pendiente.\n        4. Comprueba si la confirmaci\u00f3n ha expirado.\n        5. Verifica el PIN proporcionado.\n        6. Activa el usuario si el PIN es correcto.\n        7. Elimina el registro de confirmaci\u00f3n.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            pin (str): PIN de confirmaci\u00f3n proporcionado por el usuario.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si ocurre un error durante el proceso de confirmaci\u00f3n.\n            UserStateException: Si el estado del usuario no es v\u00e1lido.\n        \"\"\"\n        # Obtener el usuario por correo electr\u00f3nico\n        user = self.user_repository.get_user_with_confirmation(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        # Validar el estado del usuario\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.PENDING],\n            disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        # Verificar si hay una confirmaci\u00f3n pendiente\n        confirmation = self.get_last_confirmation(user.confirmacion)\n        if not confirmation:\n            raise DomainException(\n                message=\"No hay un registro de confirmaci\u00f3n para este usuario.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Verificar si la confirmaci\u00f3n est\u00e1 expirada\n        if self.is_confirmation_expired(confirmation):\n            # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n            self.user_repository.delete_user(user)\n            raise DomainException(\n                message=\"La confirmaci\u00f3n ha expirado. Por favor, inicie el proceso de registro nuevamente.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        # Hashear el PIN proporcionado\n        pin_hash = hash_pin(pin)\n\n        # Obtener el registro de confirmaci\u00f3n\n        confirm_pin = confirmation.pin == pin_hash\n\n        if not confirm_pin:\n            # Manejar intentos fallidos de confirmaci\u00f3n\n            intentos = self.increment_confirmation_attempts(confirmation)\n            if intentos &gt;= 3:\n                # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n                self.user_repository.delete_user(user)\n                raise DomainException(\n                    message=\"Demasiados intentos. Por favor, inicie el proceso de registro nuevamente.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n            raise DomainException(\n                message=\"PIN de confirmaci\u00f3n incorrecto.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n\n        self.activate_user(user)\n\n        # Eliminar el registro de confirmaci\u00f3n\n        self.user_repository.delete_user_confirmation(confirmation)\n\n        return SuccessResponse(\n                message=\"Usuario confirmado exitosamente.\"\n            )\n\n    def is_confirmation_expired(self, confirmation: UserConfirmation) -&gt; bool:\n        \"\"\"\n        Verifica si la confirmaci\u00f3n ha expirado.\n\n        Args:\n            confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n\n        Returns:\n            bool: True si la confirmaci\u00f3n ha expirado, False en caso contrario.\n        \"\"\"\n        return confirmation.expiracion &lt; datetime_utc_time()\n\n    def increment_confirmation_attempts(self, confirmation: UserConfirmation) -&gt; int:\n        \"\"\"\n        Incrementa los intentos de confirmaci\u00f3n.\n\n        Args:\n            confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n\n        Returns:\n            int: El n\u00famero actualizado de intentos de confirmaci\u00f3n.\n        \"\"\"\n        confirmation.intentos += 1\n        self.user_repository.update_user_confirmation(confirmation)\n        return confirmation.intentos\n\n    def activate_user(self, user: User) -&gt; None:\n        \"\"\"\n        Activa el usuario cambiando su estado a activo.\n\n        Args:\n            user (User): Objeto de usuario a activar.\n\n        Raises:\n            UserStateException: Si no se puede encontrar el estado de usuario activo.\n        \"\"\"\n        active_state = self.get_active_user_state()\n        if not active_state:\n            raise UserStateException(\n                message=\"No se pudo encontrar el estado de usuario activo.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n        user.state_id = active_state.id\n        self.user_repository.update_user(user)\n\n    def get_last_confirmation(self, confirmation: UserConfirmation) -&gt; Optional[UserConfirmation]:\n        \"\"\"\n        Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.\n\n        Args:\n            confirmation (UserConfirmation): Lista de confirmaciones del usuario.\n\n        Returns:\n            Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.\n        \"\"\"\n        if isinstance(confirmation, list) and confirmation:\n            confirmation.sort(key=lambda c: c.created_at)\n            latest_confirmation = confirmation[-1]\n            for old_confirmation in confirmation[:-1]:\n                self.user_repository.delete_user_confirmation(old_confirmation)\n            return latest_confirmation\n        return None\n\n    def get_active_user_state(self) -&gt; Optional[UserStateModel]:\n        \"\"\"\n        Obtiene el estado activo del usuario.\n\n        Returns:\n            Optional[UserStateModel]: El estado activo del usuario.\n\n        Raises:\n            UserStateException: Si no se puede encontrar el estado de usuario activo.\n        \"\"\"\n        active_state = self.user_repository.get_state_by_name(ACTIVE_STATE_NAME)\n        if not active_state:\n            raise UserStateException(\n                message=\"No se pudo encontrar el estado de usuario activo.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n        return active_state\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para confirmar el registro de usuarios mediante un PIN, incluyendo la validaci\u00f3n del PIN, la activaci\u00f3n del usuario y la gesti\u00f3n de intentos fallidos.</p>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ConfirmationUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ConfirmationUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.activate_user","title":"<code>activate_user(user)</code>","text":"<p>Activa el usuario cambiando su estado a activo.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario a activar.</p> required <p>Raises:</p> Type Description <code>UserStateException</code> <p>Si no se puede encontrar el estado de usuario activo.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def activate_user(self, user: User) -&gt; None:\n    \"\"\"\n    Activa el usuario cambiando su estado a activo.\n\n    Args:\n        user (User): Objeto de usuario a activar.\n\n    Raises:\n        UserStateException: Si no se puede encontrar el estado de usuario activo.\n    \"\"\"\n    active_state = self.get_active_user_state()\n    if not active_state:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario activo.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n    user.state_id = active_state.id\n    self.user_repository.update_user(user)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.confirm_user","title":"<code>confirm_user(email, pin)</code>","text":"<p>Confirma el registro de un usuario mediante un PIN.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Obtiene el usuario por correo electr\u00f3nico. 2. Valida el estado del usuario. 3. Verifica la existencia de una confirmaci\u00f3n pendiente. 4. Comprueba si la confirmaci\u00f3n ha expirado. 5. Verifica el PIN proporcionado. 6. Activa el usuario si el PIN es correcto. 7. Elimina el registro de confirmaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de confirmaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def confirm_user(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el registro de un usuario mediante un PIN.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Obtiene el usuario por correo electr\u00f3nico.\n    2. Valida el estado del usuario.\n    3. Verifica la existencia de una confirmaci\u00f3n pendiente.\n    4. Comprueba si la confirmaci\u00f3n ha expirado.\n    5. Verifica el PIN proporcionado.\n    6. Activa el usuario si el PIN es correcto.\n    7. Elimina el registro de confirmaci\u00f3n.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de confirmaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    # Obtener el usuario por correo electr\u00f3nico\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    confirmation = self.get_last_confirmation(user.confirmacion)\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay un registro de confirmaci\u00f3n para este usuario.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si la confirmaci\u00f3n est\u00e1 expirada\n    if self.is_confirmation_expired(confirmation):\n        # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n        self.user_repository.delete_user(user)\n        raise DomainException(\n            message=\"La confirmaci\u00f3n ha expirado. Por favor, inicie el proceso de registro nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Hashear el PIN proporcionado\n    pin_hash = hash_pin(pin)\n\n    # Obtener el registro de confirmaci\u00f3n\n    confirm_pin = confirmation.pin == pin_hash\n\n    if not confirm_pin:\n        # Manejar intentos fallidos de confirmaci\u00f3n\n        intentos = self.increment_confirmation_attempts(confirmation)\n        if intentos &gt;= 3:\n            # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n            self.user_repository.delete_user(user)\n            raise DomainException(\n                message=\"Demasiados intentos. Por favor, inicie el proceso de registro nuevamente.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n        raise DomainException(\n            message=\"PIN de confirmaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n\n    self.activate_user(user)\n\n    # Eliminar el registro de confirmaci\u00f3n\n    self.user_repository.delete_user_confirmation(confirmation)\n\n    return SuccessResponse(\n            message=\"Usuario confirmado exitosamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.get_active_user_state","title":"<code>get_active_user_state()</code>","text":"<p>Obtiene el estado activo del usuario.</p> <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserStateModel]: El estado activo del usuario.</p> <p>Raises:</p> Type Description <code>UserStateException</code> <p>Si no se puede encontrar el estado de usuario activo.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def get_active_user_state(self) -&gt; Optional[UserStateModel]:\n    \"\"\"\n    Obtiene el estado activo del usuario.\n\n    Returns:\n        Optional[UserStateModel]: El estado activo del usuario.\n\n    Raises:\n        UserStateException: Si no se puede encontrar el estado de usuario activo.\n    \"\"\"\n    active_state = self.user_repository.get_state_by_name(ACTIVE_STATE_NAME)\n    if not active_state:\n        raise UserStateException(\n            message=\"No se pudo encontrar el estado de usuario activo.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n    return active_state\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.get_last_confirmation","title":"<code>get_last_confirmation(confirmation)</code>","text":"<p>Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Lista de confirmaciones del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[UserConfirmation]</code> <p>Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def get_last_confirmation(self, confirmation: UserConfirmation) -&gt; Optional[UserConfirmation]:\n    \"\"\"\n    Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.\n\n    Args:\n        confirmation (UserConfirmation): Lista de confirmaciones del usuario.\n\n    Returns:\n        Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.\n    \"\"\"\n    if isinstance(confirmation, list) and confirmation:\n        confirmation.sort(key=lambda c: c.created_at)\n        latest_confirmation = confirmation[-1]\n        for old_confirmation in confirmation[:-1]:\n            self.user_repository.delete_user_confirmation(old_confirmation)\n        return latest_confirmation\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.increment_confirmation_attempts","title":"<code>increment_confirmation_attempts(confirmation)</code>","text":"<p>Incrementa los intentos de confirmaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n del usuario.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>El n\u00famero actualizado de intentos de confirmaci\u00f3n.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def increment_confirmation_attempts(self, confirmation: UserConfirmation) -&gt; int:\n    \"\"\"\n    Incrementa los intentos de confirmaci\u00f3n.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n\n    Returns:\n        int: El n\u00famero actualizado de intentos de confirmaci\u00f3n.\n    \"\"\"\n    confirmation.intentos += 1\n    self.user_repository.update_user_confirmation(confirmation)\n    return confirmation.intentos\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.confirmation_use_case.ConfirmationUseCase.is_confirmation_expired","title":"<code>is_confirmation_expired(confirmation)</code>","text":"<p>Verifica si la confirmaci\u00f3n ha expirado.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n del usuario.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la confirmaci\u00f3n ha expirado, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def is_confirmation_expired(self, confirmation: UserConfirmation) -&gt; bool:\n    \"\"\"\n    Verifica si la confirmaci\u00f3n ha expirado.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n\n    Returns:\n        bool: True si la confirmaci\u00f3n ha expirado, False en caso contrario.\n    \"\"\"\n    return confirmation.expiracion &lt; datetime_utc_time()\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-confirmacion-de-usuario","title":"M\u00e9todos Principales de confirmaci\u00f3n de usuario","text":""},{"location":"user/use_cases/#confirm_user","title":"confirm_user","text":"<p>Confirma el registro de un usuario mediante un PIN.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Obtiene el usuario por correo electr\u00f3nico. 2. Valida el estado del usuario. 3. Verifica la existencia de una confirmaci\u00f3n pendiente. 4. Comprueba si la confirmaci\u00f3n ha expirado. 5. Verifica el PIN proporcionado. 6. Activa el usuario si el PIN es correcto. 7. Elimina el registro de confirmaci\u00f3n.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de confirmaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de confirmaci\u00f3n.</p> <code>UserStateException</code> <p>Si el estado del usuario no es v\u00e1lido.</p> Source code in <code>app\\user\\application\\user_register_process\\confirmation_use_case.py</code> <pre><code>def confirm_user(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el registro de un usuario mediante un PIN.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Obtiene el usuario por correo electr\u00f3nico.\n    2. Valida el estado del usuario.\n    3. Verifica la existencia de una confirmaci\u00f3n pendiente.\n    4. Comprueba si la confirmaci\u00f3n ha expirado.\n    5. Verifica el PIN proporcionado.\n    6. Activa el usuario si el PIN es correcto.\n    7. Elimina el registro de confirmaci\u00f3n.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de confirmaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de confirmaci\u00f3n.\n        UserStateException: Si el estado del usuario no es v\u00e1lido.\n    \"\"\"\n    # Obtener el usuario por correo electr\u00f3nico\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    confirmation = self.get_last_confirmation(user.confirmacion)\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay un registro de confirmaci\u00f3n para este usuario.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Verificar si la confirmaci\u00f3n est\u00e1 expirada\n    if self.is_confirmation_expired(confirmation):\n        # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n        self.user_repository.delete_user(user)\n        raise DomainException(\n            message=\"La confirmaci\u00f3n ha expirado. Por favor, inicie el proceso de registro nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    # Hashear el PIN proporcionado\n    pin_hash = hash_pin(pin)\n\n    # Obtener el registro de confirmaci\u00f3n\n    confirm_pin = confirmation.pin == pin_hash\n\n    if not confirm_pin:\n        # Manejar intentos fallidos de confirmaci\u00f3n\n        intentos = self.increment_confirmation_attempts(confirmation)\n        if intentos &gt;= 3:\n            # Eliminar usuario y con el se elimina su confirmaci\u00f3n\n            self.user_repository.delete_user(user)\n            raise DomainException(\n                message=\"Demasiados intentos. Por favor, inicie el proceso de registro nuevamente.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n        raise DomainException(\n            message=\"PIN de confirmaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n\n    self.activate_user(user)\n\n    # Eliminar el registro de confirmaci\u00f3n\n    self.user_repository.delete_user_confirmation(confirmation)\n\n    return SuccessResponse(\n            message=\"Usuario confirmado exitosamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-reenvio-de-confirmacion","title":"Caso de Uso: Reenv\u00edo de Confirmaci\u00f3n","text":"<p>Caso de uso para reenviar la confirmaci\u00f3n de registro a un usuario.</p> <p>Esta clase maneja la l\u00f3gica de negocio para reenviar PINs de confirmaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la generaci\u00f3n de nuevos PINs, y el env\u00edo de correos electr\u00f3nicos de confirmaci\u00f3n.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>class ResendConfirmationUseCase:\n    \"\"\"\n    Caso de uso para reenviar la confirmaci\u00f3n de registro a un usuario.\n\n    Esta clase maneja la l\u00f3gica de negocio para reenviar PINs de confirmaci\u00f3n,\n    incluyendo la validaci\u00f3n del estado del usuario, la generaci\u00f3n de nuevos PINs,\n    y el env\u00edo de correos electr\u00f3nicos de confirmaci\u00f3n.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ResendConfirmationUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def resend_confirmation(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Verifica si el usuario existe.\n        2. Valida el estado del usuario.\n        3. Obtiene la \u00faltima confirmaci\u00f3n del usuario.\n        4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera).\n        5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n.\n        6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si ocurre un error durante el proceso de reenv\u00edo.\n        \"\"\"\n        user = self.user_repository.get_user_with_confirmation(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        # Validar el estado del usuario\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.PENDING],\n            disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        # Obtener confirmaci\u00f3n del usuario\n        confirmation = self.get_last_confirmation(user.confirmacion)\n\n        # Verificar si hay una confirmaci\u00f3n pendiente\n        if not confirmation:\n            raise DomainException(\n                message=\"No hay una confirmaci\u00f3n pendiente para reenviar el PIN.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        # Definimos el tiempo de espera en minutos\n        warning_time = 3\n\n        # Si es el primer reenv\u00edo (resends == 0), permitir sin restricci\u00f3n\n        if confirmation.resends &gt; 0:\n            # Si ya ha reenviado al menos una vez, verificar si han pasado 3 minutos\n            if self.was_recently_requested(confirmation, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n        # Generar nuevo PIN y su hash\n        pin, pin_hash = generate_pin()\n\n        expiration_time = 10  # minutos\n        expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n        # Actualizar el registro de confirmaci\u00f3n de usuario con manejo de errores\n        confirmation.pin = pin_hash\n        confirmation.expiracion = expiration_datetime\n        confirmation.resends += 1\n        confirmation.intentos = 0\n        confirmation.created_at = datetime_utc_time()\n\n        if not self.user_repository.update_user_confirmation(confirmation):\n            # Log the error or handle it as needed\n            raise DomainException(\n                message=\"Error al actualizar la confirmaci\u00f3n del usuario\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        # Enviar el correo electr\u00f3nico con el nuevo PIN\n        background_tasks.add_task(self.resend_confirmation_email, email, pin)\n\n        return SuccessResponse(\n            message=\"PIN de confirmaci\u00f3n reenviado con \u00e9xito.\"\n        )\n\n    def resend_confirmation_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de confirmaci\u00f3n reenviado.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n            pin (str): Nuevo PIN de confirmaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n        \"\"\"\n        subject = \"Confirma tu registro en AgroInSight\"\n        text_content = f\"Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n        return send_email(email, subject, text_content, html_content)\n\n    def was_recently_requested(self, confirmation: UserConfirmation, minutes: int = 3) -&gt; bool:\n        \"\"\"\n        Verifica si la confirmaci\u00f3n se solicit\u00f3 recientemente.\n\n        Args:\n            confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n            minutes (int, optional): N\u00famero de minutos para considerar como reciente. Por defecto es 3.\n\n        Returns:\n            bool: True si la confirmaci\u00f3n se solicit\u00f3 hace menos de los minutos especificados, False en caso contrario.\n        \"\"\"\n        return (datetime_utc_time() - ensure_utc(confirmation.created_at)).total_seconds() &lt; minutes * 60\n\n    def get_last_confirmation(self, confirmation: UserConfirmation) -&gt; Optional[UserConfirmation]:\n        \"\"\"\n        Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.\n\n        Args:\n            confirmation (UserConfirmation): Lista de confirmaciones del usuario.\n\n        Returns:\n            Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.\n        \"\"\"\n        if isinstance(confirmation, list) and confirmation:\n            # Ordenar las confirmaciones por fecha de creaci\u00f3n de forma ascendente\n            confirmation.sort(key=lambda c: c.created_at)\n            # Tomar el \u00faltimo registro\n            latest_confirmation = confirmation[-1]\n            # Eliminar todas las confirmaciones anteriores a la \u00faltima\n            for old_confirmation in confirmation[:-1]:\n                self.user_repository.delete_user_confirmation(old_confirmation)\n            # Actualizar la variable confirmation para solo trabajar con la \u00faltima\n            return latest_confirmation\n        # Si no hay confirmaciones, retornar None\n        return None\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para reenviar PINs de confirmaci\u00f3n a usuarios que est\u00e1n en proceso de registro.</p>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ResendConfirmationUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ResendConfirmationUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.get_last_confirmation","title":"<code>get_last_confirmation(confirmation)</code>","text":"<p>Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Lista de confirmaciones del usuario.</p> required <p>Returns:</p> Type Description <code>Optional[UserConfirmation]</code> <p>Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def get_last_confirmation(self, confirmation: UserConfirmation) -&gt; Optional[UserConfirmation]:\n    \"\"\"\n    Obtiene la \u00faltima confirmaci\u00f3n del usuario y elimina las anteriores.\n\n    Args:\n        confirmation (UserConfirmation): Lista de confirmaciones del usuario.\n\n    Returns:\n        Optional[UserConfirmation]: La \u00faltima confirmaci\u00f3n del usuario o None si no hay confirmaciones.\n    \"\"\"\n    if isinstance(confirmation, list) and confirmation:\n        # Ordenar las confirmaciones por fecha de creaci\u00f3n de forma ascendente\n        confirmation.sort(key=lambda c: c.created_at)\n        # Tomar el \u00faltimo registro\n        latest_confirmation = confirmation[-1]\n        # Eliminar todas las confirmaciones anteriores a la \u00faltima\n        for old_confirmation in confirmation[:-1]:\n            self.user_repository.delete_user_confirmation(old_confirmation)\n        # Actualizar la variable confirmation para solo trabajar con la \u00faltima\n        return latest_confirmation\n    # Si no hay confirmaciones, retornar None\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.resend_confirmation","title":"<code>resend_confirmation(email, background_tasks)</code>","text":"<p>Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario existe. 2. Valida el estado del usuario. 3. Obtiene la \u00faltima confirmaci\u00f3n del usuario. 4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera). 5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n. 6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de reenv\u00edo.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def resend_confirmation(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario existe.\n    2. Valida el estado del usuario.\n    3. Obtiene la \u00faltima confirmaci\u00f3n del usuario.\n    4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera).\n    5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n.\n    6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de reenv\u00edo.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Obtener confirmaci\u00f3n del usuario\n    confirmation = self.get_last_confirmation(user.confirmacion)\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay una confirmaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Definimos el tiempo de espera en minutos\n    warning_time = 3\n\n    # Si es el primer reenv\u00edo (resends == 0), permitir sin restricci\u00f3n\n    if confirmation.resends &gt; 0:\n        # Si ya ha reenviado al menos una vez, verificar si han pasado 3 minutos\n        if self.was_recently_requested(confirmation, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    # Generar nuevo PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    # Actualizar el registro de confirmaci\u00f3n de usuario con manejo de errores\n    confirmation.pin = pin_hash\n    confirmation.expiracion = expiration_datetime\n    confirmation.resends += 1\n    confirmation.intentos = 0\n    confirmation.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_user_confirmation(confirmation):\n        # Log the error or handle it as needed\n        raise DomainException(\n            message=\"Error al actualizar la confirmaci\u00f3n del usuario\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar el correo electr\u00f3nico con el nuevo PIN\n    background_tasks.add_task(self.resend_confirmation_email, email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de confirmaci\u00f3n reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.resend_confirmation_email","title":"<code>resend_confirmation_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de confirmaci\u00f3n reenviado.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>Nuevo PIN de confirmaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def resend_confirmation_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de confirmaci\u00f3n reenviado.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): Nuevo PIN de confirmaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"Confirma tu registro en AgroInSight\"\n    text_content = f\"Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de confirmaci\u00f3n es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.user_register_process.resend_confirmation_use_case.ResendConfirmationUseCase.was_recently_requested","title":"<code>was_recently_requested(confirmation, minutes=3)</code>","text":"<p>Verifica si la confirmaci\u00f3n se solicit\u00f3 recientemente.</p> <p>Parameters:</p> Name Type Description Default <code>confirmation</code> <code>UserConfirmation</code> <p>Objeto de confirmaci\u00f3n del usuario.</p> required <code>minutes</code> <code>int</code> <p>N\u00famero de minutos para considerar como reciente. Por defecto es 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la confirmaci\u00f3n se solicit\u00f3 hace menos de los minutos especificados, False en caso contrario.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def was_recently_requested(self, confirmation: UserConfirmation, minutes: int = 3) -&gt; bool:\n    \"\"\"\n    Verifica si la confirmaci\u00f3n se solicit\u00f3 recientemente.\n\n    Args:\n        confirmation (UserConfirmation): Objeto de confirmaci\u00f3n del usuario.\n        minutes (int, optional): N\u00famero de minutos para considerar como reciente. Por defecto es 3.\n\n    Returns:\n        bool: True si la confirmaci\u00f3n se solicit\u00f3 hace menos de los minutos especificados, False en caso contrario.\n    \"\"\"\n    return (datetime_utc_time() - ensure_utc(confirmation.created_at)).total_seconds() &lt; minutes * 60\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-reenvio-de-confirmacion","title":"M\u00e9todos Principales de reenv\u00edo de confirmaci\u00f3n","text":""},{"location":"user/use_cases/#resend_confirmation","title":"resend_confirmation","text":"<p>Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica si el usuario existe. 2. Valida el estado del usuario. 3. Obtiene la \u00faltima confirmaci\u00f3n del usuario. 4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera). 5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n. 6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito de la operaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de reenv\u00edo.</p> Source code in <code>app\\user\\application\\user_register_process\\resend_confirmation_use_case.py</code> <pre><code>def resend_confirmation(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda la confirmaci\u00f3n de registro a un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica si el usuario existe.\n    2. Valida el estado del usuario.\n    3. Obtiene la \u00faltima confirmaci\u00f3n del usuario.\n    4. Verifica si se puede reenviar la confirmaci\u00f3n (tiempo de espera).\n    5. Genera un nuevo PIN y actualiza la confirmaci\u00f3n.\n    6. Env\u00eda un nuevo correo electr\u00f3nico con el PIN.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito de la operaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de reenv\u00edo.\n    \"\"\"\n    user = self.user_repository.get_user_with_confirmation(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.PENDING],\n        disallowed_states=[UserState.ACTIVE, UserState.LOCKED, UserState.INACTIVE]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Obtener confirmaci\u00f3n del usuario\n    confirmation = self.get_last_confirmation(user.confirmacion)\n\n    # Verificar si hay una confirmaci\u00f3n pendiente\n    if not confirmation:\n        raise DomainException(\n            message=\"No hay una confirmaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    # Definimos el tiempo de espera en minutos\n    warning_time = 3\n\n    # Si es el primer reenv\u00edo (resends == 0), permitir sin restricci\u00f3n\n    if confirmation.resends &gt; 0:\n        # Si ya ha reenviado al menos una vez, verificar si han pasado 3 minutos\n        if self.was_recently_requested(confirmation, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    # Generar nuevo PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    # Actualizar el registro de confirmaci\u00f3n de usuario con manejo de errores\n    confirmation.pin = pin_hash\n    confirmation.expiracion = expiration_datetime\n    confirmation.resends += 1\n    confirmation.intentos = 0\n    confirmation.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_user_confirmation(confirmation):\n        # Log the error or handle it as needed\n        raise DomainException(\n            message=\"Error al actualizar la confirmaci\u00f3n del usuario\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    # Enviar el correo electr\u00f3nico con el nuevo PIN\n    background_tasks.add_task(self.resend_confirmation_email, email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de confirmaci\u00f3n reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#proceso-de-inicio-de-sesion","title":"Proceso de Inicio de Sesi\u00f3n","text":""},{"location":"user/use_cases/#caso-de-uso-inicio-de-sesion","title":"Caso de Uso: Inicio de Sesi\u00f3n","text":"<p>Caso de uso para el proceso de inicio de sesi\u00f3n.</p> <p>Esta clase maneja la l\u00f3gica de negocio para el inicio de sesi\u00f3n de usuarios, incluyendo la validaci\u00f3n de credenciales, el manejo de intentos fallidos, y la generaci\u00f3n de PIN para autenticaci\u00f3n de dos factores.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador de estados de usuario.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>class LoginUseCase:\n    \"\"\"\n    Caso de uso para el proceso de inicio de sesi\u00f3n.\n\n    Esta clase maneja la l\u00f3gica de negocio para el inicio de sesi\u00f3n de usuarios,\n    incluyendo la validaci\u00f3n de credenciales, el manejo de intentos fallidos,\n    y la generaci\u00f3n de PIN para autenticaci\u00f3n de dos factores.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n        state_validator (UserStateValidator): Validador de estados de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de LoginUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def login_user(self, email: str, password: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Inicia el proceso de inicio de sesi\u00f3n para un usuario.\n\n        Este m\u00e9todo realiza las siguientes operaciones:\n        1. Verifica la existencia del usuario.\n        2. Valida el estado del usuario.\n        3. Verifica la contrase\u00f1a.\n        4. Maneja intentos fallidos de inicio de sesi\u00f3n.\n        5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            password (str): Contrase\u00f1a del usuario.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si ocurre un error durante el proceso de inicio de sesi\u00f3n.\n            UserHasBeenBlockedException: Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.\n        \"\"\"\n        user = self.user_repository.get_user_with_two_factor_verification(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        # Validar el estado del usuario\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        # Verificar si verification trajo una lista de varias verificaciones,\n        verification = self.get_last_verification(user.verificacion_dos_pasos)\n\n        # Verificar si ya se ha enviado un PIN en los ltimos 3 minutos\n        warning_time = 3\n\n        if verification:\n            if self.was_recently_requested(verification, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n            # Eliminar verificaciones de dos pasos expiradas\n            self.user_repository.delete_two_factor_verification(verification)\n\n        if not verify_password(password, user.password):\n            self.handle_failed_login_attempt(user)\n\n        # Autenticaci\u00f3n exitosa\n        user.failed_attempts = 0\n        user.locked_until = None\n        self.user_repository.update_user(user)\n\n        # Generar el PIN y su hash\n        pin, pin_hash = generate_pin()\n\n        expiration_time = 10  # minutos\n        expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n        # Crear un nuevo registro de verificaci\u00f3n\n        verification = TwoStepVerification(\n            usuario_id=user.id,\n            pin=pin_hash,\n            expiracion=expiration_datetime,\n            resends=0,\n            created_at=datetime_utc_time()\n        )\n\n        self.user_repository.add_two_factor_verification(verification)\n\n        # Enviar el PIN al correo electr\u00f3nico del usuario\n        background_tasks.add_task(self.send_two_factor_verification_email, user.email, pin)\n\n        return SuccessResponse(\n            message=\"Verificaci\u00f3n en dos pasos iniciada. Por favor, revisa tu correo electr\u00f3nico para obtener el PIN.\"\n        )\n\n    def handle_failed_login_attempt(self, user: User) -&gt; None:\n        \"\"\"\n        Maneja un intento fallido de inicio de sesi\u00f3n.\n\n        Incrementa el contador de intentos fallidos y bloquea al usuario si se excede el l\u00edmite.\n\n        Args:\n            user (User): El usuario que ha fallado en el intento de inicio de sesi\u00f3n.\n\n        Raises:\n            UserHasBeenBlockedException: Si el usuario es bloqueado debido a m\u00faltiples intentos fallidos.\n            DomainException: Si la contrase\u00f1a es incorrecta pero no se ha alcanzado el l\u00edmite de intentos.\n        \"\"\"\n        max_failed_attempts = 3\n        block_time = 10\n\n        user.failed_attempts += 1\n        self.user_repository.update_user(user)\n\n        if user.failed_attempts &gt;= max_failed_attempts:\n            self.block_user(user, timedelta(minutes=block_time))\n            raise UserHasBeenBlockedException(block_time)\n\n        raise DomainException(\n            message=\"Contrase\u00f1a incorrecta.\",\n            status_code=status.HTTP_401_UNAUTHORIZED\n        )\n\n    def send_two_factor_verification_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n            pin (str): PIN de verificaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n        \"\"\"\n        subject = \"PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n        text_content = f\"Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n        return send_email(email, subject, text_content, html_content)\n\n    def was_recently_requested(self, verification: TwoStepVerification, minutes: int = 3) -&gt; bool:\n        \"\"\"\n        Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 recientemente.\n\n        Args:\n            verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos.\n            minutes (int, optional): N\u00famero de minutos para considerar como reciente. Por defecto es 3.\n\n        Returns:\n            bool: True si la verificaci\u00f3n se solicit\u00f3 hace menos de los minutos especificados, False en caso contrario.\n        \"\"\"\n        \"\"\"Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 hace menos de x minutos.\"\"\"\n        return (datetime_utc_time() - ensure_utc(verification.created_at)).total_seconds() &lt; minutes * 60\n\n    def get_last_verification(self, verification: TwoStepVerification) -&gt; Optional[TwoStepVerification]:\n        \"\"\"\n        Obtiene la \u00faltima verificaci\u00f3n de dos pasos si existe.\n\n        Args:\n            verification (TwoStepVerification): Lista de verificaciones de dos pasos.\n\n        Returns:\n            Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos pasos o None si no hay verificaciones.\n        \"\"\"\n        \"\"\"Obtiene la \u00faltima verificaci\u00f3n de dos pasos si existe.\"\"\"\n        if isinstance(verification, list) and verification:\n            # Ordenar las verificaciones por fecha de creaci\u00f3n de forma ascendente\n            verification.sort(key=lambda v: v.created_at)\n            # Tomar el \u00faltimo registro\n            latest_verification = verification[-1]\n            # Eliminar todas las verificaciones anteriores a la \u00faltima\n            for old_verification in verification[:-1]:\n                self.user_repository.delete_two_factor_verification(old_verification)\n            # Actualizar la variable verification para solo trabajar con la \u00faltima\n            return latest_verification\n        # Si no hay verificaciones, retornar None\n        return None\n\n    def is_user_blocked(self, user: User) -&gt; bool:\n        \"\"\"\n        Verifica si un usuario est\u00e1 bloqueado.\n\n        Args:\n            user (User): El usuario a verificar.\n\n        Returns:\n            bool: True si el usuario est\u00e1 bloqueado, False en caso contrario.\n        \"\"\"\n        return user.locked_until and datetime_utc_time() &lt; user.locked_until and user.state_id == self.get_locked_user_state().id\n\n    def block_user(self, user: User, lock_duration: timedelta) -&gt; bool:\n        \"\"\"\n        Bloquea a un usuario por un per\u00edodo de tiempo espec\u00edfico.\n\n        Args:\n            user (User): El usuario a bloquear.\n            lock_duration (timedelta): Duraci\u00f3n del bloqueo.\n\n        Returns:\n            bool: True si el usuario fue bloqueado exitosamente, False en caso contrario.\n\n        Raises:\n            DomainException: Si ocurre un error al bloquear al usuario.\n        \"\"\"\n        try:\n            user.locked_until = datetime_utc_time() + lock_duration\n            user.state_id = self.get_locked_user_state().id\n            if not self.user_repository.update_user(user):\n                raise DomainException(\n                    message=\"No se pudo actualizar el estado del usuario.\",\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n                )\n\n            # Verificaci\u00f3n adicional\n            if not self.is_user_blocked(user):\n                raise DomainException(\n                    message=\"No se pudo bloquear el usuario.\",\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n                )\n\n            return True\n        except Exception as e:\n            raise DomainException(\n                message=f\"Error al bloquear el usuario: {str(e)}\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n    def get_locked_user_state(self) -&gt; Optional[UserStateModel]:\n        \"\"\"\n        Obtiene el estado de usuario 'bloqueado'.\n\n        Returns:\n            Optional[UserStateModel]: El estado de usuario 'bloqueado'.\n\n        Raises:\n            DomainException: Si no se puede obtener el estado de usuario bloqueado.\n        \"\"\"\n        locked_state = self.user_repository.get_state_by_name(LOCKED_STATE_NAME)\n        if not locked_state:\n            raise DomainException(\n                message=\"No se pudo obtener el estado de usuario bloqueado.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        return locked_state\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica de negocio para el inicio de sesi\u00f3n de usuarios, incluyendo la validaci\u00f3n de credenciales, el manejo de intentos fallidos, y la generaci\u00f3n de PIN para autenticaci\u00f3n de dos factores.</p>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de LoginUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de LoginUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.block_user","title":"<code>block_user(user, lock_duration)</code>","text":"<p>Bloquea a un usuario por un per\u00edodo de tiempo espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>El usuario a bloquear.</p> required <code>lock_duration</code> <code>timedelta</code> <p>Duraci\u00f3n del bloqueo.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario fue bloqueado exitosamente, False en caso contrario.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si ocurre un error al bloquear al usuario.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def block_user(self, user: User, lock_duration: timedelta) -&gt; bool:\n    \"\"\"\n    Bloquea a un usuario por un per\u00edodo de tiempo espec\u00edfico.\n\n    Args:\n        user (User): El usuario a bloquear.\n        lock_duration (timedelta): Duraci\u00f3n del bloqueo.\n\n    Returns:\n        bool: True si el usuario fue bloqueado exitosamente, False en caso contrario.\n\n    Raises:\n        DomainException: Si ocurre un error al bloquear al usuario.\n    \"\"\"\n    try:\n        user.locked_until = datetime_utc_time() + lock_duration\n        user.state_id = self.get_locked_user_state().id\n        if not self.user_repository.update_user(user):\n            raise DomainException(\n                message=\"No se pudo actualizar el estado del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        # Verificaci\u00f3n adicional\n        if not self.is_user_blocked(user):\n            raise DomainException(\n                message=\"No se pudo bloquear el usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return True\n    except Exception as e:\n        raise DomainException(\n            message=f\"Error al bloquear el usuario: {str(e)}\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.get_last_verification","title":"<code>get_last_verification(verification)</code>","text":"<p>Obtiene la \u00faltima verificaci\u00f3n de dos pasos si existe.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Lista de verificaciones de dos pasos.</p> required <p>Returns:</p> Type Description <code>Optional[TwoStepVerification]</code> <p>Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos pasos o None si no hay verificaciones.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def get_last_verification(self, verification: TwoStepVerification) -&gt; Optional[TwoStepVerification]:\n    \"\"\"\n    Obtiene la \u00faltima verificaci\u00f3n de dos pasos si existe.\n\n    Args:\n        verification (TwoStepVerification): Lista de verificaciones de dos pasos.\n\n    Returns:\n        Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos pasos o None si no hay verificaciones.\n    \"\"\"\n    \"\"\"Obtiene la \u00faltima verificaci\u00f3n de dos pasos si existe.\"\"\"\n    if isinstance(verification, list) and verification:\n        # Ordenar las verificaciones por fecha de creaci\u00f3n de forma ascendente\n        verification.sort(key=lambda v: v.created_at)\n        # Tomar el \u00faltimo registro\n        latest_verification = verification[-1]\n        # Eliminar todas las verificaciones anteriores a la \u00faltima\n        for old_verification in verification[:-1]:\n            self.user_repository.delete_two_factor_verification(old_verification)\n        # Actualizar la variable verification para solo trabajar con la \u00faltima\n        return latest_verification\n    # Si no hay verificaciones, retornar None\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.get_locked_user_state","title":"<code>get_locked_user_state()</code>","text":"<p>Obtiene el estado de usuario 'bloqueado'.</p> <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserStateModel]: El estado de usuario 'bloqueado'.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se puede obtener el estado de usuario bloqueado.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def get_locked_user_state(self) -&gt; Optional[UserStateModel]:\n    \"\"\"\n    Obtiene el estado de usuario 'bloqueado'.\n\n    Returns:\n        Optional[UserStateModel]: El estado de usuario 'bloqueado'.\n\n    Raises:\n        DomainException: Si no se puede obtener el estado de usuario bloqueado.\n    \"\"\"\n    locked_state = self.user_repository.get_state_by_name(LOCKED_STATE_NAME)\n    if not locked_state:\n        raise DomainException(\n            message=\"No se pudo obtener el estado de usuario bloqueado.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return locked_state\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.handle_failed_login_attempt","title":"<code>handle_failed_login_attempt(user)</code>","text":"<p>Maneja un intento fallido de inicio de sesi\u00f3n.</p> <p>Incrementa el contador de intentos fallidos y bloquea al usuario si se excede el l\u00edmite.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>El usuario que ha fallado en el intento de inicio de sesi\u00f3n.</p> required <p>Raises:</p> Type Description <code>UserHasBeenBlockedException</code> <p>Si el usuario es bloqueado debido a m\u00faltiples intentos fallidos.</p> <code>DomainException</code> <p>Si la contrase\u00f1a es incorrecta pero no se ha alcanzado el l\u00edmite de intentos.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def handle_failed_login_attempt(self, user: User) -&gt; None:\n    \"\"\"\n    Maneja un intento fallido de inicio de sesi\u00f3n.\n\n    Incrementa el contador de intentos fallidos y bloquea al usuario si se excede el l\u00edmite.\n\n    Args:\n        user (User): El usuario que ha fallado en el intento de inicio de sesi\u00f3n.\n\n    Raises:\n        UserHasBeenBlockedException: Si el usuario es bloqueado debido a m\u00faltiples intentos fallidos.\n        DomainException: Si la contrase\u00f1a es incorrecta pero no se ha alcanzado el l\u00edmite de intentos.\n    \"\"\"\n    max_failed_attempts = 3\n    block_time = 10\n\n    user.failed_attempts += 1\n    self.user_repository.update_user(user)\n\n    if user.failed_attempts &gt;= max_failed_attempts:\n        self.block_user(user, timedelta(minutes=block_time))\n        raise UserHasBeenBlockedException(block_time)\n\n    raise DomainException(\n        message=\"Contrase\u00f1a incorrecta.\",\n        status_code=status.HTTP_401_UNAUTHORIZED\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.is_user_blocked","title":"<code>is_user_blocked(user)</code>","text":"<p>Verifica si un usuario est\u00e1 bloqueado.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>El usuario a verificar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario est\u00e1 bloqueado, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def is_user_blocked(self, user: User) -&gt; bool:\n    \"\"\"\n    Verifica si un usuario est\u00e1 bloqueado.\n\n    Args:\n        user (User): El usuario a verificar.\n\n    Returns:\n        bool: True si el usuario est\u00e1 bloqueado, False en caso contrario.\n    \"\"\"\n    return user.locked_until and datetime_utc_time() &lt; user.locked_until and user.state_id == self.get_locked_user_state().id\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.login_user","title":"<code>login_user(email, password, background_tasks)</code>","text":"<p>Inicia el proceso de inicio de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica la existencia del usuario. 2. Valida el estado del usuario. 3. Verifica la contrase\u00f1a. 4. Maneja intentos fallidos de inicio de sesi\u00f3n. 5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de inicio de sesi\u00f3n.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def login_user(self, email: str, password: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de inicio de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica la existencia del usuario.\n    2. Valida el estado del usuario.\n    3. Verifica la contrase\u00f1a.\n    4. Maneja intentos fallidos de inicio de sesi\u00f3n.\n    5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de inicio de sesi\u00f3n.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si verification trajo una lista de varias verificaciones,\n    verification = self.get_last_verification(user.verificacion_dos_pasos)\n\n    # Verificar si ya se ha enviado un PIN en los ltimos 3 minutos\n    warning_time = 3\n\n    if verification:\n        if self.was_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n        # Eliminar verificaciones de dos pasos expiradas\n        self.user_repository.delete_two_factor_verification(verification)\n\n    if not verify_password(password, user.password):\n        self.handle_failed_login_attempt(user)\n\n    # Autenticaci\u00f3n exitosa\n    user.failed_attempts = 0\n    user.locked_until = None\n    self.user_repository.update_user(user)\n\n    # Generar el PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    # Crear un nuevo registro de verificaci\u00f3n\n    verification = TwoStepVerification(\n        usuario_id=user.id,\n        pin=pin_hash,\n        expiracion=expiration_datetime,\n        resends=0,\n        created_at=datetime_utc_time()\n    )\n\n    self.user_repository.add_two_factor_verification(verification)\n\n    # Enviar el PIN al correo electr\u00f3nico del usuario\n    background_tasks.add_task(self.send_two_factor_verification_email, user.email, pin)\n\n    return SuccessResponse(\n        message=\"Verificaci\u00f3n en dos pasos iniciada. Por favor, revisa tu correo electr\u00f3nico para obtener el PIN.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.send_two_factor_verification_email","title":"<code>send_two_factor_verification_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 correctamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def send_two_factor_verification_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del usuario.\n        pin (str): PIN de verificaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 correctamente, False en caso contrario.\n    \"\"\"\n    subject = \"PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n    text_content = f\"Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.login_use_case.LoginUseCase.was_recently_requested","title":"<code>was_recently_requested(verification, minutes=3)</code>","text":"<p>Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 recientemente.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos pasos.</p> required <code>minutes</code> <code>int</code> <p>N\u00famero de minutos para considerar como reciente. Por defecto es 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la verificaci\u00f3n se solicit\u00f3 hace menos de los minutos especificados, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def was_recently_requested(self, verification: TwoStepVerification, minutes: int = 3) -&gt; bool:\n    \"\"\"\n    Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 recientemente.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos.\n        minutes (int, optional): N\u00famero de minutos para considerar como reciente. Por defecto es 3.\n\n    Returns:\n        bool: True si la verificaci\u00f3n se solicit\u00f3 hace menos de los minutos especificados, False en caso contrario.\n    \"\"\"\n    \"\"\"Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 hace menos de x minutos.\"\"\"\n    return (datetime_utc_time() - ensure_utc(verification.created_at)).total_seconds() &lt; minutes * 60\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-inicio-de-sesion","title":"M\u00e9todos Principales de inicio de sesi\u00f3n","text":""},{"location":"user/use_cases/#login_user","title":"login_user","text":"<p>Inicia el proceso de inicio de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo realiza las siguientes operaciones: 1. Verifica la existencia del usuario. 2. Valida el estado del usuario. 3. Verifica la contrase\u00f1a. 4. Maneja intentos fallidos de inicio de sesi\u00f3n. 5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>password</code> <code>str</code> <p>Contrase\u00f1a del usuario.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si ocurre un error durante el proceso de inicio de sesi\u00f3n.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\login_use_case.py</code> <pre><code>def login_user(self, email: str, password: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de inicio de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo realiza las siguientes operaciones:\n    1. Verifica la existencia del usuario.\n    2. Valida el estado del usuario.\n    3. Verifica la contrase\u00f1a.\n    4. Maneja intentos fallidos de inicio de sesi\u00f3n.\n    5. Genera y env\u00eda un PIN para autenticaci\u00f3n de dos factores.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        password (str): Contrase\u00f1a del usuario.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando el \u00e9xito del inicio del proceso de autenticaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si ocurre un error durante el proceso de inicio de sesi\u00f3n.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado por m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    # Validar el estado del usuario\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    # Verificar si verification trajo una lista de varias verificaciones,\n    verification = self.get_last_verification(user.verificacion_dos_pasos)\n\n    # Verificar si ya se ha enviado un PIN en los ltimos 3 minutos\n    warning_time = 3\n\n    if verification:\n        if self.was_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n        # Eliminar verificaciones de dos pasos expiradas\n        self.user_repository.delete_two_factor_verification(verification)\n\n    if not verify_password(password, user.password):\n        self.handle_failed_login_attempt(user)\n\n    # Autenticaci\u00f3n exitosa\n    user.failed_attempts = 0\n    user.locked_until = None\n    self.user_repository.update_user(user)\n\n    # Generar el PIN y su hash\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    # Crear un nuevo registro de verificaci\u00f3n\n    verification = TwoStepVerification(\n        usuario_id=user.id,\n        pin=pin_hash,\n        expiracion=expiration_datetime,\n        resends=0,\n        created_at=datetime_utc_time()\n    )\n\n    self.user_repository.add_two_factor_verification(verification)\n\n    # Enviar el PIN al correo electr\u00f3nico del usuario\n    background_tasks.add_task(self.send_two_factor_verification_email, user.email, pin)\n\n    return SuccessResponse(\n        message=\"Verificaci\u00f3n en dos pasos iniciada. Por favor, revisa tu correo electr\u00f3nico para obtener el PIN.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-verificacion-de-autenticacion-de-dos-factores","title":"Caso de Uso: Verificaci\u00f3n de Autenticaci\u00f3n de Dos Factores","text":"<p>Caso de uso para verificar la autenticaci\u00f3n de dos factores.</p> <p>Esta clase maneja el proceso de verificaci\u00f3n del PIN de autenticaci\u00f3n de dos factores, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>class VerifyUseCase:\n    \"\"\"\n    Caso de uso para verificar la autenticaci\u00f3n de dos factores.\n\n    Esta clase maneja el proceso de verificaci\u00f3n del PIN de autenticaci\u00f3n de dos factores,\n    incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN,\n    y el manejo de intentos fallidos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de VerifyUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def verify_2fa(self, email: str, pin: str) -&gt; TokenResponse:\n        \"\"\"\n        Verifica el PIN de autenticaci\u00f3n de dos factores.\n\n        Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n        de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja\n        los intentos fallidos.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            pin (str): PIN de verificaci\u00f3n proporcionado por el usuario.\n\n        Returns:\n            TokenResponse: Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,\n                             el PIN es incorrecto, o hay otros errores.\n            UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n        \"\"\"\n        user = self.user_repository.get_user_with_two_factor_verification(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        verification = self.get_last_verification(user.verificacion_dos_pasos)\n        if not verification:\n            raise DomainException(\n                message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if self.is_two_factor_verification_expired(verification):\n            self.user_repository.delete_two_factor_verification(verification)\n            raise DomainException(\n                message=\"La verificaci\u00f3n ha expirado. Por favor, inicie el proceso de doble factor de autenticaci\u00f3n nuevamente.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        pin_hash = hash_pin(pin)\n        verify_pin = verification.pin == pin_hash\n\n        if not verify_pin:\n            attempts = self.increment_two_factor_attempts(verification)\n            if attempts &gt;= 3:\n                block_time = 10\n                self.block_user(user, timedelta(minutes=block_time))\n                self.user_repository.delete_two_factor_verification(verification)\n                raise UserHasBeenBlockedException(block_time)\n            raise DomainException(\n                message=\"PIN de verificaci\u00f3n incorrecto.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        self.user_repository.delete_two_factor_verification(verification)\n\n        access_token = create_access_token(data={\"sub\": user.email})\n        return TokenResponse(\n            access_token=access_token,\n            token_type=\"bearer\"\n        )\n\n    def increment_two_factor_attempts(self, verification: TwoStepVerification) -&gt; int:\n        \"\"\"\n        Incrementa el contador de intentos fallidos de verificaci\u00f3n de dos factores.\n\n        Args:\n            verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos factores.\n\n        Returns:\n            int: N\u00famero actualizado de intentos fallidos.\n        \"\"\"\n        verification.intentos += 1\n        self.user_repository.update_two_factor_verification(verification)\n        return verification.intentos\n\n    def is_two_factor_verification_expired(self, verification: TwoStepVerification) -&gt; bool:\n        \"\"\"\n        Verifica si la verificaci\u00f3n de dos factores ha expirado.\n\n        Args:\n            verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos factores.\n\n        Returns:\n            bool: True si la verificaci\u00f3n ha expirado, False en caso contrario.\n        \"\"\"\n        return verification.expiracion &lt; datetime_utc_time()\n\n    def get_last_verification(self, verification: TwoStepVerification) -&gt; Optional[TwoStepVerification]:\n        \"\"\"\n        Obtiene la \u00faltima verificaci\u00f3n de dos factores del usuario.\n\n        Esta funci\u00f3n tambi\u00e9n elimina todas las verificaciones anteriores a la \u00faltima.\n\n        Args:\n            verification (TwoStepVerification): Objeto o lista de objetos de verificaci\u00f3n de dos factores.\n\n        Returns:\n            Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos factores, o None si no hay ninguna.\n        \"\"\"\n        if isinstance(verification, list) and verification:\n            verification.sort(key=lambda v: v.created_at)\n            latest_verification = verification[-1]\n            for old_verification in verification[:-1]:\n                self.user_repository.delete_two_factor_verification(old_verification)\n            return latest_verification\n        return None\n\n    def is_user_blocked(self, user: User) -&gt; bool:\n        \"\"\"\n        Verifica si el usuario est\u00e1 bloqueado.\n\n        Args:\n            user (User): Objeto de usuario a verificar.\n\n        Returns:\n            bool: True si el usuario est\u00e1 bloqueado, False en caso contrario.\n        \"\"\"\n        return user.locked_until and datetime_utc_time() &lt; user.locked_until and user.state_id == self.get_locked_user_state().id\n\n    def block_user(self, user: User, lock_duration: timedelta) -&gt; bool:\n        \"\"\"\n        Bloquea al usuario por un per\u00edodo de tiempo espec\u00edfico.\n\n        Args:\n            user (User): Usuario a bloquear.\n            lock_duration (timedelta): Duraci\u00f3n del bloqueo.\n\n        Returns:\n            bool: True si el usuario fue bloqueado exitosamente, False en caso contrario.\n\n        Raises:\n            DomainException: Si no se pudo bloquear al usuario.\n        \"\"\"\n        try:\n            user.locked_until = datetime_utc_time() + lock_duration\n            user.state_id = self.get_locked_user_state().id\n            if not self.user_repository.update_user(user):\n                raise DomainException(\n                    message=\"No se pudo actualizar el estado del usuario.\",\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n                )\n\n            if not self.is_user_blocked(user):\n                raise DomainException(\n                    message=\"No se pudo bloquear el usuario.\",\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n                )\n\n            return True\n        except Exception as e:\n            raise DomainException(\n                message=f\"Error al bloquear el usuario: {str(e)}\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n    def get_locked_user_state(self) -&gt; Optional[UserStateModel]:\n        \"\"\"\n        Obtiene el estado de usuario bloqueado.\n\n        Returns:\n            Optional[UserStateModel]: El estado de usuario bloqueado, o None si no se encuentra.\n\n        Raises:\n            DomainException: Si no se pudo obtener el estado de usuario bloqueado.\n        \"\"\"\n        locked_state = self.user_repository.get_state_by_name(LOCKED_STATE_NAME)\n        if not locked_state:\n            raise DomainException(\n                message=\"No se pudo obtener el estado de usuario bloqueado.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        return locked_state\n</code></pre> <p>Este caso de uso maneja el proceso de verificaci\u00f3n del PIN de autenticaci\u00f3n de dos factores, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de VerifyUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de VerifyUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.block_user","title":"<code>block_user(user, lock_duration)</code>","text":"<p>Bloquea al usuario por un per\u00edodo de tiempo espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Usuario a bloquear.</p> required <code>lock_duration</code> <code>timedelta</code> <p>Duraci\u00f3n del bloqueo.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario fue bloqueado exitosamente, False en caso contrario.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo bloquear al usuario.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def block_user(self, user: User, lock_duration: timedelta) -&gt; bool:\n    \"\"\"\n    Bloquea al usuario por un per\u00edodo de tiempo espec\u00edfico.\n\n    Args:\n        user (User): Usuario a bloquear.\n        lock_duration (timedelta): Duraci\u00f3n del bloqueo.\n\n    Returns:\n        bool: True si el usuario fue bloqueado exitosamente, False en caso contrario.\n\n    Raises:\n        DomainException: Si no se pudo bloquear al usuario.\n    \"\"\"\n    try:\n        user.locked_until = datetime_utc_time() + lock_duration\n        user.state_id = self.get_locked_user_state().id\n        if not self.user_repository.update_user(user):\n            raise DomainException(\n                message=\"No se pudo actualizar el estado del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        if not self.is_user_blocked(user):\n            raise DomainException(\n                message=\"No se pudo bloquear el usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return True\n    except Exception as e:\n        raise DomainException(\n            message=f\"Error al bloquear el usuario: {str(e)}\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.get_last_verification","title":"<code>get_last_verification(verification)</code>","text":"<p>Obtiene la \u00faltima verificaci\u00f3n de dos factores del usuario.</p> <p>Esta funci\u00f3n tambi\u00e9n elimina todas las verificaciones anteriores a la \u00faltima.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto o lista de objetos de verificaci\u00f3n de dos factores.</p> required <p>Returns:</p> Type Description <code>Optional[TwoStepVerification]</code> <p>Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos factores, o None si no hay ninguna.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def get_last_verification(self, verification: TwoStepVerification) -&gt; Optional[TwoStepVerification]:\n    \"\"\"\n    Obtiene la \u00faltima verificaci\u00f3n de dos factores del usuario.\n\n    Esta funci\u00f3n tambi\u00e9n elimina todas las verificaciones anteriores a la \u00faltima.\n\n    Args:\n        verification (TwoStepVerification): Objeto o lista de objetos de verificaci\u00f3n de dos factores.\n\n    Returns:\n        Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos factores, o None si no hay ninguna.\n    \"\"\"\n    if isinstance(verification, list) and verification:\n        verification.sort(key=lambda v: v.created_at)\n        latest_verification = verification[-1]\n        for old_verification in verification[:-1]:\n            self.user_repository.delete_two_factor_verification(old_verification)\n        return latest_verification\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.get_locked_user_state","title":"<code>get_locked_user_state()</code>","text":"<p>Obtiene el estado de usuario bloqueado.</p> <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserStateModel]: El estado de usuario bloqueado, o None si no se encuentra.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo obtener el estado de usuario bloqueado.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def get_locked_user_state(self) -&gt; Optional[UserStateModel]:\n    \"\"\"\n    Obtiene el estado de usuario bloqueado.\n\n    Returns:\n        Optional[UserStateModel]: El estado de usuario bloqueado, o None si no se encuentra.\n\n    Raises:\n        DomainException: Si no se pudo obtener el estado de usuario bloqueado.\n    \"\"\"\n    locked_state = self.user_repository.get_state_by_name(LOCKED_STATE_NAME)\n    if not locked_state:\n        raise DomainException(\n            message=\"No se pudo obtener el estado de usuario bloqueado.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return locked_state\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.increment_two_factor_attempts","title":"<code>increment_two_factor_attempts(verification)</code>","text":"<p>Incrementa el contador de intentos fallidos de verificaci\u00f3n de dos factores.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos factores.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>N\u00famero actualizado de intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def increment_two_factor_attempts(self, verification: TwoStepVerification) -&gt; int:\n    \"\"\"\n    Incrementa el contador de intentos fallidos de verificaci\u00f3n de dos factores.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos factores.\n\n    Returns:\n        int: N\u00famero actualizado de intentos fallidos.\n    \"\"\"\n    verification.intentos += 1\n    self.user_repository.update_two_factor_verification(verification)\n    return verification.intentos\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.is_two_factor_verification_expired","title":"<code>is_two_factor_verification_expired(verification)</code>","text":"<p>Verifica si la verificaci\u00f3n de dos factores ha expirado.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos factores.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la verificaci\u00f3n ha expirado, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def is_two_factor_verification_expired(self, verification: TwoStepVerification) -&gt; bool:\n    \"\"\"\n    Verifica si la verificaci\u00f3n de dos factores ha expirado.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos factores.\n\n    Returns:\n        bool: True si la verificaci\u00f3n ha expirado, False en caso contrario.\n    \"\"\"\n    return verification.expiracion &lt; datetime_utc_time()\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.is_user_blocked","title":"<code>is_user_blocked(user)</code>","text":"<p>Verifica si el usuario est\u00e1 bloqueado.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario a verificar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario est\u00e1 bloqueado, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def is_user_blocked(self, user: User) -&gt; bool:\n    \"\"\"\n    Verifica si el usuario est\u00e1 bloqueado.\n\n    Args:\n        user (User): Objeto de usuario a verificar.\n\n    Returns:\n        bool: True si el usuario est\u00e1 bloqueado, False en caso contrario.\n    \"\"\"\n    return user.locked_until and datetime_utc_time() &lt; user.locked_until and user.state_id == self.get_locked_user_state().id\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.verify_2fa_use_case.VerifyUseCase.verify_2fa","title":"<code>verify_2fa(email, pin)</code>","text":"<p>Verifica el PIN de autenticaci\u00f3n de dos factores.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>TokenResponse</code> <code>TokenResponse</code> <p>Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def verify_2fa(self, email: str, pin: str) -&gt; TokenResponse:\n    \"\"\"\n    Verifica el PIN de autenticaci\u00f3n de dos factores.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de verificaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        TokenResponse: Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.get_last_verification(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.is_two_factor_verification_expired(verification):\n        self.user_repository.delete_two_factor_verification(verification)\n        raise DomainException(\n            message=\"La verificaci\u00f3n ha expirado. Por favor, inicie el proceso de doble factor de autenticaci\u00f3n nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    pin_hash = hash_pin(pin)\n    verify_pin = verification.pin == pin_hash\n\n    if not verify_pin:\n        attempts = self.increment_two_factor_attempts(verification)\n        if attempts &gt;= 3:\n            block_time = 10\n            self.block_user(user, timedelta(minutes=block_time))\n            self.user_repository.delete_two_factor_verification(verification)\n            raise UserHasBeenBlockedException(block_time)\n        raise DomainException(\n            message=\"PIN de verificaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    self.user_repository.delete_two_factor_verification(verification)\n\n    access_token = create_access_token(data={\"sub\": user.email})\n    return TokenResponse(\n        access_token=access_token,\n        token_type=\"bearer\"\n    )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-verificacion-de-autenticacion-de-dos-factores","title":"M\u00e9todos Principales de verificaci\u00f3n de autenticaci\u00f3n de dos factores","text":""},{"location":"user/use_cases/#verify_2fa","title":"verify_2fa","text":"<p>Verifica el PIN de autenticaci\u00f3n de dos factores.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>TokenResponse</code> <code>TokenResponse</code> <p>Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\login_process\\verify_2fa_use_case.py</code> <pre><code>def verify_2fa(self, email: str, pin: str) -&gt; TokenResponse:\n    \"\"\"\n    Verifica el PIN de autenticaci\u00f3n de dos factores.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de verificaci\u00f3n de dos factores v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de verificaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        TokenResponse: Respuesta con el token de acceso si la verificaci\u00f3n es exitosa.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.get_last_verification(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.is_two_factor_verification_expired(verification):\n        self.user_repository.delete_two_factor_verification(verification)\n        raise DomainException(\n            message=\"La verificaci\u00f3n ha expirado. Por favor, inicie el proceso de doble factor de autenticaci\u00f3n nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    pin_hash = hash_pin(pin)\n    verify_pin = verification.pin == pin_hash\n\n    if not verify_pin:\n        attempts = self.increment_two_factor_attempts(verification)\n        if attempts &gt;= 3:\n            block_time = 10\n            self.block_user(user, timedelta(minutes=block_time))\n            self.user_repository.delete_two_factor_verification(verification)\n            raise UserHasBeenBlockedException(block_time)\n        raise DomainException(\n            message=\"PIN de verificaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    self.user_repository.delete_two_factor_verification(verification)\n\n    access_token = create_access_token(data={\"sub\": user.email})\n    return TokenResponse(\n        access_token=access_token,\n        token_type=\"bearer\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-reenvio-de-pin-de-verificacion-en-dos-pasos","title":"Caso de Uso: Reenv\u00edo de PIN de Verificaci\u00f3n en Dos Pasos","text":"<p>Caso de uso para reenviar el PIN de verificaci\u00f3n en dos pasos.</p> <p>Esta clase maneja el proceso de reenv\u00edo del PIN de verificaci\u00f3n en dos pasos, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>class Resend2faUseCase:\n    \"\"\"\n    Caso de uso para reenviar el PIN de verificaci\u00f3n en dos pasos.\n\n    Esta clase maneja el proceso de reenv\u00edo del PIN de verificaci\u00f3n en dos pasos,\n    incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes\n    recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de Resend2faUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def resend_2fa(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.\n\n        Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n        un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una verificaci\u00f3n pendiente, se ha solicitado\n                             un reenv\u00edo recientemente, o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_two_factor_verification(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        verification = self.get_last_verification(user.verificacion_dos_pasos)\n        if not verification:\n            raise DomainException(\n                message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        warning_time = 3\n\n        if verification.resends &gt; 0:\n            if self.was_recently_requested(verification, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n        pin, pin_hash = generate_pin()\n\n        expiration_time = 10  # minutos\n        expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n        verification.pin = pin_hash\n        verification.expiracion = expiration_datetime\n        verification.resends += 1\n        verification.intentos = 0\n        verification.created_at = datetime_utc_time()\n\n        if not self.user_repository.update_two_factor_verification(verification):\n            raise DomainException(\n                message=\"No se pudo actualizar la verificaci\u00f3n de doble factor de autenticaci\u00f3n\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        background_tasks.add_task(self.send_two_factor_pin, user.email, pin)\n\n        return SuccessResponse(\n            message=\"PIN de verificaci\u00f3n en dos pasos reenviado con \u00e9xito.\"\n        )\n\n    def send_two_factor_pin(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos reenviado.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n            pin (str): PIN de verificaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n        \"\"\"\n        subject = \"Reenv\u00edo de PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n        text_content = f\"Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        return send_email(email, subject, text_content, html_content)\n\n    def was_recently_requested(self, verification: TwoStepVerification, minutes: int = 3) -&gt; bool:\n        \"\"\"\n        Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 recientemente.\n\n        Args:\n            verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos.\n            minutes (int, optional): N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.\n\n        Returns:\n            bool: True si la solicitud fue reciente, False en caso contrario.\n        \"\"\"\n        return (datetime_utc_time() - ensure_utc(verification.created_at)).total_seconds() &lt; minutes * 60\n\n    def get_last_verification(self, verification: TwoStepVerification) -&gt; Optional[TwoStepVerification]:\n        \"\"\"\n        Obtiene la \u00faltima verificaci\u00f3n de dos pasos del usuario.\n\n        Esta funci\u00f3n tambi\u00e9n elimina todas las verificaciones anteriores a la \u00faltima.\n\n        Args:\n            verification (TwoStepVerification): Objeto o lista de objetos de verificaci\u00f3n de dos pasos.\n\n        Returns:\n            Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos pasos, o None si no hay ninguna.\n        \"\"\"\n        if isinstance(verification, list) and verification:\n            verification.sort(key=lambda v: v.created_at)\n            latest_verification = verification[-1]\n            for old_verification in verification[:-1]:\n                self.user_repository.delete_two_factor_verification(old_verification)\n            return latest_verification\n        return None\n</code></pre> <p>Este caso de uso maneja el proceso de reenv\u00edo del PIN de verificaci\u00f3n en dos pasos, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de Resend2faUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de Resend2faUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.get_last_verification","title":"<code>get_last_verification(verification)</code>","text":"<p>Obtiene la \u00faltima verificaci\u00f3n de dos pasos del usuario.</p> <p>Esta funci\u00f3n tambi\u00e9n elimina todas las verificaciones anteriores a la \u00faltima.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto o lista de objetos de verificaci\u00f3n de dos pasos.</p> required <p>Returns:</p> Type Description <code>Optional[TwoStepVerification]</code> <p>Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos pasos, o None si no hay ninguna.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def get_last_verification(self, verification: TwoStepVerification) -&gt; Optional[TwoStepVerification]:\n    \"\"\"\n    Obtiene la \u00faltima verificaci\u00f3n de dos pasos del usuario.\n\n    Esta funci\u00f3n tambi\u00e9n elimina todas las verificaciones anteriores a la \u00faltima.\n\n    Args:\n        verification (TwoStepVerification): Objeto o lista de objetos de verificaci\u00f3n de dos pasos.\n\n    Returns:\n        Optional[TwoStepVerification]: La \u00faltima verificaci\u00f3n de dos pasos, o None si no hay ninguna.\n    \"\"\"\n    if isinstance(verification, list) and verification:\n        verification.sort(key=lambda v: v.created_at)\n        latest_verification = verification[-1]\n        for old_verification in verification[:-1]:\n            self.user_repository.delete_two_factor_verification(old_verification)\n        return latest_verification\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.resend_2fa","title":"<code>resend_2fa(email, background_tasks)</code>","text":"<p>Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def resend_2fa(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.get_last_verification(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = 3\n\n    if verification.resends &gt; 0:\n        if self.was_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    verification.pin = pin_hash\n    verification.expiracion = expiration_datetime\n    verification.resends += 1\n    verification.intentos = 0\n    verification.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_two_factor_verification(verification):\n        raise DomainException(\n            message=\"No se pudo actualizar la verificaci\u00f3n de doble factor de autenticaci\u00f3n\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    background_tasks.add_task(self.send_two_factor_pin, user.email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de verificaci\u00f3n en dos pasos reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.send_two_factor_pin","title":"<code>send_two_factor_pin(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos reenviado.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del destinatario.</p> required <code>pin</code> <code>str</code> <p>PIN de verificaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 exitosamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def send_two_factor_pin(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de verificaci\u00f3n en dos pasos reenviado.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n        pin (str): PIN de verificaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n    \"\"\"\n    subject = \"Reenv\u00edo de PIN de verificaci\u00f3n en dos pasos - AgroInSight\"\n    text_content = f\"Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de verificaci\u00f3n en dos pasos es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.login_process.resend_2fa_use_case.Resend2faUseCase.was_recently_requested","title":"<code>was_recently_requested(verification, minutes=3)</code>","text":"<p>Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 recientemente.</p> <p>Parameters:</p> Name Type Description Default <code>verification</code> <code>TwoStepVerification</code> <p>Objeto de verificaci\u00f3n de dos pasos.</p> required <code>minutes</code> <code>int</code> <p>N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la solicitud fue reciente, False en caso contrario.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def was_recently_requested(self, verification: TwoStepVerification, minutes: int = 3) -&gt; bool:\n    \"\"\"\n    Verifica si la verificaci\u00f3n de dos pasos se solicit\u00f3 recientemente.\n\n    Args:\n        verification (TwoStepVerification): Objeto de verificaci\u00f3n de dos pasos.\n        minutes (int, optional): N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.\n\n    Returns:\n        bool: True si la solicitud fue reciente, False en caso contrario.\n    \"\"\"\n    return (datetime_utc_time() - ensure_utc(verification.created_at)).total_seconds() &lt; minutes * 60\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-reenvio-de-pin-de-verificacion-en-dos-pasos","title":"M\u00e9todos Principales de reenv\u00edo de PIN de verificaci\u00f3n en dos pasos","text":""},{"location":"user/use_cases/#resend_2fa","title":"resend_2fa","text":"<p>Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una verificaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\login_process\\resend_2fa_use_case.py</code> <pre><code>def resend_2fa(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de verificaci\u00f3n en dos pasos.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de verificaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una verificaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_two_factor_verification(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    verification = self.get_last_verification(user.verificacion_dos_pasos)\n    if not verification:\n        raise DomainException(\n            message=\"No hay una verificaci\u00f3n de doble factor de autenticaci\u00f3n pendiente para reenviar el PIN.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = 3\n\n    if verification.resends &gt; 0:\n        if self.was_recently_requested(verification, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de autenticaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10  # minutos\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    verification.pin = pin_hash\n    verification.expiracion = expiration_datetime\n    verification.resends += 1\n    verification.intentos = 0\n    verification.created_at = datetime_utc_time()\n\n    if not self.user_repository.update_two_factor_verification(verification):\n        raise DomainException(\n            message=\"No se pudo actualizar la verificaci\u00f3n de doble factor de autenticaci\u00f3n\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    background_tasks.add_task(self.send_two_factor_pin, user.email, pin)\n\n    return SuccessResponse(\n        message=\"PIN de verificaci\u00f3n en dos pasos reenviado con \u00e9xito.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#proceso-de-recuperacion-de-contrasena","title":"Proceso de Recuperaci\u00f3n de Contrase\u00f1a","text":""},{"location":"user/use_cases/#caso-de-uso-recuperacion-de-contrasena","title":"Caso de Uso: Recuperaci\u00f3n de Contrase\u00f1a","text":"<p>Caso de uso para el proceso de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Esta clase maneja el proceso de recuperaci\u00f3n de contrase\u00f1a, incluyendo la generaci\u00f3n y env\u00edo de PIN, validaci\u00f3n del estado del usuario y gesti\u00f3n de solicitudes recientes.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>class PasswordRecoveryUseCase:\n    \"\"\"\n    Caso de uso para el proceso de recuperaci\u00f3n de contrase\u00f1a.\n\n    Esta clase maneja el proceso de recuperaci\u00f3n de contrase\u00f1a, incluyendo la generaci\u00f3n\n    y env\u00edo de PIN, validaci\u00f3n del estado del usuario y gesti\u00f3n de solicitudes recientes.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de PasswordRecoveryUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def recovery_password(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n        Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n        un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si se ha solicitado un PIN recientemente o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        warning_time = 3\n        recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n        if recovery and self.was_recently_requested(recovery, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n        self.user_repository.delete_password_recovery(recovery)\n\n        pin, pin_hash = generate_pin()\n\n        expiration_time = 10\n        expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n        recovery = PasswordRecovery(\n            usuario_id=user.id,\n            pin=pin_hash,\n            expiracion=expiration_datetime,\n            resends=0,\n            created_at=datetime_utc_time()\n        )\n\n        background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n        self.user_repository.add_password_recovery(recovery)\n        return SuccessResponse(\n            message=\"Se ha enviado un PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n        )\n\n    def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n            pin (str): PIN de recuperaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n        \"\"\"\n        subject = \"Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n        text_content = f\"Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n        return send_email(email, subject, text_content, html_content)\n\n    def was_recently_requested(self, recovery: PasswordRecovery, minutes: int = 3) -&gt; bool:\n        \"\"\"\n        Verifica si la recuperaci\u00f3n de contrase\u00f1a se solicit\u00f3 recientemente.\n\n        Args:\n            recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a.\n            minutes (int, optional): N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.\n\n        Returns:\n            bool: True si la solicitud fue reciente, False en caso contrario.\n        \"\"\"\n        return (datetime_utc_time() - ensure_utc(recovery.created_at)).total_seconds() &lt; minutes * 60\n\n    def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n        \"\"\"\n        Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n        Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n        Args:\n            recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n        Returns:\n            Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n        \"\"\"\n        if isinstance(recovery, list) and recovery:\n            recovery.sort(key=lambda r: r.created_at)\n            latest_recovery = recovery[-1]\n            for old_recovery in recovery[:-1]:\n                self.user_repository.delete_password_recovery(old_recovery)\n            return latest_recovery\n        return None\n</code></pre> <p>Este caso de uso maneja el proceso de recuperaci\u00f3n de contrase\u00f1a, incluyendo la generaci\u00f3n y env\u00edo de PIN, validaci\u00f3n del estado del usuario y gesti\u00f3n de solicitudes recientes.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de PasswordRecoveryUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de PasswordRecoveryUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.get_last_password_recovery","title":"<code>get_last_password_recovery(recovery)</code>","text":"<p>Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.</p> <p>Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.</p> required <p>Returns:</p> Type Description <code>Optional[PasswordRecovery]</code> <p>Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n    \"\"\"\n    Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n    Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n    Args:\n        recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n    Returns:\n        Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n    \"\"\"\n    if isinstance(recovery, list) and recovery:\n        recovery.sort(key=lambda r: r.created_at)\n        latest_recovery = recovery[-1]\n        for old_recovery in recovery[:-1]:\n            self.user_repository.delete_password_recovery(old_recovery)\n        return latest_recovery\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.recovery_password","title":"<code>recovery_password(email, background_tasks)</code>","text":"<p>Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si se ha solicitado un PIN recientemente o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def recovery_password(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si se ha solicitado un PIN recientemente o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    warning_time = 3\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n    if recovery and self.was_recently_requested(recovery, warning_time):\n        raise DomainException(\n            message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS\n        )\n\n    self.user_repository.delete_password_recovery(recovery)\n\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    recovery = PasswordRecovery(\n        usuario_id=user.id,\n        pin=pin_hash,\n        expiracion=expiration_datetime,\n        resends=0,\n        created_at=datetime_utc_time()\n    )\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    self.user_repository.add_password_recovery(recovery)\n    return SuccessResponse(\n        message=\"Se ha enviado un PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.send_password_recovery_email","title":"<code>send_password_recovery_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del destinatario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 exitosamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n        pin (str): PIN de recuperaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n    \"\"\"\n    subject = \"Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n    text_content = f\"Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"&lt;html&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.password_recovery_use_case.PasswordRecoveryUseCase.was_recently_requested","title":"<code>was_recently_requested(recovery, minutes=3)</code>","text":"<p>Verifica si la recuperaci\u00f3n de contrase\u00f1a se solicit\u00f3 recientemente.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a.</p> required <code>minutes</code> <code>int</code> <p>N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la solicitud fue reciente, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def was_recently_requested(self, recovery: PasswordRecovery, minutes: int = 3) -&gt; bool:\n    \"\"\"\n    Verifica si la recuperaci\u00f3n de contrase\u00f1a se solicit\u00f3 recientemente.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a.\n        minutes (int, optional): N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.\n\n    Returns:\n        bool: True si la solicitud fue reciente, False en caso contrario.\n    \"\"\"\n    return (datetime_utc_time() - ensure_utc(recovery.created_at)).total_seconds() &lt; minutes * 60\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-recuperacion-de-contrasena","title":"M\u00e9todos Principales de recuperaci\u00f3n de contrase\u00f1a","text":""},{"location":"user/use_cases/#recovery_password","title":"recovery_password","text":"<p>Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si se ha solicitado un PIN recientemente o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\password_recovery_use_case.py</code> <pre><code>def recovery_password(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Inicia el proceso de recuperaci\u00f3n de contrase\u00f1a para un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un PIN, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita la recuperaci\u00f3n.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha enviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si se ha solicitado un PIN recientemente o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    warning_time = 3\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n    if recovery and self.was_recently_requested(recovery, warning_time):\n        raise DomainException(\n            message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n            status_code=status.HTTP_429_TOO_MANY_REQUESTS\n        )\n\n    self.user_repository.delete_password_recovery(recovery)\n\n    pin, pin_hash = generate_pin()\n\n    expiration_time = 10\n    expiration_datetime = datetime_utc_time() + timedelta(minutes=expiration_time)\n\n    recovery = PasswordRecovery(\n        usuario_id=user.id,\n        pin=pin_hash,\n        expiracion=expiration_datetime,\n        resends=0,\n        created_at=datetime_utc_time()\n    )\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    self.user_repository.add_password_recovery(recovery)\n    return SuccessResponse(\n        message=\"Se ha enviado un PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-confirmacion-de-pin-de-recuperacion","title":"Caso de Uso: Confirmaci\u00f3n de PIN de Recuperaci\u00f3n","text":"<p>Caso de uso para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Esta clase maneja el proceso de confirmaci\u00f3n del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>class ConfirmRecoveryPinUseCase:\n    \"\"\"\n    Caso de uso para confirmar el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Esta clase maneja el proceso de confirmaci\u00f3n del PIN de recuperaci\u00f3n,\n    incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN,\n    y el manejo de intentos fallidos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ConfirmRecoveryPinUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def confirm_recovery(self, email: str, pin: str) -&gt; SuccessResponse:\n        \"\"\"\n        Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n        Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n        de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja\n        los intentos fallidos.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            pin (str): PIN de recuperaci\u00f3n proporcionado por el usuario.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que el PIN se confirm\u00f3 correctamente.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,\n                             el PIN es incorrecto, o hay otros errores.\n            UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n        if not recovery:\n            raise DomainException(\n                message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if self.is_password_recovery_expired(recovery):\n            self.user_repository.delete_password_recovery(recovery)\n            raise DomainException(\n                message=\"La recuperaci\u00f3n de contrase\u00f1a ha expirado. Por favor, inicie el proceso de recuperaci\u00f3n de contrase\u00f1a nuevamente.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        pin_hash = hash_pin(pin)\n\n        recovery_pin = recovery.pin == pin_hash \n\n        if not recovery_pin:\n            recovery.intentos += 1\n            self.user_repository.update_password_recovery(recovery)\n\n            if recovery.intentos &gt;= 3:\n                block_time = 10\n                self.user_repository.delete_password_recovery(recovery)\n                self.block_user(user, timedelta(minutes=block_time))\n                raise UserHasBeenBlockedException(block_time)\n\n            raise DomainException(\n                message=\"PIN de recuperaci\u00f3n incorrecto.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        recovery.pin_confirmado = True\n        self.user_repository.update_password_recovery(recovery)\n\n        return SuccessResponse(\n                message=\"PIN de recuperaci\u00f3n confirmado correctamente.\"\n            )\n\n    def is_password_recovery_expired(self, recovery: PasswordRecovery) -&gt; bool:\n        \"\"\"\n        Verifica si la recuperaci\u00f3n de contrase\u00f1a ha expirado.\n\n        Args:\n            recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a.\n\n        Returns:\n            bool: True si la recuperaci\u00f3n ha expirado, False en caso contrario.\n        \"\"\"\n        return recovery.expiracion &lt; datetime_utc_time()\n\n    def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n        \"\"\"\n        Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n        Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n        Args:\n            recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n        Returns:\n            Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n        \"\"\"\n        if isinstance(recovery, list) and recovery:\n            recovery.sort(key=lambda r: r.created_at)\n            latest_recovery = recovery[-1]\n            for old_recovery in recovery[:-1]:\n                self.user_repository.delete_password_recovery(old_recovery)\n            return latest_recovery\n        return None\n\n    def is_user_blocked(self, user: User) -&gt; bool:\n        \"\"\"\n        Verifica si el usuario est\u00e1 bloqueado.\n\n        Args:\n            user (User): Objeto de usuario a verificar.\n\n        Returns:\n            bool: True si el usuario est\u00e1 bloqueado, False en caso contrario.\n        \"\"\"\n        return user.locked_until and datetime_utc_time() &lt; user.locked_until and user.state_id == self.get_locked_user_state().id\n\n    def block_user(self, user: User, lock_duration: timedelta) -&gt; bool:\n        \"\"\"\n        Bloquea al usuario por un per\u00edodo de tiempo espec\u00edfico.\n\n        Args:\n            user (User): Usuario a bloquear.\n            lock_duration (timedelta): Duraci\u00f3n del bloqueo.\n\n        Returns:\n            bool: True si el usuario fue bloqueado exitosamente, False en caso contrario.\n\n        Raises:\n            DomainException: Si no se pudo bloquear al usuario.\n        \"\"\"\n        try:\n            user.locked_until = datetime_utc_time() + lock_duration\n            user.state_id = self.get_locked_user_state().id\n            if not self.user_repository.update_user(user):\n                raise DomainException(\n                    message=\"No se pudo actualizar el estado del usuario.\",\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n                )\n\n            if not self.is_user_blocked(user):\n                raise DomainException(\n                    message=\"No se pudo bloquear el usuario.\",\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n                )\n\n            return True\n        except Exception as e:\n            raise DomainException(\n                message=f\"Error al bloquear el usuario: {str(e)}\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n    def get_locked_user_state(self) -&gt; Optional[UserStateModel]:\n        \"\"\"\n        Obtiene el estado de usuario bloqueado.\n\n        Returns:\n            Optional[UserStateModel]: El estado de usuario bloqueado, o None si no se encuentra.\n\n        Raises:\n            DomainException: Si no se pudo obtener el estado de usuario bloqueado.\n        \"\"\"\n        locked_state = self.user_repository.get_state_by_name(LOCKED_STATE_NAME)\n        if not locked_state:\n            raise DomainException(\n                message=\"No se pudo obtener el estado de usuario bloqueado.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        return locked_state\n</code></pre> <p>Este caso de uso maneja el proceso de confirmaci\u00f3n del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN, y el manejo de intentos fallidos.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ConfirmRecoveryPinUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ConfirmRecoveryPinUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.block_user","title":"<code>block_user(user, lock_duration)</code>","text":"<p>Bloquea al usuario por un per\u00edodo de tiempo espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Usuario a bloquear.</p> required <code>lock_duration</code> <code>timedelta</code> <p>Duraci\u00f3n del bloqueo.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario fue bloqueado exitosamente, False en caso contrario.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo bloquear al usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def block_user(self, user: User, lock_duration: timedelta) -&gt; bool:\n    \"\"\"\n    Bloquea al usuario por un per\u00edodo de tiempo espec\u00edfico.\n\n    Args:\n        user (User): Usuario a bloquear.\n        lock_duration (timedelta): Duraci\u00f3n del bloqueo.\n\n    Returns:\n        bool: True si el usuario fue bloqueado exitosamente, False en caso contrario.\n\n    Raises:\n        DomainException: Si no se pudo bloquear al usuario.\n    \"\"\"\n    try:\n        user.locked_until = datetime_utc_time() + lock_duration\n        user.state_id = self.get_locked_user_state().id\n        if not self.user_repository.update_user(user):\n            raise DomainException(\n                message=\"No se pudo actualizar el estado del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        if not self.is_user_blocked(user):\n            raise DomainException(\n                message=\"No se pudo bloquear el usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return True\n    except Exception as e:\n        raise DomainException(\n            message=f\"Error al bloquear el usuario: {str(e)}\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.confirm_recovery","title":"<code>confirm_recovery(email, pin)</code>","text":"<p>Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el PIN se confirm\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def confirm_recovery(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de recuperaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el PIN se confirm\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.is_password_recovery_expired(recovery):\n        self.user_repository.delete_password_recovery(recovery)\n        raise DomainException(\n            message=\"La recuperaci\u00f3n de contrase\u00f1a ha expirado. Por favor, inicie el proceso de recuperaci\u00f3n de contrase\u00f1a nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    pin_hash = hash_pin(pin)\n\n    recovery_pin = recovery.pin == pin_hash \n\n    if not recovery_pin:\n        recovery.intentos += 1\n        self.user_repository.update_password_recovery(recovery)\n\n        if recovery.intentos &gt;= 3:\n            block_time = 10\n            self.user_repository.delete_password_recovery(recovery)\n            self.block_user(user, timedelta(minutes=block_time))\n            raise UserHasBeenBlockedException(block_time)\n\n        raise DomainException(\n            message=\"PIN de recuperaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    recovery.pin_confirmado = True\n    self.user_repository.update_password_recovery(recovery)\n\n    return SuccessResponse(\n            message=\"PIN de recuperaci\u00f3n confirmado correctamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.get_last_password_recovery","title":"<code>get_last_password_recovery(recovery)</code>","text":"<p>Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.</p> <p>Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.</p> required <p>Returns:</p> Type Description <code>Optional[PasswordRecovery]</code> <p>Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n    \"\"\"\n    Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n    Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n    Args:\n        recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n    Returns:\n        Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n    \"\"\"\n    if isinstance(recovery, list) and recovery:\n        recovery.sort(key=lambda r: r.created_at)\n        latest_recovery = recovery[-1]\n        for old_recovery in recovery[:-1]:\n            self.user_repository.delete_password_recovery(old_recovery)\n        return latest_recovery\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.get_locked_user_state","title":"<code>get_locked_user_state()</code>","text":"<p>Obtiene el estado de usuario bloqueado.</p> <p>Returns:</p> Type Description <code>Optional[UserState]</code> <p>Optional[UserStateModel]: El estado de usuario bloqueado, o None si no se encuentra.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo obtener el estado de usuario bloqueado.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def get_locked_user_state(self) -&gt; Optional[UserStateModel]:\n    \"\"\"\n    Obtiene el estado de usuario bloqueado.\n\n    Returns:\n        Optional[UserStateModel]: El estado de usuario bloqueado, o None si no se encuentra.\n\n    Raises:\n        DomainException: Si no se pudo obtener el estado de usuario bloqueado.\n    \"\"\"\n    locked_state = self.user_repository.get_state_by_name(LOCKED_STATE_NAME)\n    if not locked_state:\n        raise DomainException(\n            message=\"No se pudo obtener el estado de usuario bloqueado.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return locked_state\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.is_password_recovery_expired","title":"<code>is_password_recovery_expired(recovery)</code>","text":"<p>Verifica si la recuperaci\u00f3n de contrase\u00f1a ha expirado.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la recuperaci\u00f3n ha expirado, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def is_password_recovery_expired(self, recovery: PasswordRecovery) -&gt; bool:\n    \"\"\"\n    Verifica si la recuperaci\u00f3n de contrase\u00f1a ha expirado.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a.\n\n    Returns:\n        bool: True si la recuperaci\u00f3n ha expirado, False en caso contrario.\n    \"\"\"\n    return recovery.expiracion &lt; datetime_utc_time()\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.confirm_recovery_use_case.ConfirmRecoveryPinUseCase.is_user_blocked","title":"<code>is_user_blocked(user)</code>","text":"<p>Verifica si el usuario est\u00e1 bloqueado.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>Objeto de usuario a verificar.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el usuario est\u00e1 bloqueado, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def is_user_blocked(self, user: User) -&gt; bool:\n    \"\"\"\n    Verifica si el usuario est\u00e1 bloqueado.\n\n    Args:\n        user (User): Objeto de usuario a verificar.\n\n    Returns:\n        bool: True si el usuario est\u00e1 bloqueado, False en caso contrario.\n    \"\"\"\n    return user.locked_until and datetime_utc_time() &lt; user.locked_until and user.state_id == self.get_locked_user_state().id\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-confirmacion-de-pin-de-recuperacion","title":"M\u00e9todos Principales de confirmaci\u00f3n de PIN de recuperaci\u00f3n","text":""},{"location":"user/use_cases/#confirm_recovery","title":"confirm_recovery","text":"<p>Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja los intentos fallidos.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n proporcionado por el usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el PIN se confirm\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,              el PIN es incorrecto, o hay otros errores.</p> <code>UserHasBeenBlockedException</code> <p>Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.</p> Source code in <code>app\\user\\application\\password_recovery_process\\confirm_recovery_use_case.py</code> <pre><code>def confirm_recovery(self, email: str, pin: str) -&gt; SuccessResponse:\n    \"\"\"\n    Confirma el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, comprueba el PIN proporcionado y maneja\n    los intentos fallidos.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        pin (str): PIN de recuperaci\u00f3n proporcionado por el usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el PIN se confirm\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN ha expirado,\n                         el PIN es incorrecto, o hay otros errores.\n        UserHasBeenBlockedException: Si el usuario ha sido bloqueado debido a m\u00faltiples intentos fallidos.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if self.is_password_recovery_expired(recovery):\n        self.user_repository.delete_password_recovery(recovery)\n        raise DomainException(\n            message=\"La recuperaci\u00f3n de contrase\u00f1a ha expirado. Por favor, inicie el proceso de recuperaci\u00f3n de contrase\u00f1a nuevamente.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    pin_hash = hash_pin(pin)\n\n    recovery_pin = recovery.pin == pin_hash \n\n    if not recovery_pin:\n        recovery.intentos += 1\n        self.user_repository.update_password_recovery(recovery)\n\n        if recovery.intentos &gt;= 3:\n            block_time = 10\n            self.user_repository.delete_password_recovery(recovery)\n            self.block_user(user, timedelta(minutes=block_time))\n            raise UserHasBeenBlockedException(block_time)\n\n        raise DomainException(\n            message=\"PIN de recuperaci\u00f3n incorrecto.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    recovery.pin_confirmado = True\n    self.user_repository.update_password_recovery(recovery)\n\n    return SuccessResponse(\n            message=\"PIN de recuperaci\u00f3n confirmado correctamente.\"\n        )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-reenvio-de-pin-de-recuperacion","title":"Caso de Uso: Reenv\u00edo de PIN de Recuperaci\u00f3n","text":"<p>Caso de uso para reenviar el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Esta clase maneja el proceso de reenv\u00edo del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>class ResendRecoveryUseCase:\n    \"\"\"\n    Caso de uso para reenviar el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Esta clase maneja el proceso de reenv\u00edo del PIN de recuperaci\u00f3n, incluyendo\n    la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes,\n    y la generaci\u00f3n y env\u00edo de un nuevo PIN.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ResendRecoveryUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def resend_recovery(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n        \"\"\"\n        Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n        Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n        un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n            background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado\n                             un reenv\u00edo recientemente, o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n\n        if not recovery:\n            raise DomainException(\n                message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        warning_time = 3\n\n        if recovery.resends &gt; 0:\n            if self.was_recently_requested(recovery, warning_time):\n                raise DomainException(\n                    message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                    status_code=status.HTTP_429_TOO_MANY_REQUESTS\n                )\n\n        pin, pin_hash = generate_pin()\n\n        background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n        recovery.pin = pin_hash\n        recovery.expiracion = datetime_utc_time() + timedelta(minutes=10)\n        recovery.intentos = 0\n        recovery.resends += 1\n        self.user_repository.update_password_recovery(recovery)\n        return SuccessResponse(\n            message=\"Se ha reenviado el PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n        )\n\n    def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n        \"\"\"\n        Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a reenviado.\n\n        Args:\n            email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n            pin (str): PIN de recuperaci\u00f3n generado.\n\n        Returns:\n            bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n        \"\"\"\n        subject = \"Reenv\u00edo: Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n        text_content = f\"Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n        html_content = f\"\"\"\n        &lt;html&gt;\n            &lt;body&gt;\n                &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;\n                &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n            &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        return send_email(email, subject, text_content, html_content)\n\n    def was_recently_requested(self, recovery: PasswordRecovery, minutes: int = 3) -&gt; bool:\n        \"\"\"\n        Verifica si la recuperaci\u00f3n de contrase\u00f1a se solicit\u00f3 recientemente.\n\n        Args:\n            recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a.\n            minutes (int, optional): N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.\n\n        Returns:\n            bool: True si la solicitud fue reciente, False en caso contrario.\n        \"\"\"\n        return (datetime_utc_time() - ensure_utc(recovery.created_at)).total_seconds() &lt; minutes * 60\n\n    def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n        \"\"\"\n        Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n        Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n        Args:\n            recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n        Returns:\n            Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n        \"\"\"\n        if isinstance(recovery, list) and recovery:\n            recovery.sort(key=lambda r: r.created_at)\n            latest_recovery = recovery[-1]\n            for old_recovery in recovery[:-1]:\n                self.user_repository.delete_password_recovery(old_recovery)\n            return latest_recovery\n        return None\n</code></pre> <p>Este caso de uso maneja el proceso de reenv\u00edo del PIN de recuperaci\u00f3n, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n de solicitudes recientes, y la generaci\u00f3n y env\u00edo de un nuevo PIN.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ResendRecoveryUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ResendRecoveryUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.get_last_password_recovery","title":"<code>get_last_password_recovery(recovery)</code>","text":"<p>Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.</p> <p>Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.</p> required <p>Returns:</p> Type Description <code>Optional[PasswordRecovery]</code> <p>Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n    \"\"\"\n    Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n    Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n    Args:\n        recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n    Returns:\n        Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n    \"\"\"\n    if isinstance(recovery, list) and recovery:\n        recovery.sort(key=lambda r: r.created_at)\n        latest_recovery = recovery[-1]\n        for old_recovery in recovery[:-1]:\n            self.user_repository.delete_password_recovery(old_recovery)\n        return latest_recovery\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.resend_recovery","title":"<code>resend_recovery(email, background_tasks)</code>","text":"<p>Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def resend_recovery(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = 3\n\n    if recovery.resends &gt; 0:\n        if self.was_recently_requested(recovery, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    recovery.pin = pin_hash\n    recovery.expiracion = datetime_utc_time() + timedelta(minutes=10)\n    recovery.intentos = 0\n    recovery.resends += 1\n    self.user_repository.update_password_recovery(recovery)\n    return SuccessResponse(\n        message=\"Se ha reenviado el PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.send_password_recovery_email","title":"<code>send_password_recovery_email(email, pin)</code>","text":"<p>Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a reenviado.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Direcci\u00f3n de correo electr\u00f3nico del destinatario.</p> required <code>pin</code> <code>str</code> <p>PIN de recuperaci\u00f3n generado.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el correo se envi\u00f3 exitosamente, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def send_password_recovery_email(self, email: str, pin: str) -&gt; bool:\n    \"\"\"\n    Env\u00eda un correo electr\u00f3nico con el PIN de recuperaci\u00f3n de contrase\u00f1a reenviado.\n\n    Args:\n        email (str): Direcci\u00f3n de correo electr\u00f3nico del destinatario.\n        pin (str): PIN de recuperaci\u00f3n generado.\n\n    Returns:\n        bool: True si el correo se envi\u00f3 exitosamente, False en caso contrario.\n    \"\"\"\n    subject = \"Reenv\u00edo: Recuperaci\u00f3n de contrase\u00f1a - AgroInSight\"\n    text_content = f\"Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}\\nEste PIN expirar\u00e1 en 10 minutos.\"\n    html_content = f\"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;p&gt;&lt;strong&gt;Reenv\u00edo: Tu PIN de recuperaci\u00f3n de contrase\u00f1a es: {pin}&lt;/strong&gt;&lt;/p&gt;\n            &lt;p&gt;Este PIN expirar\u00e1 en 10 minutos.&lt;/p&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    return send_email(email, subject, text_content, html_content)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.resend_recovery_use_case.ResendRecoveryUseCase.was_recently_requested","title":"<code>was_recently_requested(recovery, minutes=3)</code>","text":"<p>Verifica si la recuperaci\u00f3n de contrase\u00f1a se solicit\u00f3 recientemente.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto de recuperaci\u00f3n de contrase\u00f1a.</p> required <code>minutes</code> <code>int</code> <p>N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si la solicitud fue reciente, False en caso contrario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def was_recently_requested(self, recovery: PasswordRecovery, minutes: int = 3) -&gt; bool:\n    \"\"\"\n    Verifica si la recuperaci\u00f3n de contrase\u00f1a se solicit\u00f3 recientemente.\n\n    Args:\n        recovery (PasswordRecovery): Objeto de recuperaci\u00f3n de contrase\u00f1a.\n        minutes (int, optional): N\u00famero de minutos para considerar una solicitud reciente. Por defecto es 3.\n\n    Returns:\n        bool: True si la solicitud fue reciente, False en caso contrario.\n    \"\"\"\n    return (datetime_utc_time() - ensure_utc(recovery.created_at)).total_seconds() &lt; minutes * 60\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-reenvio-de-pin-de-recuperacion","title":"M\u00e9todos Principales de reenv\u00edo de PIN de recuperaci\u00f3n","text":""},{"location":"user/use_cases/#resend_recovery","title":"resend_recovery","text":"<p>Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>Tareas en segundo plano para enviar el correo.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado              un reenv\u00edo recientemente, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\resend_recovery_use_case.py</code> <pre><code>def resend_recovery(self, email: str, background_tasks: BackgroundTasks) -&gt; SuccessResponse:\n    \"\"\"\n    Reenv\u00eda el PIN de recuperaci\u00f3n de contrase\u00f1a.\n\n    Este m\u00e9todo valida el estado del usuario, verifica si se ha solicitado recientemente\n    un reenv\u00edo, genera un nuevo PIN y lo env\u00eda por correo electr\u00f3nico.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario que solicita el reenv\u00edo.\n        background_tasks (BackgroundTasks): Tareas en segundo plano para enviar el correo.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que se ha reenviado el PIN de recuperaci\u00f3n.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay un registro de recuperaci\u00f3n pendiente, se ha solicitado\n                         un reenv\u00edo recientemente, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    warning_time = 3\n\n    if recovery.resends &gt; 0:\n        if self.was_recently_requested(recovery, warning_time):\n            raise DomainException(\n                message=f\"Ya has solicitado un PIN de recuperaci\u00f3n recientemente. Por favor, espera {warning_time} minutos antes de solicitar uno nuevo.\",\n                status_code=status.HTTP_429_TOO_MANY_REQUESTS\n            )\n\n    pin, pin_hash = generate_pin()\n\n    background_tasks.add_task(self.send_password_recovery_email, email, pin)\n\n    recovery.pin = pin_hash\n    recovery.expiracion = datetime_utc_time() + timedelta(minutes=10)\n    recovery.intentos = 0\n    recovery.resends += 1\n    self.user_repository.update_password_recovery(recovery)\n    return SuccessResponse(\n        message=\"Se ha reenviado el PIN de recuperaci\u00f3n a tu correo electr\u00f3nico.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-restablecimiento-de-contrasena","title":"Caso de Uso: Restablecimiento de Contrase\u00f1a","text":"<p>Caso de uso para restablecer la contrase\u00f1a de un usuario.</p> <p>Esta clase maneja el proceso de restablecimiento de contrase\u00f1a, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN de recuperaci\u00f3n, y la actualizaci\u00f3n de la contrase\u00f1a en la base de datos.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> <code>state_validator</code> <code>UserStateValidator</code> <p>Validador del estado del usuario.</p> Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>class ResetPasswordUseCase:\n    \"\"\"\n    Caso de uso para restablecer la contrase\u00f1a de un usuario.\n\n    Esta clase maneja el proceso de restablecimiento de contrase\u00f1a, incluyendo\n    la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN de recuperaci\u00f3n,\n    y la actualizaci\u00f3n de la contrase\u00f1a en la base de datos.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n        state_validator (UserStateValidator): Validador del estado del usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de ResetPasswordUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n        self.state_validator = UserStateValidator(db)\n\n    def reset_password(self, email: str, new_password: str) -&gt; SuccessResponse:\n        \"\"\"\n        Restablece la contrase\u00f1a de un usuario.\n\n        Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n        de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.\n\n        Args:\n            email (str): Correo electr\u00f3nico del usuario.\n            new_password (str): Nueva contrase\u00f1a a establecer.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.\n\n        Raises:\n            UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n            DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,\n                             la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.\n        \"\"\"\n        user = self.user_repository.get_user_with_password_recovery(email)\n        if not user:\n            raise UserNotRegisteredException()\n\n        state_validation_result = self.state_validator.validate_user_state(\n            user,\n            allowed_states=[UserState.ACTIVE],\n            disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n        )\n        if state_validation_result:\n            return state_validation_result\n\n        recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n\n        if not recovery:\n            raise DomainException(\n                message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n                status_code=status.HTTP_404_NOT_FOUND\n            )\n\n        if not recovery.pin_confirmado:\n            raise DomainException(\n                message=\"El PIN de recuperaci\u00f3n no ha sido confirmado.\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        if verify_password(new_password, user.password):\n            raise DomainException(\n                message=\"Aseg\u00farate de que la nueva contrase\u00f1a sea diferente de la anterior\",\n                status_code=status.HTTP_400_BAD_REQUEST\n            )\n\n        user.password = hash_password(new_password)\n        if not self.user_repository.update_user(user):\n            raise DomainException(\n                message=\"No se pudo actualizar la contrase\u00f1a del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        if not self.user_repository.delete_password_recovery(recovery):\n            raise DomainException(\n                message=\"No se pudo eliminar el registro de recuperaci\u00f3n de contrase\u00f1a.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessResponse(\n            message= \"Contrase\u00f1a restablecida correctamente.\"\n        )\n\n    def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n        \"\"\"\n        Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n        Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n        Args:\n            recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n        Returns:\n            Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n        \"\"\"\n        if isinstance(recovery, list) and recovery:\n            recovery.sort(key=lambda r: r.created_at)\n            latest_recovery = recovery[-1]\n            for old_recovery in recovery[:-1]:\n                self.user_repository.delete_password_recovery(old_recovery)\n            return latest_recovery\n        return None\n</code></pre> <p>Este caso de uso maneja el proceso de restablecimiento de contrase\u00f1a, incluyendo la validaci\u00f3n del estado del usuario, la verificaci\u00f3n del PIN de recuperaci\u00f3n, y la actualizaci\u00f3n de la contrase\u00f1a en la base de datos.</p>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.reset_password_use_case.ResetPasswordUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de ResetPasswordUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de ResetPasswordUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n    self.state_validator = UserStateValidator(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.reset_password_use_case.ResetPasswordUseCase.get_last_password_recovery","title":"<code>get_last_password_recovery(recovery)</code>","text":"<p>Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.</p> <p>Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.</p> <p>Parameters:</p> Name Type Description Default <code>recovery</code> <code>PasswordRecovery</code> <p>Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.</p> required <p>Returns:</p> Type Description <code>Optional[PasswordRecovery]</code> <p>Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.</p> Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>def get_last_password_recovery(self, recovery: PasswordRecovery) -&gt; Optional[PasswordRecovery]:\n    \"\"\"\n    Obtiene la \u00faltima recuperaci\u00f3n de contrase\u00f1a del usuario.\n\n    Esta funci\u00f3n tambi\u00e9n elimina todas las recuperaciones anteriores a la \u00faltima.\n\n    Args:\n        recovery (PasswordRecovery): Objeto o lista de objetos de recuperaci\u00f3n de contrase\u00f1a.\n\n    Returns:\n        Optional[PasswordRecovery]: La \u00faltima recuperaci\u00f3n de contrase\u00f1a, o None si no hay ninguna.\n    \"\"\"\n    if isinstance(recovery, list) and recovery:\n        recovery.sort(key=lambda r: r.created_at)\n        latest_recovery = recovery[-1]\n        for old_recovery in recovery[:-1]:\n            self.user_repository.delete_password_recovery(old_recovery)\n        return latest_recovery\n    return None\n</code></pre>"},{"location":"user/use_cases/#app.user.application.password_recovery_process.reset_password_use_case.ResetPasswordUseCase.reset_password","title":"<code>reset_password(email, new_password)</code>","text":"<p>Restablece la contrase\u00f1a de un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>new_password</code> <code>str</code> <p>Nueva contrase\u00f1a a establecer.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,              la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>def reset_password(self, email: str, new_password: str) -&gt; SuccessResponse:\n    \"\"\"\n    Restablece la contrase\u00f1a de un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        new_password (str): Nueva contrase\u00f1a a establecer.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,\n                         la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if not recovery.pin_confirmado:\n        raise DomainException(\n            message=\"El PIN de recuperaci\u00f3n no ha sido confirmado.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    if verify_password(new_password, user.password):\n        raise DomainException(\n            message=\"Aseg\u00farate de que la nueva contrase\u00f1a sea diferente de la anterior\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    user.password = hash_password(new_password)\n    if not self.user_repository.update_user(user):\n        raise DomainException(\n            message=\"No se pudo actualizar la contrase\u00f1a del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    if not self.user_repository.delete_password_recovery(recovery):\n        raise DomainException(\n            message=\"No se pudo eliminar el registro de recuperaci\u00f3n de contrase\u00f1a.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(\n        message= \"Contrase\u00f1a restablecida correctamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-restablecimiento-de-contrasena","title":"M\u00e9todos Principales de restablecimiento de contrase\u00f1a","text":""},{"location":"user/use_cases/#reset_password","title":"reset_password","text":"<p>Restablece la contrase\u00f1a de un usuario.</p> <p>Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>Correo electr\u00f3nico del usuario.</p> required <code>new_password</code> <code>str</code> <p>Nueva contrase\u00f1a a establecer.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.</p> <p>Raises:</p> Type Description <code>UserNotRegisteredException</code> <p>Si el usuario no est\u00e1 registrado.</p> <code>DomainException</code> <p>Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,              la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.</p> Source code in <code>app\\user\\application\\password_recovery_process\\reset_password_use_case.py</code> <pre><code>def reset_password(self, email: str, new_password: str) -&gt; SuccessResponse:\n    \"\"\"\n    Restablece la contrase\u00f1a de un usuario.\n\n    Este m\u00e9todo valida el estado del usuario, verifica la existencia de una solicitud\n    de recuperaci\u00f3n de contrase\u00f1a v\u00e1lida, y actualiza la contrase\u00f1a del usuario.\n\n    Args:\n        email (str): Correo electr\u00f3nico del usuario.\n        new_password (str): Nueva contrase\u00f1a a establecer.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la contrase\u00f1a se restableci\u00f3 correctamente.\n\n    Raises:\n        UserNotRegisteredException: Si el usuario no est\u00e1 registrado.\n        DomainException: Si no hay una solicitud de recuperaci\u00f3n v\u00e1lida, el PIN no est\u00e1 confirmado,\n                         la nueva contrase\u00f1a es igual a la anterior, o hay otros errores.\n    \"\"\"\n    user = self.user_repository.get_user_with_password_recovery(email)\n    if not user:\n        raise UserNotRegisteredException()\n\n    state_validation_result = self.state_validator.validate_user_state(\n        user,\n        allowed_states=[UserState.ACTIVE],\n        disallowed_states=[UserState.INACTIVE, UserState.PENDING, UserState.LOCKED]\n    )\n    if state_validation_result:\n        return state_validation_result\n\n    recovery = self.get_last_password_recovery(user.recuperacion_contrasena)\n\n    if not recovery:\n        raise DomainException(\n            message=\"No hay un registro de recuperaci\u00f3n de contrase\u00f1a pendiente.\",\n            status_code=status.HTTP_404_NOT_FOUND\n        )\n\n    if not recovery.pin_confirmado:\n        raise DomainException(\n            message=\"El PIN de recuperaci\u00f3n no ha sido confirmado.\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    if verify_password(new_password, user.password):\n        raise DomainException(\n            message=\"Aseg\u00farate de que la nueva contrase\u00f1a sea diferente de la anterior\",\n            status_code=status.HTTP_400_BAD_REQUEST\n        )\n\n    user.password = hash_password(new_password)\n    if not self.user_repository.update_user(user):\n        raise DomainException(\n            message=\"No se pudo actualizar la contrase\u00f1a del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    if not self.user_repository.delete_password_recovery(recovery):\n        raise DomainException(\n            message=\"No se pudo eliminar el registro de recuperaci\u00f3n de contrase\u00f1a.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(\n        message= \"Contrase\u00f1a restablecida correctamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#otros-casos-de-uso","title":"Otros Casos de Uso","text":""},{"location":"user/use_cases/#caso-de-uso-cierre-de-sesion","title":"Caso de Uso: Cierre de Sesi\u00f3n","text":"<p>Caso de uso para gestionar el cierre de sesi\u00f3n de un usuario.</p> <p>Esta clase maneja el proceso de cerrar sesi\u00f3n, incluyendo la inclusi\u00f3n del token en la lista negra.</p> <p>Attributes:</p> Name Type Description <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>class LogoutUseCase:\n    \"\"\"\n    Caso de uso para gestionar el cierre de sesi\u00f3n de un usuario.\n\n    Esta clase maneja el proceso de cerrar sesi\u00f3n, incluyendo la inclusi\u00f3n\n    del token en la lista negra.\n\n    Attributes:\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de LogoutUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.user_repository = UserRepository(db)\n\n    def logout(self, token: str, user_id: int) -&gt; SuccessResponse:\n        \"\"\"\n        Realiza el proceso de cierre de sesi\u00f3n para un usuario.\n\n        Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta\n        de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.\n\n        Args:\n            token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n            user_id (int): ID del usuario que est\u00e1 cerrando sesi\u00f3n.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.\n\n        Raises:\n            DomainException: Si no se pudo cerrar la sesi\u00f3n.\n        \"\"\"\n        success = self.blacklist_token(token, user_id)\n        if not success:\n            raise DomainException(\n                message=\"No se pudo cerrar la sesi\u00f3n. Intenta nuevamente.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n        return SuccessResponse(\n                message=\"Sesi\u00f3n cerrada exitosamente.\"\n        )\n\n    def blacklist_token(self, token: str, user_id: int) -&gt; bool:\n        \"\"\"\n        Incluye un token en la lista negra.\n\n        Args:\n            token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n            user_id (int): ID del usuario asociado al token.\n\n        Returns:\n            bool: True si el token se incluy\u00f3 exitosamente en la lista negra, False en caso contrario.\n        \"\"\"\n        blacklisted = BlacklistedToken(token=token, usuario_id=user_id)\n        return self.user_repository.blacklist_token(blacklisted)\n</code></pre> <p>Este caso de uso maneja el proceso de cerrar sesi\u00f3n, incluyendo la inclusi\u00f3n del token en la lista negra.</p>"},{"location":"user/use_cases/#app.user.application.logout_use_case.LogoutUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de LogoutUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de LogoutUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.user_repository = UserRepository(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.logout_use_case.LogoutUseCase.blacklist_token","title":"<code>blacklist_token(token, user_id)</code>","text":"<p>Incluye un token en la lista negra.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token de autenticaci\u00f3n a incluir en la lista negra.</p> required <code>user_id</code> <code>int</code> <p>ID del usuario asociado al token.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True si el token se incluy\u00f3 exitosamente en la lista negra, False en caso contrario.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def blacklist_token(self, token: str, user_id: int) -&gt; bool:\n    \"\"\"\n    Incluye un token en la lista negra.\n\n    Args:\n        token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n        user_id (int): ID del usuario asociado al token.\n\n    Returns:\n        bool: True si el token se incluy\u00f3 exitosamente en la lista negra, False en caso contrario.\n    \"\"\"\n    blacklisted = BlacklistedToken(token=token, usuario_id=user_id)\n    return self.user_repository.blacklist_token(blacklisted)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.logout_use_case.LogoutUseCase.logout","title":"<code>logout(token, user_id)</code>","text":"<p>Realiza el proceso de cierre de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token de autenticaci\u00f3n a incluir en la lista negra.</p> required <code>user_id</code> <code>int</code> <p>ID del usuario que est\u00e1 cerrando sesi\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo cerrar la sesi\u00f3n.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def logout(self, token: str, user_id: int) -&gt; SuccessResponse:\n    \"\"\"\n    Realiza el proceso de cierre de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta\n    de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.\n\n    Args:\n        token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n        user_id (int): ID del usuario que est\u00e1 cerrando sesi\u00f3n.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.\n\n    Raises:\n        DomainException: Si no se pudo cerrar la sesi\u00f3n.\n    \"\"\"\n    success = self.blacklist_token(token, user_id)\n    if not success:\n        raise DomainException(\n            message=\"No se pudo cerrar la sesi\u00f3n. Intenta nuevamente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return SuccessResponse(\n            message=\"Sesi\u00f3n cerrada exitosamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-cierre-de-sesion","title":"M\u00e9todos Principales de cierre de sesi\u00f3n","text":""},{"location":"user/use_cases/#logout","title":"logout","text":"<p>Realiza el proceso de cierre de sesi\u00f3n para un usuario.</p> <p>Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Token de autenticaci\u00f3n a incluir en la lista negra.</p> required <code>user_id</code> <code>int</code> <p>ID del usuario que est\u00e1 cerrando sesi\u00f3n.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.</p> <p>Raises:</p> Type Description <code>DomainException</code> <p>Si no se pudo cerrar la sesi\u00f3n.</p> Source code in <code>app\\user\\application\\logout_use_case.py</code> <pre><code>def logout(self, token: str, user_id: int) -&gt; SuccessResponse:\n    \"\"\"\n    Realiza el proceso de cierre de sesi\u00f3n para un usuario.\n\n    Este m\u00e9todo intenta incluir el token en la lista negra y devuelve una respuesta\n    de \u00e9xito si se logra, o lanza una excepci\u00f3n si falla.\n\n    Args:\n        token (str): Token de autenticaci\u00f3n a incluir en la lista negra.\n        user_id (int): ID del usuario que est\u00e1 cerrando sesi\u00f3n.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que el cierre de sesi\u00f3n fue exitoso.\n\n    Raises:\n        DomainException: Si no se pudo cerrar la sesi\u00f3n.\n    \"\"\"\n    success = self.blacklist_token(token, user_id)\n    if not success:\n        raise DomainException(\n            message=\"No se pudo cerrar la sesi\u00f3n. Intenta nuevamente.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n    return SuccessResponse(\n            message=\"Sesi\u00f3n cerrada exitosamente.\"\n    )\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-obtener-usuario-actual","title":"Caso de Uso: Obtener Usuario Actual","text":"<p>Caso de uso para obtener la informaci\u00f3n del usuario actual.</p> <p>Esta clase maneja la l\u00f3gica para recuperar y validar la informaci\u00f3n del usuario actual.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos para realizar operaciones.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones de usuario.</p> Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>class GetCurrentUserUseCase:\n    \"\"\"\n    Caso de uso para obtener la informaci\u00f3n del usuario actual.\n\n    Esta clase maneja la l\u00f3gica para recuperar y validar la informaci\u00f3n del usuario actual.\n\n    Attributes:\n        db (Session): La sesi\u00f3n de base de datos para realizar operaciones.\n        user_repository (UserRepository): Repositorio para operaciones de usuario.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de GetCurrentUserUseCase.\n\n        Args:\n            db (Session): La sesi\u00f3n de base de datos a utilizar.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n\n    def get_current_user(self, current_user: UserInDB) -&gt; UserResponse:\n        \"\"\"\n        Obtiene la informaci\u00f3n del usuario actual.\n\n        Este m\u00e9todo verifica la existencia del usuario actual y su estado,\n        y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.\n\n        Args:\n            current_user (UserInDB): El usuario actual autenticado.\n\n        Returns:\n            UserResponse: La informaci\u00f3n del usuario mapeada a la respuesta.\n\n        Raises:\n            MissingTokenException: Si no se proporciona un usuario actual.\n            UserStateException: Si el estado del usuario no es reconocido.\n        \"\"\"\n        if not current_user:\n            raise MissingTokenException()\n\n        # Obtener el estado del usuario\n        estado = self.user_repository.get_state_by_id(current_user.state_id)\n        if not estado:\n            raise UserStateException(\n                message=\"Estado de usuario no reconocido.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                user_state=\"unknown\"\n            )\n\n        current_user.estado = estado\n        return map_user_to_response(current_user)\n</code></pre> <p>Este caso de uso maneja la l\u00f3gica para recuperar y validar la informaci\u00f3n del usuario actual.</p>"},{"location":"user/use_cases/#app.user.application.get_current_user_use_case.GetCurrentUserUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de GetCurrentUserUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>La sesi\u00f3n de base de datos a utilizar.</p> required Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de GetCurrentUserUseCase.\n\n    Args:\n        db (Session): La sesi\u00f3n de base de datos a utilizar.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.get_current_user_use_case.GetCurrentUserUseCase.get_current_user","title":"<code>get_current_user(current_user)</code>","text":"<p>Obtiene la informaci\u00f3n del usuario actual.</p> <p>Este m\u00e9todo verifica la existencia del usuario actual y su estado, y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>El usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>UserResponse</code> <code>UserResponse</code> <p>La informaci\u00f3n del usuario mapeada a la respuesta.</p> <p>Raises:</p> Type Description <code>MissingTokenException</code> <p>Si no se proporciona un usuario actual.</p> <code>UserStateException</code> <p>Si el estado del usuario no es reconocido.</p> Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>def get_current_user(self, current_user: UserInDB) -&gt; UserResponse:\n    \"\"\"\n    Obtiene la informaci\u00f3n del usuario actual.\n\n    Este m\u00e9todo verifica la existencia del usuario actual y su estado,\n    y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.\n\n    Args:\n        current_user (UserInDB): El usuario actual autenticado.\n\n    Returns:\n        UserResponse: La informaci\u00f3n del usuario mapeada a la respuesta.\n\n    Raises:\n        MissingTokenException: Si no se proporciona un usuario actual.\n        UserStateException: Si el estado del usuario no es reconocido.\n    \"\"\"\n    if not current_user:\n        raise MissingTokenException()\n\n    # Obtener el estado del usuario\n    estado = self.user_repository.get_state_by_id(current_user.state_id)\n    if not estado:\n        raise UserStateException(\n            message=\"Estado de usuario no reconocido.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    current_user.estado = estado\n    return map_user_to_response(current_user)\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-obtener-usuario-actual","title":"M\u00e9todos Principales de obtener usuario actual","text":""},{"location":"user/use_cases/#get_current_user","title":"get_current_user","text":"<p>Obtiene la informaci\u00f3n del usuario actual.</p> <p>Este m\u00e9todo verifica la existencia del usuario actual y su estado, y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>UserInDB</code> <p>El usuario actual autenticado.</p> required <p>Returns:</p> Name Type Description <code>UserResponse</code> <code>UserResponse</code> <p>La informaci\u00f3n del usuario mapeada a la respuesta.</p> <p>Raises:</p> Type Description <code>MissingTokenException</code> <p>Si no se proporciona un usuario actual.</p> <code>UserStateException</code> <p>Si el estado del usuario no es reconocido.</p> Source code in <code>app\\user\\application\\get_current_user_use_case.py</code> <pre><code>def get_current_user(self, current_user: UserInDB) -&gt; UserResponse:\n    \"\"\"\n    Obtiene la informaci\u00f3n del usuario actual.\n\n    Este m\u00e9todo verifica la existencia del usuario actual y su estado,\n    y devuelve la informaci\u00f3n del usuario mapeada a la respuesta adecuada.\n\n    Args:\n        current_user (UserInDB): El usuario actual autenticado.\n\n    Returns:\n        UserResponse: La informaci\u00f3n del usuario mapeada a la respuesta.\n\n    Raises:\n        MissingTokenException: Si no se proporciona un usuario actual.\n        UserStateException: Si el estado del usuario no es reconocido.\n    \"\"\"\n    if not current_user:\n        raise MissingTokenException()\n\n    # Obtener el estado del usuario\n    estado = self.user_repository.get_state_by_id(current_user.state_id)\n    if not estado:\n        raise UserStateException(\n            message=\"Estado de usuario no reconocido.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            user_state=\"unknown\"\n        )\n\n    current_user.estado = estado\n    return map_user_to_response(current_user)\n</code></pre>"},{"location":"user/use_cases/#caso-de-uso-actualizar-informacion-de-usuario","title":"Caso de Uso: Actualizar Informaci\u00f3n de Usuario","text":"<p>Caso de uso para actualizar la informaci\u00f3n de un usuario.</p> <p>Esta clase maneja el proceso de actualizaci\u00f3n de la informaci\u00f3n del usuario, incluyendo la verificaci\u00f3n de correo electr\u00f3nico duplicado.</p> <p>Attributes:</p> Name Type Description <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> <code>user_repository</code> <code>UserRepository</code> <p>Repositorio para operaciones relacionadas con usuarios.</p> Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>class UpdateUserInfoUseCase:\n    \"\"\"\n    Caso de uso para actualizar la informaci\u00f3n de un usuario.\n\n    Esta clase maneja el proceso de actualizaci\u00f3n de la informaci\u00f3n del usuario,\n    incluyendo la verificaci\u00f3n de correo electr\u00f3nico duplicado.\n\n    Attributes:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        user_repository (UserRepository): Repositorio para operaciones relacionadas con usuarios.\n    \"\"\"\n\n    def __init__(self, db: Session):\n        \"\"\"\n        Inicializa una nueva instancia de UpdateUserInfoUseCase.\n\n        Args:\n            db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n        \"\"\"\n        self.db = db\n        self.user_repository = UserRepository(db)\n\n    def update_user_info(self, current_user: User, user_update: UserUpdate) -&gt; SuccessResponse:\n        \"\"\"\n        Actualiza la informaci\u00f3n del usuario.\n\n        Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso,\n        actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.\n\n        Args:\n            current_user (User): Usuario actual cuya informaci\u00f3n se va a actualizar.\n            user_update (UserUpdate): Datos actualizados del usuario.\n\n        Returns:\n            SuccessResponse: Respuesta indicando que la actualizaci\u00f3n fue exitosa.\n\n        Raises:\n            UserAlreadyRegisteredException: Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.\n            DomainException: Si no se pudo actualizar la informaci\u00f3n del usuario.\n        \"\"\"\n        # Verificar si el email ya est\u00e1 en uso por otro usuario\n        if user_update.email != current_user.email:\n            if self.user_repository.get_user_by_email(user_update.email):\n                raise UserAlreadyRegisteredException()\n\n            current_user.email = user_update.email\n\n        current_user.nombre = user_update.nombre\n        current_user.apellido = user_update.apellido\n\n        if not self.user_repository.update_user(current_user):\n            raise DomainException(\n                message=\"No se pudo actualizar la informaci\u00f3n del usuario.\",\n                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n            )\n\n        return SuccessResponse(message=\"Usuario actualizado exitosamente\")\n</code></pre> <p>Este caso de uso maneja el proceso de actualizaci\u00f3n de la informaci\u00f3n del usuario, incluyendo la verificaci\u00f3n de correo electr\u00f3nico duplicado.</p>"},{"location":"user/use_cases/#app.user.application.update_user_info_use_case.UpdateUserInfoUseCase.__init__","title":"<code>__init__(db)</code>","text":"<p>Inicializa una nueva instancia de UpdateUserInfoUseCase.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>Session</code> <p>Sesi\u00f3n de base de datos para operaciones de persistencia.</p> required Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>def __init__(self, db: Session):\n    \"\"\"\n    Inicializa una nueva instancia de UpdateUserInfoUseCase.\n\n    Args:\n        db (Session): Sesi\u00f3n de base de datos para operaciones de persistencia.\n    \"\"\"\n    self.db = db\n    self.user_repository = UserRepository(db)\n</code></pre>"},{"location":"user/use_cases/#app.user.application.update_user_info_use_case.UpdateUserInfoUseCase.update_user_info","title":"<code>update_user_info(current_user, user_update)</code>","text":"<p>Actualiza la informaci\u00f3n del usuario.</p> <p>Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso, actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>User</code> <p>Usuario actual cuya informaci\u00f3n se va a actualizar.</p> required <code>user_update</code> <code>UserUpdate</code> <p>Datos actualizados del usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la actualizaci\u00f3n fue exitosa.</p> <p>Raises:</p> Type Description <code>UserAlreadyRegisteredException</code> <p>Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.</p> <code>DomainException</code> <p>Si no se pudo actualizar la informaci\u00f3n del usuario.</p> Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>def update_user_info(self, current_user: User, user_update: UserUpdate) -&gt; SuccessResponse:\n    \"\"\"\n    Actualiza la informaci\u00f3n del usuario.\n\n    Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso,\n    actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.\n\n    Args:\n        current_user (User): Usuario actual cuya informaci\u00f3n se va a actualizar.\n        user_update (UserUpdate): Datos actualizados del usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la actualizaci\u00f3n fue exitosa.\n\n    Raises:\n        UserAlreadyRegisteredException: Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.\n        DomainException: Si no se pudo actualizar la informaci\u00f3n del usuario.\n    \"\"\"\n    # Verificar si el email ya est\u00e1 en uso por otro usuario\n    if user_update.email != current_user.email:\n        if self.user_repository.get_user_by_email(user_update.email):\n            raise UserAlreadyRegisteredException()\n\n        current_user.email = user_update.email\n\n    current_user.nombre = user_update.nombre\n    current_user.apellido = user_update.apellido\n\n    if not self.user_repository.update_user(current_user):\n        raise DomainException(\n            message=\"No se pudo actualizar la informaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(message=\"Usuario actualizado exitosamente\")\n</code></pre>"},{"location":"user/use_cases/#metodos-principales-de-actualizacion-de-informacion-de-usuario","title":"M\u00e9todos Principales de actualizaci\u00f3n de informaci\u00f3n de usuario","text":""},{"location":"user/use_cases/#update_user_info","title":"update_user_info","text":"<p>Actualiza la informaci\u00f3n del usuario.</p> <p>Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso, actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>current_user</code> <code>User</code> <p>Usuario actual cuya informaci\u00f3n se va a actualizar.</p> required <code>user_update</code> <code>UserUpdate</code> <p>Datos actualizados del usuario.</p> required <p>Returns:</p> Name Type Description <code>SuccessResponse</code> <code>SuccessResponse</code> <p>Respuesta indicando que la actualizaci\u00f3n fue exitosa.</p> <p>Raises:</p> Type Description <code>UserAlreadyRegisteredException</code> <p>Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.</p> <code>DomainException</code> <p>Si no se pudo actualizar la informaci\u00f3n del usuario.</p> Source code in <code>app\\user\\application\\update_user_info_use_case.py</code> <pre><code>def update_user_info(self, current_user: User, user_update: UserUpdate) -&gt; SuccessResponse:\n    \"\"\"\n    Actualiza la informaci\u00f3n del usuario.\n\n    Este m\u00e9todo verifica si el nuevo correo electr\u00f3nico ya est\u00e1 en uso,\n    actualiza la informaci\u00f3n del usuario y guarda los cambios en la base de datos.\n\n    Args:\n        current_user (User): Usuario actual cuya informaci\u00f3n se va a actualizar.\n        user_update (UserUpdate): Datos actualizados del usuario.\n\n    Returns:\n        SuccessResponse: Respuesta indicando que la actualizaci\u00f3n fue exitosa.\n\n    Raises:\n        UserAlreadyRegisteredException: Si el nuevo correo electr\u00f3nico ya est\u00e1 en uso por otro usuario.\n        DomainException: Si no se pudo actualizar la informaci\u00f3n del usuario.\n    \"\"\"\n    # Verificar si el email ya est\u00e1 en uso por otro usuario\n    if user_update.email != current_user.email:\n        if self.user_repository.get_user_by_email(user_update.email):\n            raise UserAlreadyRegisteredException()\n\n        current_user.email = user_update.email\n\n    current_user.nombre = user_update.nombre\n    current_user.apellido = user_update.apellido\n\n    if not self.user_repository.update_user(current_user):\n        raise DomainException(\n            message=\"No se pudo actualizar la informaci\u00f3n del usuario.\",\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR\n        )\n\n    return SuccessResponse(message=\"Usuario actualizado exitosamente\")\n</code></pre>"}]}